

==================================================
SECTION: frontend.rst
PATH: developer/reference/frontend.rst
==================================================

:nosearch:
:hide-page-toc:

=============
Web framework
=============

.. toctree::
   :titlesonly:

   frontend/framework_overview
   frontend/assets
   frontend/javascript_modules
   frontend/owl_components
   frontend/registries
   frontend/services
   frontend/hooks
   frontend/patching_code
   frontend/error_handling
   frontend/javascript_reference
   frontend/mobile
   frontend/qweb
   frontend/odoo_editor
   frontend/unit_testing


==================================================
SECTION: assets.rst
PATH: developer/reference/frontend/assets.rst
==================================================


.. _reference/assets:

======
Assets
======

Managing assets in Odoo is not as straightforward as it is in some other apps.
One of the reasons is that we have a variety of situations where some, but not all
of the assets are required. For example, the needs of the web client, the point of
sale app, the website or even the mobile application are different. Also, some
assets may be large, but are seldom needed: in that case we may want them
to be :ref:`loaded lazily (on demand) <frontend/assets/lazy_loading>`.

Asset types
===========

There are three different asset types: code (`js` files), style (`css` or `scss`
files) and templates (`xml` files).

Code
    Odoo supports :ref:`three different kinds of javascript files<frontend/js_modules>`.
    All these files are then processed (native JS modules are transformed into odoo
    modules), then minified (if not in `debug=assets` :ref:`mode <frontend/framework/assets_debug_mode>`)
    and concatenated. The result is then saved as a file attachment. These file
    attachments are usually loaded via a `<script>` tag in the `<head>` part of
    the page (as a static file).

Style
    Styling can be done with either `css` or `scss <https://sass-lang.com/>`_. Like
    the javascript files, these files are processed (`scss` files are converted into
    `css`), then minified (again, if not in `debug=assets` :ref:`mode <frontend/framework/assets_debug_mode>`)
    and concatenated. The result is then saved as a file attachment. They are
    then usually loaded via a `<link>` tag in the `<head>` part of the page (as
    a static file).

Template
    Templates (static `xml` files) are handled in a different way: they are simply
    read from the file system whenever they are needed, and concatenated.

    Whenever the browser loads odoo, it calls the `/web/webclient/qweb/` controller
    to fetch the :ref:`templates <reference/qweb>`.

It is useful to know that in most cases, a browser only performs a request the
first time it loads a page. This is because each of these assets are
associated with a checksum, which is injected into the page source. The checksum
is then added to the url, which means that it is possible to safely set the cache
headers to a long period.

.. _reference/assets_bundle:

Bundles
=======

Odoo assets are grouped by *bundles*. Each bundle (a *list of file paths*
of specific types: `xml`, `js`, `css` or `scss`) is listed in the
:ref:`module manifest <reference/module/manifest>`. Files can be declared using
`glob <https://en.wikipedia.org/wiki/Glob_(programming)>`_ syntax, meaning that
you can declare several asset files using a single line.

The bundles are defined in each module's :file:`__manifest__.py`,
with a dedicated `assets` key which contains a dictionary. The dictionary maps
bundle names (keys) to the list of files they contain (values). It looks
like this:

.. code-block:: python

    'assets': {
        'web.assets_backend': [
            'web/static/src/xml/**/*',
        ],
        'web.assets_common': [
            'web/static/lib/bootstrap/**/*',
            'web/static/src/js/boot.js',
            'web/static/src/js/webclient.js',
            'web/static/src/xml/webclient.xml',
        ],
        'web.assets_unit_tests': [
            'web/static/src/js/webclient.test.js',
        ],
    },

Here is a list of some important bundles that most odoo developers will need to
know:

- `web.assets_common`: this bundle contains most assets which are common to the
  web client, the website and also the point of sale. This is supposed to contain
  lower level building blocks for the odoo framework. Note that it contains the
  :file:`boot.js` file, which defines the odoo module system.

- `web.assets_backend`: this bundle contains the code specific to the web client
  (notably the web client/action manager/views/static XML templates)

- `web.assets_frontend`: this bundle is about all that is specific to the public
  website: ecommerce, portal, forum, blog, ...

- `web.assets_unit_tests`: all javascript unit testing code (tests, helpers, mocks)

Operations
----------

Typically, handling assets is simple: you just need to add some new files
to a frequently used bundle like `assets_common` or `assets_backend`. But there are other operations
available to cover some more specific use cases.

Note that all directives targeting a certain asset file (i.e. `before`, `after`,
`replace` and `remove`) need that file to be declared beforehand, either
in manifests higher up in the hierarchy or in ``ir.asset`` records with a lower
sequence.

`append`
~~~~~~~~

This operation adds one or multiple file(s). Since it is the most common
operation, it can be done by simply using the file name:

.. code-block:: python

  'web.assets_common': [
      'my_addon/static/src/js/**/*',
  ],

By default, adding a simple string to a bundle will append the files matching the
glob pattern at the end of the bundle. Obviously, the pattern may also be directly
a single file path.

`prepend`
~~~~~~~~~

Add one or multiple file(s) at the beginning of the bundle.

Useful when you need to put a certain file before the others in a bundle (for
example with css files). The `prepend` operation is invoked with the following
syntax: `('prepend', <path>)`.

.. code-block:: python

  'web.assets_common': [
      ('prepend', 'my_addon/static/src/css/bootstrap_overridden.scss'),
  ],

`before`
~~~~~~~~

Add one or multiple file(s) before a specific file.

Prepending a file at the beginning of a bundle might not be precise enough. The
`before` directive can be used to add the given file(s) right *before* the target
file. It is declared by replacing the normal path with a 3-element tuple
`('before', <target>, <path>)`.

.. code-block:: python

  'web.assets_common': [
      ('before', 'web/static/src/css/bootstrap_overridden.scss', 'my_addon/static/src/css/bootstrap_overridden.scss'),
  ],

`after`
~~~~~~~

Add one or multiple file(s) after a specific file.

Same as `before`, with the matching file(s) appended right *after* the target file.
It is declared by replacing the normal path with a 3-element tuple
`('after', <target>, <path>)`.

.. code-block:: python

  'web.assets_common': [
      ('after', 'web/static/src/css/list_view.scss', 'my_addon/static/src/css/list_view.scss'),
  ],

`include`
~~~~~~~~~

Use nested bundles.

The `include` directive is a way to use a bundle in other bundles to minimize
the size of your manifest. In Odoo we use sub bundles (prefixed with an underscore
by convention) to batch files used in multiple other bundles. You can then
specify the sub bundle as a pair `('include', <bundle>)` like this:

.. code-block:: python

  'web.assets_common': [
      ('include', 'web._primary_variables'),
  ],

`remove`
~~~~~~~~

Remove one or multiple file(s).

In some cases, you may want to remove one or multiple files from a bundle. This
can be done using the `remove` directive by specifying a pair
`('remove', <target>)`:

.. code-block:: python

  'web.assets_common': [
      ('remove', 'web/static/src/js/boot.js'),
  ],

`replace`
~~~~~~~~~

Replace an asset file with one or multiple file(s).

Let us say that an asset needs not only to be removed, but you also want to insert
your new version of that asset at the same exact position. This can be done with
the `replace` directive, using a 3-element tuple `('replace', <target>, <path>)`:

.. code-block:: python

  'web.assets_common': [
      ('replace', 'web/static/src/js/boot.js', 'my_addon/static/src/js/boot.js'),
  ],


Loading order
-------------

The order in which assets are loaded is sometimes critical and must be deterministic,
mostly for stylesheets priorities and setup scripts. Assets in Odoo are processed
as follows:

#. When an asset bundle is called (e.g. `t-call-assets="web.assets_common"`), an empty
   list of assets is generated

#. All records of type `ir.asset` matching the bundle are fetched and sorted
   by sequence number. Then all records with a sequence strictly less than 16 are
   processed and applied to the current list of assets.

#. All modules declaring assets for said bundle in their manifest apply their
   assets operations to this list. This is done following the order of modules dependencies
   (e.g. `web` assets is processed before `website`). If a directive tries to add
   a file already present in the list, nothing is done for that file. In other word,
   only the first occurrence of a file is kept in the list.

#. The remaining `ir.asset` records (those with a sequence greater than or equal
   to 16) are then processed and applied as well.

Assets declared in the manifest may need to be loaded in a particular order, for
example :file:`jquery.js` must be loaded before all other jquery scripts when loading the
lib folder. One solution would be to create an :ref:`ir.asset <frontend/assets/ir_asset>`
record with a lower sequence or a 'prepend' directive, but there is another simpler
way to do so.

Since the unicity of each file path in the list of assets is guaranteed, you can
mention any specific file before a glob that includes it. That file will thus appear
in the list before all the others included in the glob.

.. code-block:: python

    'web.assets_common': [
        'my_addon/static/lib/jquery/jquery.js',
        'my_addon/static/lib/jquery/**/*',
    ],

.. note::

    A module *b* removing/replacing the assets declared in a module *a* will have
    to depend on it. Trying to operate on assets that have yet to be declared will
    result in an error.

.. _frontend/assets/lazy_loading:

Lazy loading
============

It is sometimes useful to load files and/or asset bundles dynamically, for
example to only load a library once it is needed. To do that, the Odoo framework
provides a few helper functions, located in :file:`@web/core/assets`.

.. code-block:: javascript

  await loadAssets({
      jsLibs: ["/web/static/lib/stacktracejs/stacktrace.js"],
  });


.. js:function:: loadAssets(assets)

    :param Object assets: a description of various assets that should be loaded
    :returns: Promise<void>

    Load the assets described by the `assets` parameter. It is an object that
    may contain the following keys:

    .. list-table::
      :widths: 20 20 60
      :header-rows: 1

      * - Key
        - Type
        - Description
      * - `jsLibs`
        - `string[]`
        - a list of urls of javascript files
      * - `cssLibs`
        - `string[]`
        - a list of urls of css files


.. js:function:: useAssets(assets)

    :param Object assets: a description of various assets that should be loaded

    This hook is useful when components need to load some assets in their
    `onWillStart` method. It internally calls `loadAssets`.

.. _frontend/assets/ir_asset:

The asset model (`ir.asset`)
============================

In most cases the assets declared in the manifest will largely suffice. Yet for
more flexibility, the framework also supports dynamic assets declared in the
database.

This is done by creating `ir.asset` records. Those will be processed as if they
were found in a module manifest, and they give the same expressive power as their
manifest counterparts.

.. autoclass:: odoo.addons.base.models.ir_asset.IrAsset

.. rst-class:: o-definition-list

`name`
    Name of the asset record (for identification purpose).

`bundle`
    Bundle in which the asset will be applied.

`directive` (default= `append`)
    This field determines how the `path` (and `target` if needed) will be interpreted.
    Here is the list of available directives along with their required arguments:

    - **append**: `path`
    - **prepend**: `path`
    - **before**: `target`, `path`
    - **after**: `target`, `path`
    - **include**: `path` (interpreted as a **bundle name**)
    - **remove**: `path` (interpreted as a **target asset** to remove)
    - **replace**: `target`, `path`

`path`
    A string defining one of the following:

    - a **relative path** to an asset file in the addons file system;
    - a **glob pattern** to a set of asset files in the addons file system;
    - a **URL** to an attachment or external asset file;
    - a **bundle name**, when using the `include` directive.

`target`
    Target file to specify a position in the bundle. Can only be used with the
    directives `replace`, `before` and `after`.

`active` (default= `True`)
    Whether the record is active

`sequence` (default= `16`)
    Loading order of the asset records (ascending). A sequence lower than 16 means
    that the asset will be processed *before* the ones declared in the manifest.

.. seealso::

    Note that the ``ir.asset`` use case is mainly for website-related
    applications, as it allows for conditional assets (for example, when a style
    option is enabled).

    In such cases, the ``<asset id="...">`` syntax should be preferred over the
    ``<record id="..." model="ir.asset">`` syntax when defining the record in
    XML.

    See :ref:`reference/data/asset`, especially about the ``active`` value.


==================================================
SECTION: error_handling.rst
PATH: developer/reference/frontend/error_handling.rst
==================================================

==============
Error handling
==============

In programming, error handling is a complex topic with many pitfalls, and it can
be even more daunting when you're writing code within the constraints of a framework,
as the way you handle errors needs to mesh with the way the framework dispatches
errors and vice versa.

This article paints the broad strokes of how errors are handled by the JavaScript
framework and Owl, and gives some recommendations on how to interface with these
systems in a way that avoids common problems.

Errors in JavaScript
====================

Before we dive into how errors are handled in Odoo as well as how and where to
customize error handling behavior, it's a good idea to make sure we're on the
same page when it comes to what we mean exactly by "error", as well as some of
the peculiarities of error handling in JavaScript.

The `Error` class
-----------------

The first thing that may come to mind when we talk about error handling is the
built-in `Error` class, or classes that extend it. In the rest of this article,
when we refer to an object that is an instance of this class, we will
use the term *Error object* in italics.

Anything can be thrown
----------------------

In JavaScript, you can throw any value. It is customary to throw *Error objects*,
but it is possible to throw any other object, and even primitives. While we don't
recommend that you ever throw anything that is not an *Error object*, the Odoo
JavaScript framework needs to be able to deal with these scenarios, which will
help you understand some design decisions that we've had to make.

When instanciating an *Error object*, the browser collects information about
the current state of the "call stack" (either a proper call stack, or a reconstructed
call stack for async functions and promise continuations). This information is
called a "stack trace" and is very useful for debugging. The Odoo framework displays
this stack trace in error dialogs when available.

When throwing a value that is not an *Error object*, the browser still collects
information about the current call stack, but this information is not available
in JavaScript: it is only available in the devtools console if the error is not
handled.

Throwing *Error objects* enables us to show more detailed information, which a
user will be able to copy/paste if needed for a bug report, but it also makes
error handling more robust as it allows us to filter errors based on their class
when handling them. Unfortunately, JavaScript does not have syntactic support for
filtering by error class in the catch clause, but you can relatively easily do
it yourself:

.. code-block:: javascript

  try {
    doStuff();
  } catch (e) {
    if (!(e instanceof MyErrorClass)) {
      throw e; // caught an error we can't handle, rethrow
    }
    // handle MyErrorClass
  }

Promise rejections are errors
-----------------------------

During the early days of Promise adoption, Promises were often treated as a way
to store a disjoint union of a result and an "error", and it was pretty common to
use a Promise rejection as a way to signal a soft failure. While it might seem like
a good idea at first glance, browsers and JavaScript runtimes have long
started to treat rejected Promises the same way as thrown errors in pretty much
every way:

- throwing in an async function has the same effect as returning a Promise that is
  rejected with the thrown value as its rejection reason.
- catch blocks in async functions catch rejected Promises that were awaited in the
  corresponding try block.
- runtimes collect stack information about rejected promises.
- a rejected Promise that is not caught synchronously dispatches an event on
  the global/window object, and if `preventDefault` is not called on the event,
  browsers log an error, and standalone runtimes like node kill the process.
- the debugger feature "pause on exceptions" pauses when Promises are rejected

For these reasons, the Odoo framework treats rejected Promises in the exact same
way as thrown errors. Do not create rejected promises in places where you would
not throw an error, and always reject Promises with *Error objects* as their rejection
reason.

`error` events are not errors
-----------------------------

With the exception of `error` events on the window, `error` events on other objects
such as `<media>`, `<audio>` `<img>`, `<script>` and `<link>` elements, or
XMLHttpRequest objects are not errors. For the purpose of this article, "error"
specifically refers only to thrown values and rejected promises. If you need to
handle errors on these elements or want them to be treated as errors, you need to
explicitly add an event listener for said event:

.. code-block:: javascript

  const scriptEl = document.createElement("script");
  scriptEl.src = "https://example.com/third_party_script.js";
  return new Promise((resolve, reject) => {
    scriptEl.addEventListener("error", reject);
    scriptEl.addEventListener("load", resolve);
    document.head.append(scriptEl);
  });

Lifecycle of errors within the Odoo JS framework
================================================

Thrown errors unwind their call stack to find a catch clause that can handle
them. The way an error is handled depends on what code is encountered while
unwinding the call stack. While there are a virtually infinite number of places
errors could be thrown from, there are only a few possible paths into the JS framework's
error handling code.

Throwing an error at the top-level of a module
----------------------------------------------

When a JS module is loaded, the code at the top level of that module is executed and
may throw. While the framework might report these errors with a dialog, module loading
is a critical moment for the JavaScript framework and some modules throwing errors
might prevent the framework code from booting entirely, so any error reporting at
this stage is "best effort". Errors thrown during module loading should however always
at the very least log an error message in the browser console. Because this type of
error is critical, there is no way for the application to recover and you should write
your code in such a way that it's impossible for the module to throw during definition.
Any error handling and reporting that does happen at this stage is purely with the
objective of helping you, the developer, fix the code that threw the error, and
we provide no mechanism to customize how these errors are handled.

The error service
-----------------

When an error is thrown but never caught, the runtime dispatches an event on the
global object (`window`). The type of the event depends on whether the error was
thrown synchronously or asynchronously: synchronously thrown errors dispatch
an `error` event, and errors thrown from within an asynchronous context as well as
rejected Promises dispatch an `unhandledrejection` event.

The JS framework contains a service that is dedicated to handling these events: the
error service. When receiving one of these events, the error service starts by creating
a new *Error object* that is used to wrap the error that was thrown; this is because
any value can be thrown, and Promises can be rejected with any value, including `undefined`
or `null`, meaning that it's not guaranteed that it contains any information, or that
we can store any information on that value. The wrapping *Error object* is used
to collect some information about the thrown value so that it can be used uniformly
in the framework code that needs to display information about errors of any type.

The error service stores a complete stack trace of the thrown error on this wrapper
*Error object* and, when the debug mode is `assets`, uses the source maps to add
information in this stack trace about the source file that contains the function
of each stack frame. The position of the function in the bundled assets is kept, as it can
be useful is some scenarios. When errors have a `cause`, this process also unwinds
the `cause` chain to build a complete composite stack trace. While the `cause` field
on *Error objects* is standard, some major browsers still do not display the full
stack trace of error chains. Because of this, we add this information manually.
This is particularly useful when errors are thrown within Owl hooks, more on that later.

Once the wrapper error contains all the required information, we start the process
of actually handling the error. To do this, the error service successively calls
all functions registered in the `error_handlers` registry, until one of these functions
returns a truthy value, which signals that the error has been handled. After this,
if `preventDefault` was not called on the error event, and if the error service was
able to add a stack trace on the wrapper error object, the error service calls
`preventDefault` on the error event, and logs the stack trace in the console. This
is because, as previously mentioned, some browsers do not display error chains correctly,
and the default behaviour of the event is the browser logging the error, so we simply
override that behaviour to log a more complete stack trace. If the error service was
not able to collect stack trace information about the thrown error, we do not call
`preventDefault`. This can happen when throwing non-error values: strings, undefined
or other random objects. In those cases, the browser logs the stack trace itself,
as it has that information but does not expose it to the JS code.

The `error_handlers` registry
-----------------------------

The `error_handlers` registry is the main way to extend the way that the JS framework
handles "generic" errors. Generic errors, in this context, means errors that can happen
in many places, but that should be handled uniformly. Some examples:

- UserError: when the user attempts to perform an operation that the python code
  deems invalid for business reasons, the python code raises a UserError, and the
  rpc function throws a corresponding error in JavaScript. This has the potential
  to happen on any rpc anywhere, and we do not want developers to have to handle this
  kind of error explicitly in all those places, and we want the same behavior to happen
  everywhere: stop the currently executing code (which is achieved by the throw),
  and display a dialog that explains to the user what went wrong.
- AccessError: same reasoning as for user errors: it can happen at any point and should
  be displayed the same way regardless of where it happens
- LostConnection: same reasoning again.

Throwing an error in an Owl component
-------------------------------------

Registering or modifying Owl components is the main way in which you can extend the
functionality of the web client. As such, most errors that are thrown are in one
way or another thrown from an Owl component. There are a few possible scenarios:

- Throwing in the component's setup or during rendering
- Throwing from within a lifecycle hook
- Throwing from an event handler

Throwing an error from an event handler or a function or method called directly or
indirectly from an event handler means that neither Owl's code nor the JS framework's
code is in the call stack. If you don't catch the error, it lands directly in
the error service.

When throwing an error in a component's setup or during rendering, Owl catches the
error and goes up the component hierarchy, allowing components that have registered
error handlers with the `onError` hook to attempt to handle the error. If the error
is not handled by any of them, Owl destroys the application as it is likely in a
corrupted state.

.. seealso::
  `Error handling in the Owl documentation <https://github.com/odoo/owl/blob/master/doc/reference/error_handling.md>`_

Inside Odoo, there are some places where we do not want the entire application to
crash in case of error, and so the framework has a few places where it uses the
`onError` hook. The action service wraps actions and views in a component that handles
errors. If a client action or view throws an error during rendering, it attempts
to go back to the previous action. The error is dispatched to the error service
so that an error dialog can be shown regardless. A similar strategy is used in most
places where the framework calls into "user" code: we generally stop displaying the
faulty component an show an error dialog.

When throwing an error inside of a hook's callback function, Owl creates a new
*Error object* that contains stack information about where the hook was registered,
and sets its cause as the originally thrown value. This is because the stack
trace of the original error contains no information about which component registered
this hook and where, it only contains information about what called the hook. Because
hooks are called by Owl code, most of this information is *generally* not very useful
for developers, but knowing where the hook was registered and by which component
is very useful.

When reading errors that mention "OwlError: the following error occurred in <hookName>",
make sure to read both parts of the composite stack trace:

.. code-block::
  :emphasize-lines: 4,12

  Error: The following error occurred in onMounted: "My error"
    at wrapError
    at onMounted
    at MyComponent.setup
    at new ComponentNode
    at Root.template
    at MountFiber._render
    at MountFiber.render
    at ComponentNode.initiateRender

  Caused by: Error: My error
    at ParentComponent.someMethod
    at MountFiber.complete
    at Scheduler.processFiber
    at Scheduler.processTasks

The first highlighted line tells you which component registered the `onMounted`
hook, while the second highlighted line tells you which function threw the error.
In this case, a child component is calling a function it received as prop from
its parent, and that function is a method of the parent component. Both pieces
of information can be useful, as the method could have been called by mistake by
the child (or at a point in the lifecycle where it shouldn't), but it could also
be that the parent's method contains a bug.

Marking errors as handled
-------------------------

In the previous sections, we talked about two ways to register error handlers: one
is adding them to the `error_handlers` registry, the other is using the `onError`
hook in owl. In both cases, the handler has to decide whether to mark the error as
handled.

`onError`
~~~~~~~~~

In the case of a handler registered in Owl with `onError`, the error is considered
by Owl as handled unless you rethrow it. Whatever you do in `onError`, the user
interface is likely not synchronized with the state of the application, as the error
prevented owl from completing some work. If you are unable to handle the error,
you should rethrow it, and let the rest of the code handle it.

If you don't rethrow the error, you need to change some state so that the application
can render again in a non-erroring way. At this point, if you don't rethrow the error
it will not be reported. In some cases this is desirable, but in most cases, what
you should do instead is dispatch this error in a separate call stack outside of
Owl. The easiest way to do this is to simply create a rejected Promise with the error
as its rejection reason:

.. code-block:: javascript

    import { Component, onError } from "@odoo/owl";
    class MyComponent extends Component {
      setup() {
        onError((error) => {
          // implementation of this method is left as an exercise for the reader
          this.removeErroringSubcomponent();
          Promise.reject(error); // create a rejected Promise without passing it anywhere
        });
      }
    }

This causes the browser to dispatch an `unhandledrejection` event on the window, which
causes the JS framework's error handling to kick in and deal with the error, in
most cases by opening a dialog with information about the error. This is the strategy
that is used internally by the action service and dialog service to stop rendering
broken actions or dialogs while still reporting the error.

Handler in the `error_handlers` registry
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Handlers that are added to the `error_handlers` registry can mark an error as being
handled in two ways, with different meanings.

The first way is that the handler can return a truthy value, this means that the
handler has processed the error and made something happen because the error it
received matched the type of error it is able to handle. This generally means it
has opened a dialog or notification to warn the user about the error. This prevents
the error service from calling the following handlers with higher sequence number.

The other way is to call `preventDefault` on the error event: this has a different
meaning. After deciding that it is able to handle the error, the handler needs to
decide if the error it received is something that is allowed to happen during
normal operation and if it is, it should call `preventDefault`. This is generally
applicable to business errors such as an access errors or validation errors: users can
share links with other users to ressources to which they do not have acces, and users
can attempt to save a record that's in an invalid state.

When not calling `preventDefault`, the error is treated as unexpected, any such
occurrence during a test causes the test to fail, as it's generally indicative
of defective code.


Avoid throwing errors as much as possible
=========================================

Errors introduce complexity in many ways, here are some reasons why you should
avoid throwing them.

Errors are expensive
--------------------

Because errors need to unwind the callstack and collect information as they do so,
throwing errors is slow. Additionally, JavaScript runtimes are generally optimized
with the assumption that exceptions are rare, and as such generally compiles the
code with the assumption that it doesn't throw, and fall back to a slower code path
if it ever does.

Throwing errors makes debugging harder
--------------------------------------

JavaScript debuggers, like the one included in the Chrome and Firefox devtools for example,
have a feature that allows you to pause the execution when an exception is thrown. You
can also choose whether to pause only on caught exceptions, or on both caught and uncaught
exceptions.

When you throw an error inside of code that is called by Owl or by the JavaScript
framework (e.g. in a field, view, action, component, ...), because they manage
resources, they need to catch errors and inspect them to decide whether the error
is critical and the application should crash, or if the error is expected and should
be handled in a particular manner.

Because of this, almost all errors that are thrown within JavaScript code are
caught at some point, and although they may be rethrown if they cannot be handled,
this means that using the "pause on uncaught exceptions" feature is effectively useless
while working within Odoo, as it always pauses within the JavaScript framework
code, instead of near the code that threw the error originally.

However, the "pause on caught exceptions" feature is still very useful, as it
pauses execution on every throw statement and rejected promise. This allows the
developer to stop and inspect the execution context whenever an exceptional
situation occurs.

However, this is only true assuming that exceptions are rarely thrown. If exceptions
are thrown routinely, any action within the page can cause the debugger to stop the execution,
and the developer might need to step through many "routine" exceptions before they
can get to the actual exceptional scenario they are interested in. In some situations,
because clicking the play button in the debugger removes focus from the page, it may
even make the interesting throw scenario inaccessible without using the keyboard shortcut
for resuming execution which results in poor developer experience.


Throwing breaks the normal flow of the code
-------------------------------------------

When throwing an error, code that looks like it should always execute may be skipped, this
can cause many subtle bugs and memory leaks. Here is a simple example:

.. code-block:: javascript

    eventTarget.addEventListener("event", handler);
    someFunction();
    eventTarget.removeEventListener("event", handler);

In this block of code, we add an event listener to an event target, then call a function
which may dispatch events on that target. After the function call, we remove the event
listener.

If `someFunction` throws, the event listener will never be removed. This means that the
memory associated with this event listener is effectively leaked and will never be
freed unless the eventTarget itself gets deallocated.

On top of the memory being leaked, the handler still being attached means that it may be
called for events being dispatched for reasons other than the call to `someFunction`.
This is a bug.

To account for this, one would need to wrap the call in a `try` block, and the cleanup in a
`finally` block:

.. code-block:: javascript

    eventTarget.addEventListener("event", handler);
    try {
      someFunction();
    } finally {
      eventTarget.removeEventListener("event", handler);
    }

While this now avoids the problems mentioned above, not only does this require more code,
it also requires knowledge that the function may throw. It would be unmanageable to wrap
all code that may throw in a `try/finally` block.

Catching errors
===============

Sometimes, you need to call into code that is known to throw errors and you want
to handle some of these errors. There are two important things to keep in mind:

- Rethrow errors that are not the type of error you expect. This should generally
  be done with and `instanceof` check
- Keep the try block as small as possible. This avoid catching errors that are not
  the one you're trying to catch. Generally, the try block should contain exactly
  *one* statement.

.. code-block:: javascript

    let someVal;
    try {
      someVal = someFunction();
      // do not start working with someVal here.
    } catch (e) {
      if (!(e instanceof MyError)) {
        throw e;
      }
      someVal = null;
    }
    // start working with someVal here

While this is straightforward with try/catch, it's much easier to accidentally wrap
a much larger portion of code in a catch clause when working with `Promise.catch`:

.. code-block:: javascript

    someFunction().then((someVal) => {
      // work with someVal
    }).catch((e) => {
      if (!(e instanceof MyError)) {
        throw e;
      }
      return null;
    });

In this example, the catch block is actually catching errors in the entire then
block, which is not what we want. In this particular example, because we properly
filter based on the error type, we're not swallowing the error, but you can see
that it may be much easier to do so if we're expecting a single error type and decide
not to have the instanceof check. Notice however that unlike the previous example,
the null isn't going through the codepath that uses `someVal`. To avoid this,
catch clauses should generally be as close as possible to the promise that may throw,
and should always filter on the error type.

Error free control flow
=======================

For the reasons outlined above, you should avoid throwing errors for doing routine
things, and in particular, for control flow. If a function is expected to be unable
to complete its work on a regular basis, it should communicate that failure without
throwing an exception. Consider the example code:

.. code-block:: javascript

    let someVal;
    try {
      someVal = someFunction();
    } catch (e) {
      if (!(e instanceof MyError)) {
        throw e;
      }
      someVal = null;
    }

There are many things that are problematic with this code. First, because we want
the variable `someVal` to be accessible after the `try/catch` block, it needs to be
declared before that block, and it cannot be `const` since it needs to be assigned
after initialization. This hurts readability further down the road as you now have
to look out for this variable potentially being reassigned later in the code.

Second, when we catch the error, we have to check that the error is actually the type
of error we were expecting to catch, and if not, rethrow the error. If we don't do
this, we might end up swallowing errors that were *actually* unexpected instead of
reporting them correctly, e.g. we could be catching and swallowing a TypeError if the
underlying code tries to access a property on `null` or `undefined`.

Lastly, not only is this very verbose, but it's easy to do this incorrectly: if you
forget to add the `try/catch`, you are likely to end up with a traceback. If you add
the `try/catch` block but forget to rethrow unexpected errors, you are swallowing
unrelated errors. And if you want to avoid having to reassign the variable you may
move the entire block that uses the variable inside the `try` block. The more code
you have inside your `try` block, the more likely you are to catch unrelated errors,
and swallow them if you forgot to filter by error type. It also adds an indentation
level to the entire block, and you may even end up with nested `try/catch` blocks.
Lastly, it makes it harder to identify which line is actually expected to throw the
error.

The following sections outline some alternative approaches you can use instead of
using errors.

Return `null` or `undefined`
----------------------------

If the function returns a primitive or an object, you can generally use `null` or
`undefined` to signal that it was unable to do its intended job. This suffices in
most cases. The code ends up looking something like this:

.. code-block:: javascript

    const someVal = someFunction();
    // further
    if (someVal !== null) { /* do something */ }

As you can see, this is much simpler.

Return an object or array
-------------------------

In some cases, a value of `null` or `undefined` is part of the expected return values.
In those cases, you can instead return a wrapper object or a two-element array that
contains either the return value or the error:

.. code-block:: javascript

    const { val: someVal, err } = someFunction();
    if (err) {
      return;
    }
    // do something with someVal as it is known to be valid

Or with an array:

.. code-block:: javascript

    const [err, someVal] = someFunction();
    if (err) {
      return;
    }
    // do something with someVal as it is known to be valid

.. note::

    When using a two-element array, it is advisable to have the error be the first
    element, so that it is harder to ignore by mistake when destructuring. One would
    need to explicitly add a placeholder or comma to skip the error, whereas if the
    error is the second element, it is easy to simply destructure only the first
    element and mistakenly forget to handle the error.

When to throw errors
====================

The previous sections give many good reasons to avoid throwing errors, so what are
some examples of cases where throwing an error is the best course of action?

- Generic errors that can happen in many places but should be treated the same everywhere;
  e.g., access errors can happen on basically any RPC, and we always want to display
  information about why the user doesn't have access.
- Some precondition that should always be fulfilled for some operation is not fulfilled;
  e.g., a view couldn't be rendered because the domain is invalid. These types of error
  are generally not intended to be caught anywhere and signal that code is incorrect
  or data is corrupted. Throwing forces the framework to bail out and prevents
  operating in a broken state.
- When traversing some deep data structure recursively, throwing an error can be more
  ergonomic and less error prone than having to manually test for errors and forward
  them through many levels of calls. This should be very rare in practice, and needs
  to be weighed against all the disadvantages mentioned in this article.


==================================================
SECTION: framework_overview.rst
PATH: developer/reference/frontend/framework_overview.rst
==================================================

==================
Framework Overview
==================

Introduction
============

The Odoo Javascript framework is a set of features/building blocks provided by
the ``web/`` addon to help build odoo applications running in the browser. At
the same time, the Odoo Javascript framework is a single page application,
usually known as the *web client* (available at the url ``/web``).

The web client started as an application made with a custom class and widget
system, but it is now transitioning to using native javascript classes instead,
and Owl as a component system. This explains why both systems are currently in
use in the codebase.

From a high-level perspective, the web client is a single-page application: it
does not need to request a full page from the server each time the user performs
an action. Instead, it only requests what it needs and then replaces/updates the
current screen accordingly. Also, it manages the url to keep it in sync with
the current state.

The javascript framework (all or some parts) is also used in other situations,
such as the Odoo website or the point of sale. This reference is mostly focused
on the web client.

.. note::

    It is common in the Odoo ecosystem to see the words *frontend* and *backend*
    as synonyms for the odoo website (public) and the web client, respectively.
    This terminology is not to be confused with the more common use of
    browser-code (frontend) and server (backend).

.. note::

    In this documentation, the word *component* always refers to new Owl
    components, and *widget* refers to old Odoo widgets.

.. note::

    All new development should be done in Owl, if possible!

Code structure
==============

The ``web/static/src`` folder contains all the ``web/`` javascript (and css and
templates) codebase. Here is a list of the most important folders:

- ``core/`` most of the low level features
- ``fields/`` all field components
- ``views/`` all javascript views components (``form``, ``list``, ...)
- ``search/`` control panel, search bar, search panel, ...
- ``webclient/`` the web client specific code: navbar, user menu, action service, ...

The ``web/static/src`` is the root folder. Everything inside can simply be
imported by using the ``@web`` prefix. For example, here is how one can import
the ``memoize`` function located in ``web/static/src/core/utils/functions``:

.. code-block:: javascript

    import { memoize } from "@web/core/utils/functions";

WebClient Architecture
======================

As mentioned above, the web client is an owl application. Here is a slightly
simplified version of its template:

.. code-block:: xml

    <t t-name="web.WebClient">
        <body class="o_web_client">
            <NavBar/>
            <ActionContainer/>
            <MainComponentsContainer/>
        </body>
    </t>

As we can see, it basically is a wrapper for a navbar, the current action and
some additional components. The ``ActionContainer`` is a higher order component
that will display the current action controller (so, a client action, or a
specific view in the case of actions of type ``act_window``). Managing actions
is a huge part of its work: the action service keeps in memory a stack of
all active actions (represented in the breadcrumbs), and coordinates each
change.

Another interesting thing to note is the ``MainComponentsContainer``: it is
simply a component that displays all components registered in the
``main_components`` registry. This is how other parts of the system can extend
the web client.

.. _frontend/framework/environment:

Environment
===========

As an Owl application, the Odoo web client defines its own environment (components
can access it using ``this.env``). Here is a description of what Odoo adds to
the shared ``env`` object:

.. list-table::
   :widths: 25 75
   :header-rows: 1

   * - Key
     - Value
   * - `qweb`
     - required by Owl (contains all templates)
   * - `bus`
     - :ref:`main bus <frontend/framework/bus>`, used to coordinate some generic events
   * - `services`
     - all deployed :ref:`services <frontend/services>` (should usually be accessed
       with the `useService` hook)
   * - `debug`
     - string. If non empty, the web client is in :ref:`debug mode <frontend/framework/debug_mode>`
   * - `_t`
     - translation function
   * - `isSmall`
     - boolean. If true, the web client is currently in mobile mode (screen width <= 767px)

So, for example, to translate a string in a component (note: templates are
automatically translated, so no specific action is required in that case), one
can do this:


.. code-block:: javascript

    const someString = this.env._t('some text');

.. note::

   Having a reference to the environment is quite powerful, because it provides
   access to all services. This is useful in many cases: for example,
   user menu items are mostly defined as a string, and a function taking the `env`
   as unique argument. This is enough to express all user menu needs.

Building Blocks
===============

Most of the web client is built with a few types of abstractions: registries,
services, components and hooks.

Registries
----------

:ref:`Registries <frontend/registries>` are basically a simple key/value mapping
that stores some specific kind of objects. They are an important part of the
extensibility of the UI: once some object is registered, the rest of the web
client can use it. For example, the field registry contains all field components
(or widgets) that can be used in views.

.. code-block:: javascript

    import { Component } from "@odoo/owl";
    import { registry } from "./core/registry";

    class MyFieldChar extends Component {
        // some code
    }

    registry.category("fields").add("my_field_char", MyFieldChar);

Note that we import the main registry from ``@web/core/registry`` then open the
sub registry ``fields``.

Services
--------

:ref:`Services <frontend/services>` are long lived pieces of code that provide a
feature. They may be imported by components (with ``useService``) or by other
services. Also, they can declare a set of dependencies. In that sense, services
are basically a DI (dependency injection) system. For example, the ``notification``
service provides a way to display a notification, or the ``rpc`` service is the
proper way to perform a request to the Odoo server.

The following example registers a simple service that displays a notification
every 5 second:

.. code-block:: javascript

    import { registry } from "./core/registry";

    const serviceRegistry = registry.category("services");

    const myService = {
        dependencies: ["notification"],
        start(env, { notification }) {
            let counter = 1;
            setInterval(() => {
                notification.add(`Tick Tock ${counter++}`);
            }, 5000);
        }
    };

    serviceRegistry.add("myService", myService);

Components and Hooks
--------------------

:ref:`Components <frontend/components>` and :ref:`hooks <frontend/hooks>` are ideas coming from the
`Owl component system <https://github.com/odoo/owl/blob/master/doc/readme.md>`_.
Odoo components are simply owl components that are part of the web client.

`Hooks <https://github.com/odoo/owl/blob/master/doc/reference/hooks.md>`_ are a
way to factorize code, even if it depends on lifecycle. This is a
composable/functional way to inject a feature in a component. They can be seen
as a kind of mixin.

.. code-block:: javascript

    function useCurrentTime() {
        const state = useState({ now: new Date() });
        const update = () => state.now = new Date();
        let timer;
        onWillStart(() => timer = setInterval(update, 1000));
        onWillUnmount(() => clearInterval(timer));
        return state;
    }

Context
=======

An important concept in the Odoo javascript is the *context*: it provides a way
for code to give more context to a function call or a rpc, so other parts of the
system can properly react to that information. In some way, it is like a bag of
information that is propagated everywhere. It is useful in some situations, such
as letting the Odoo server know that a model rpc comes from a specific form view,
or activating/disabling some features in a component.

There are two different contexts in the Odoo web client: the *user context* and
the *action context* (so, we should be careful when using the word *context*: it
could mean a different thing depending on the situation).

.. note::
   The `context` object may be useful in many cases, but one should be careful
   not to overuse it! Many problems can be solved in a standard way without
   modifying the context.

.. _frontend/framework/user_context:

User Context
------------

The *user context* is a small object containing various informations related to
the current user. It is available through the `user` service:

.. code-block:: javascript

    class MyComponent extends Component {
        setup() {
            const user = useService("user");
            console.log(user.context);
        }
    }

It contains the following information:


.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `allowed_company_ids`
      - `number[]`
      - the list of active company ids for the user
    * - `lang`
      - `string`
      - the user language code (such as "en_us")
    * - `tz`
      - `string`
      - the user current timezone (for example "Europe/Brussels")

In practice, the `orm` service automatically adds the user context to each of
its requests. This is why it is usually not necessary to import it directly in
most cases.

.. note::
   The first element of the `allowed_company_ids` is the main company of the user.

Action Context
--------------

The :ref:`ir.actions.act_window<reference/actions/window>` and
:ref:`ir.actions.client<reference/actions/client>` support an optional `context` field.
This field is a `char` that represents an object. Whenever the corresponding
action is loaded in the web client, this context field will be evaluated as an
object and given to the component that corresponds to the action.

.. code-block:: xml

    <field name="context">{'search_default_customer': 1}</field>

It can be used in many different ways. For example, the views add the
action context to every requests made to the server. Another important use is to
activate some search filter by default (see example above).

Sometimes, when we execute new actions manually (so, programmatically, in javascript),
it is useful to be able to extend the action context. This can be done with the
`additional_context` argument.

.. code-block:: javascript

    // in setup
    let actionService = useService("action");

    // in some event handler
    actionService.doAction("addon_name.something", {
        additional_context:{
            default_period_id: defaultPeriodId
        }
    });

In this example, the action with xml_id `addon_name.something` will be loaded,
and its context will be extended with the `default_period_id` value. This is a
very important usecase that lets developers combine actions together by providing
some information to the next action.

.. _frontend/framework/pyjs:

Python Interpreter
==================

The Odoo framework features a built-in small python interpreter. Its purpose
is to evaluate small python expressions. This is important, because views in
Odoo have modifiers written in python, but they need to be evaluated by the
browser.

Example:

.. code-block:: javascript

   import { evaluateExpr } from "@web/core/py_js/py";

   evaluateExpr("1 + 2*{'a': 1}.get('b', 54) + v", { v: 33 }); // returns 142


The ``py`` javascript code exports 5 functions:

.. js:function:: tokenize(expr)

  :param string expr: the expression to tokenize
  :returns: Token[] a list of token

.. js:function:: parse(tokens)

  :param Token[] tokens: a list of tokens
  :returns: AST an abstract syntax tree structure representing the expression

.. js:function:: parseExpr(expr)

  :param string expr: a string representing a valid python expression
  :returns: AST an abstract syntax tree structure representing the expression

.. js:function:: evaluate(ast[, context])

  :param AST ast: a AST structure that represents an expression
  :param Object context: an object that provides an additional evaluation context
  :returns: any the resulting value of the expression, with respect to the context

.. js:function:: evaluateExpr(expr[, context])

  :param string expr: a string representing a valid python expression
  :param Object context: an object that provides an additional evaluation context
  :returns: any the resulting value of the expression, with respect to the context

.. _frontend/framework/domains:

Domains
=======

Broadly speaking, domains in Odoo represent a set of records that matches some
specified conditions. In javascript, they are usually represented either as a
list of conditions (or of operators: `|`, `&` or `!` in prefix notation), or as string
expressions. They don't have to be normalized (the `&` operator is implied if
necessary). For example:

.. code-block:: javascript

  // list of conditions
  []
  [["a", "=", 3]]
  [["a", "=", 1], ["b", "=", 2], ["c", "=", 3]]
  ["&", "&", ["a", "=", 1], ["b", "=", 2], ["c", "=", 3]]
  ["&", "!", ["a", "=", 1], "|", ["a", "=", 2], ["a", "=", 3]]

  // string expressions
  "[('some_file', '>', a)]"
  "[('date','>=', (context_today() - datetime.timedelta(days=30)).strftime('%Y-%m-%d'))]"
  "[('date', '!=', False)]"

String expressions are more powerful than list expressions: they can contain
python expressions and unevaluated values, that depends on some evaluation context.
However, manipulating string expressions is more difficult.

Since domains are quite important in the web client, Odoo provides a `Domain`
class:

.. code-block:: javascript

    new Domain([["a", "=", 3]]).contains({ a: 3 }) // true

    const domain = new Domain(["&", "&", ["a", "=", 1], ["b", "=", 2], ["c", "=", 3]]);
    domain.contains({ a: 1, b: 2, c: 3 }); // true
    domain.contains({ a: -1, b: 2, c: 3 }); // false

    // next expression returns ["|", ("a", "=", 1), ("b", "<=", 3)]
    Domain.or([[["a", "=", 1]], "[('b', '<=', 3)]"]).toString();

Here is the `Domain` class description:

.. js:class:: Domain([descr])

  :param descr: a domain description
  :type descr: string | any[] | Domain

  .. js:method:: contains(record)

    :param Object record: a record object
    :returns: boolean

    Returns true if the record matches all the condition specified by the domain

  .. js:method:: toString()

    :returns: string

    Returns a string description for the domain

  .. js:method:: toList([context])

    :param Object context: evaluation context
    :returns: any[]

    Returns a list description for the domain. Note that this method takes an
    optional `context` object that will be used to replace all free variables.

    .. code-block:: javascript

      new Domain(`[('a', '>', b)]`).toList({ b:3 }); // [['a', '>', 3]]

The `Domain` class also provides 4 useful static methods to combine domains:

.. code-block:: javascript

    // ["&", ("a", "=", 1), ("uid", "<=", uid)]
    Domain.and([[["a", "=", 1]], "[('uid', '<=', uid)]"]).toString();

    // ["|", ("a", "=", 1), ("uid", "<=", uid)]
    Domain.or([[["a", "=", 1]], "[('uid', '<=', uid)]"]).toString();

    // ["!", ("a", "=", 1)]
    Domain.not([["a", "=", 1]]).toString();

    // ["&", ("a", "=", 1), ("uid", "<=", uid)]
    Domain.combine([[["a", "=", 1]], "[('uid', '<=', uid)]"], "AND").toString();


.. staticmethod:: Domain.and(domains)

  :param domains: a list of domain representations
  :type domains: string[] | any[][] | Domain[]
  :returns: Domain

  Returns a domain representing the intersection of all domains.

.. staticmethod:: Domain.or(domains)

  :param domains: a list of domain representations
  :type domains: string[] | any[][] | Domain[]
  :returns: Domain

  Returns a domain representing the union of all domains.

.. staticmethod:: Domain.not(domain)

  :param domain: a domain representation
  :type domain: string | any[] | Domain
  :returns: Domain

  Returns a domain representing the negation of the domain argument

.. staticmethod:: Domain.combine(domains, operator)

  :param domains: a list of domain representations
  :type domains: string[] | any[][] | Domain[]
  :param operator: an operator
  :type operator: 'AND' or 'OR'

  :returns: Domain

  Returns a domain representing either the intersection or the union of all the
  domains, depending on the value of the operator argument.

.. _frontend/framework/bus:

Bus
===

The web client :ref:`environment <frontend/framework/environment>` object contains an event
bus, named `bus`. Its purpose is to allow various parts of the system to properly
coordinate themselves, without coupling them. The `env.bus` is an owl
`EventBus <https://github.com/odoo/owl/blob/master/doc/reference/event_bus.md>`_,
that should be used for global events of interest.


.. code-block:: javascript

   // for example, in some service code:
   env.bus.on("WEB_CLIENT_READY", null, doSomething);

Here is a list of the events that can be triggered on this bus:

.. list-table::
   :header-rows: 1

   * - Message
     - Payload
     - Trigger
   * - ``ACTION_MANAGER:UI-UPDATED``
     - a mode indicating what part of the ui has been updated ('current', 'new' or 'fullscreen')
     - the rendering of the action requested to the action manager is done
   * - ``ACTION_MANAGER:UPDATE``
     - next rendering info
     - the action manager has finished computing the next interface
   * - ``MENUS:APP-CHANGED``
     - none
     - the menu service's current app has changed
   * - ``ROUTE_CHANGE``
     - none
     - the url hash was changed
   * - ``RPC:REQUEST``
     - rpc id
     - a rpc request has just started
   * - ``RPC:RESPONSE``
     - rpc id
     - a rpc request is completed
   * - ``WEB_CLIENT_READY``
     - none
     - the web client has been mounted
   * - ``FOCUS-VIEW``
     - none
     - the main view should focus itself
   * - ``CLEAR-CACHES``
     - none
     - all internal caches should be cleared
   * - ``CLEAR-UNCOMMITTED-CHANGES``
     - list of functions
     - all views with uncommitted changes should clear them, and push a callback in the list


Browser Object
==============

The javascript framework also provides a special object ``browser`` that
provides access to many browser APIs, like ``location``, ``localStorage``
or ``setTimeout``.  For example, here is how one could use the
``browser.setTimeout`` function:

.. code-block:: javascript

    import { browser } from "@web/core/browser/browser";

    // somewhere in code
    browser.setTimeout(someFunction, 1000);

It is mostly interesting for testing purposes: all code using the browser object
can be tested easily by mocking the relevant functions for the duration of the
test.

It contains the following content:

.. list-table::

  * - `addEventListener`
    - `cancelAnimationFrame`
    - `clearInterval`
  * - `clearTimeout`
    - `console`
    - `Date`
  * - `fetch`
    - `history`
    - `localStorage`
  * - `location`
    - `navigator`
    - `open`
  * - `random`
    - `removeEventListener`
    - `requestAnimationFrame`
  * - `sessionStorage`
    - `setInterval`
    - `setTimeout`
  * - `XMLHttpRequest`
    -
    -

.. _frontend/framework/debug_mode:

Debug mode
==========

Odoo can sometimes operate in a special mode called the `debug` mode. It is used
for two main purposes:

- display additional information/fields for some particular screens,
- provide some additional tools to help developer debug the Odoo interface.

The `debug` mode is described by a string. An empty string means that the `debug`
mode is not active. Otherwise, it is active.  If the string contains `assets` or
`tests`, then the corresponding specific sub modes are activated (see below). Both
modes can be active at the same time, for example with the string `assets,tests`.

The `debug` mode current value can be read in the :ref:`environment<frontend/framework/environment>`:
`env.debug`.

.. tip::

    To show menus, fields or view elements only in debug mode, you should target
    the group `base.group_no_one`:

    .. code-block:: xml

        <field name="fname" groups="base.group_no_one"/>

.. seealso::
   - :ref:`Activate the debug mode <developer-mode>`


.. _frontend/framework/assets_debug_mode:

Assets mode
-----------

The `debug=assets` sub mode is useful to debug javascript code: once activated,
the :ref:`assets<reference/assets>` bundles are no longer minified, and source-maps
are generated as well. This makes it useful to debug all kind of javascript code.

.. _frontend/framework/tests_debug_mode:

Tests mode
----------

There is another sub mode named `tests`: if enabled, the server injects the
bundle `web.assets_tests` in the page. This bundle contains mostly test tours
(tours whose purpose is to test a feature, not to show something interesting to
users). The `tests` mode is then useful to be able to run these tours.

.. seealso::
    - `Owl Repository <https://github.com/odoo/owl>`_


==================================================
SECTION: hooks.rst
PATH: developer/reference/frontend/hooks.rst
==================================================

.. _frontend/hooks:

=====
Hooks
=====

`Owl hooks <https://github.com/odoo/owl/blob/master/doc/reference/hooks.md>`_ are a
way to factorize code, even if it depends on some component lifecycle. Most hooks
provided by Owl are related to the lifecycle of a component, but some of them (such as
`useComponent <https://github.com/odoo/owl/blob/master/doc/reference/hooks.md#usecomponent>`_)
provide a way to build specific hooks.

Using these hooks, it is possible to build many customized hooks that help solve
a specific problem, or make some common tasks easier. The rest of this page
documents the list of hooks provided by the Odoo web framework.

.. list-table::
   :widths: 30 70
   :header-rows: 1

   * - Name
     - Short Description
   * - :ref:`useAssets <frontend/hooks/useassets>`
     - load assets
   * - :ref:`useAutofocus <frontend/hooks/useAutofocus>`
     - focus automatically an element referenced by autofocus
   * - :ref:`useBus <frontend/hooks/usebus>`
     - subscribe and unsubscribe to a bus
   * - :ref:`usePager <frontend/hooks/usepager>`
     - Display the pager of the control panel of a view.
   * - :ref:`usePosition <frontend/hooks/useposition>`
     - position an element relative to a target
   * - :ref:`useSpellCheck <frontend/hooks/useSpellCheck>`
     - activate spellcheck on focus for input or textarea

.. _frontend/hooks/useassets:

useAssets
=========

Location
--------

`@web/core/assets`

Description
-----------

See the section on :ref:`lazy loading assets <frontend/assets/lazy_loading>` for
more details.


.. _frontend/hooks/useAutofocus:

useAutofocus
============

Location
--------

`@web/core/utils/hooks`

Description
-----------

Focus an element referenced by a t-ref="autofocus" in the current component as
soon as it appears in the DOM and if it was not displayed before.

.. code-block:: javascript

    import { useAutofocus } from "@web/core/utils/hooks";

    class Comp {
      setup() {
        this.inputRef = useAutofocus();
      }
      static template = "Comp";
    }

.. code-block:: xml

    <t t-name="Comp">
      <input t-ref="autofocus" type="text"/>
    </t>

API
---

.. js:function:: useAutofocus()

    :returns: the element reference.

.. _frontend/hooks/usebus:

useBus
======

Location
--------

`@web/core/utils/hooks`

Description
-----------

Add and clear an event listener to a bus. This hook ensures that
the listener is properly cleared when the component is unmounted.

.. code-block:: javascript

    import { useBus } from "@web/core/utils/hooks";

    class MyComponent {
      setup() {
        useBus(this.env.bus, "some-event", event => {
          console.log(event);
        });
      }
    }

API
---

.. js:function:: useBus(bus, eventName, callback)

    :param EventBus bus: the target event bus
    :param string eventName: the name of the event that we want to listen to
    :param function callback: listener callback

.. _frontend/hooks/usepager:

usePager
========

Location
--------

`@web/search/pager_hook`

Description
-----------

Display the :ref:`Pager <frontend/pager>` of the control panel of a view. This hooks correctly sets `env.config` to provide the props to the pager.

.. code-block:: javascript

    import { usePager } from "@web/search/pager_hook";

    class CustomView {
      setup() {
        const state = owl.hooks.useState({
          offset: 0,
          limit: 80,
          total: 50,
        });
        usePager(() => {
          return {
            offset: this.state.offset,
            limit: this.state.limit,
            total: this.state.total,
            onUpdate: (newState) => {
              Object.assign(this.state, newState);
            },
          };
        });
      }
    }

API
---

.. js:function:: usePager(getPagerProps)

    :param function getPagerProps: function that returns the pager props.

.. _frontend/hooks/useposition:

usePosition
===========

Location
--------

`@web/core/position_hook`

Description
-----------

Helps positioning an HTMLElement (the `popper`) relatively to another
HTMLElement (the `reference`). This hook ensures the positioning is updated when
the window is resized/scrolled.

.. code-block:: javascript

    import { usePosition } from "@web/core/position_hook";
    import { Component, xml } from "@odoo/owl";

    class MyPopover extends Component {
      static template = xml`
        <div t-ref="popper">
          I am positioned through a wonderful hook!
        </div>
      `;

      setup() {
        // Here, the reference is the target props, which is an HTMLElement
        usePosition(this.props.target);
      }
    }

.. important::
   You should indicate your `popper` element using a `t-ref directive <https://github.com/odoo/owl/blob/master/doc/reference/hooks.md#useref>`_.

API
---

.. js:function:: usePosition(reference[, options])

    :param reference: the target HTMLElement to be positioned from
    :type reference: HTMLElement or ()=>HTMLElement
    :param Options options: the positioning options (see table below)

.. list-table::
   :widths: 20 20 60
   :header-rows: 1

   * - Option
     - Type
     - Description
   * - `popper`
     - string
     - this is a `useRef reference <https://github.com/odoo/owl/blob/master/doc/reference/hooks.md#useref>`_ for the element that will get positioned.
       Default is `"popper"`.
   * - `container`
     - HTMLElement
     - the container from which the popper is expected not to overflow. If
       overflowing occurs, other popper positions are tried until a not
       overflowing one is found. (default: the `<html/>` node)
   * - `margin`
     - number
     - added margin between popper and reference elements (default: `0`)
   * - `position`
     - Direction[-Variant]
     - the desired position. It is a string composed of one `Direction` and one
       `Variant` separated by a dash character.
       `Direction` could be: `top`, `bottom`, `right`, `left`.
       `Variant` could be: `start`, `middle`, `end`, `fit`.
       The variant can be omitted (default variant is `middle`).
       The `fit` variant means that the popper would have the exact same width or height,
       depending on the chosen direction.
       Examples of valid positions: `right-end`, `top-start`, `left-middle`,
       `left`, `bottom-fit`. (default position: `bottom`)
   * - `onPositioned`
     - (el: HTMLElement, position: PositioningSolution) => void
     - a callback that will be called everytime a positioning occurs
       (e.g. on component mounted/patched, document scroll, window resize...).
       Can be used i.e. for dynamic styling regarding the current position.
       The `PositioningSolution` is an object having the following type:
       `{ direction: Direction, variant: Variant, top: number, left: number }`.

.. example::

   .. code-block:: javascript

      import { Component, xml, useRef } from "@odoo/owl";
      import { usePosition } from "@web/core/position_hook";

      class DropMenu extends Component {
        static template = xml`
          <button t-ref="toggler">Toggle Menu</button>
          <div t-ref="menu">
            <t t-slot="default">
              This is the menu default content.
            </t>
          </div>
        `;

        setup() {
          const toggler = useRef("toggler");
          usePosition(
            () => toggler.el,
            {
              popper: "menu",
              position: "right-start",
              onPositioned: (el, { direction, variant }) => {
                el.classList.add(`dm-${direction}`); // -> "dm-top" "dm-right" "dm-bottom" "dm-left"
                el.style.backgroundColor = variant === "middle" ? "red" : "blue";
              },
            },
          );
        }
      }

.. _frontend/hooks/useSpellCheck:

useSpellCheck
=============

Location
--------

`@web/core/utils/hooks`

Description
-----------

Activate the spellcheck state to an input or textarea on focus by a `t-ref="spellcheck"` in
the current component. This state is then removed on blur, as well as the red outline, which
improves readability of the content.

The hook can also be used on any HTML element with the `contenteditable` attribute. To disable
spellcheck completely on elements that might be enabled by the hook, set explicitly the
`spellcheck` attribute as `false` on the element.

.. example::

   In the following example, the spellcheck will be enabled on the first input, the textarea and
   the div with `contenteditable="true"`.

   .. code-block:: javascript

       import { useSpellCheck } from "@web/core/utils/hooks";

       class Comp {
         setup() {
           this.simpleRef = useSpellCheck();
           this.customRef = useSpellCheck({ refName: "custom" });
           this.nodeRef = useSpellCheck({ refName: "container" });
         }
         static template = "Comp";
       }

   .. code-block:: xml

       <t t-name="Comp">
         <input t-ref="spellcheck" type="text"/>
         <textarea t-ref="custom"/>
         <div t-ref="container">
           <input type="text" spellcheck="false"/>
           <div contenteditable="true"/>
         </div>
       </t>

API
---

.. js:function:: useSpellCheck([options])

    :param Options options: the spellcheck options (see table below)

.. list-table::
   :widths: 20 20 60
   :header-rows: 1

   * - Option
     - Type
     - Description
   * - `refName`
     - string
     - this is a `useRef reference <{OWL_PATH}/doc/reference/hooks.md#useref>`_ for the element that will be
       spellcheck enabled.


==================================================
SECTION: hoot.rst
PATH: developer/reference/frontend/unit_testing/hoot.rst
==================================================

====
HOOT
====

Overview
========

:abbr:`HOOT (Hierarchically Organized Odoo Tests)` is a testing framework written with Owl whose
key features are:

- to register and run tests and test suites;
- to display an intuitive interface to view and filter test results;
- to provide ways to interact with the DOM to simulate user actions;
- to provide low-level helpers allowing to mock various global objects.

As such, it has been integrated as a :file:`lib/` in the Odoo codebase and exports 2 main modules:

- :file:`@odoo/hoot-dom`: (can be used in tours) helpers to:

    - **interact** with the DOM, such as :js:meth:`click` and :js:meth:`press`;
    - **query** elements from the DOM, such as :js:meth:`queryAll` and :js:meth:`waitFor`;

- :file:`@odoo/hoot`: (only to be used in unit tests) all the test framework features:

    - `test`, `describe` and `expect`
    - test hooks like `after` and `afterEach`
    - fixture handling with `getFixture`
    - date and time handling like `mockDate` or `advanceTime`
    - mocking network responses through :js:meth:`mockFetch` or :js:meth:`mockWebSocket`
    - every helper exported by :file:`@odoo/hoot-dom`

.. note::
    This section of the documentation is not meant to list *all* helpers available
    in Hoot (the full list can be found in the `@odoo/hoot <{GITHUB_PATH}/addons/web/static/lib/hoot/hoot.js>`_
    module itself). The goal here is to showcase the most used helpers and to justify
    some of the decisions that have led to the current shape of the testing framework.

Running tests
=============

In Odoo, frontend unit tests can be run by going to the `/web/tests` URL. Most of
the setup for calling the test runner is already in place:

- the `web.assets_unit_tests` bundle is already defined, and picks up all tests
  defined in most addons;

- a :file:`start.hoot.js` file takes care of calling the test runner with its exported
  `start` entry point function.

When going to the test page, tests will be run sequentially and the results will
be displayed in the console and in the GUI (if not running in `headless` mode).

Runner options
--------------

The runner can be configured either:

- through the interface (with the configuration dropdown and the search bar);
- or through the URL query parameters (e.g. `?headless` to run in headless mode).

Here is the list of available options for the runner:

- `bail`
    Amount of failed tests after which the test runner will be stopped. A falsy value
    (including 0) means that the runner should never be aborted. (default: `0`)

- `debugTest`
    Same as the `FILTER_SCHEMA.test` filter, while also putting the test runner in
    "debug" mode. See `TestRunner.debug` for more info. (default: `false`)

- `fps`
    Sets the value of frames per seconds (this will be transformed to milliseconds and used in
    `advanceFrame`)

- `filter`
    Search string that will filter matching tests/suites, based on their full name (including
    their parent suite(s)) and their tags. (default: `""`)

- `frameRate`
    *Estimated* amount of frames rendered per second, used when mocking animation frames. (default:
    `60` fps)

- `fun`
    Lightens the mood. (default: `false`)

- `headless`
    Whether to render the test runner user interface. (default: `false`)

- `id`
    IDs of the suites OR tests to run exclusively. The ID of a job is generated
    deterministically based on its full name.

- `loglevel`
    Log level used by the test runner. The higher the level, the more logs will be displayed:

    - `0`: only runner logs are displayed (default)
    - `1`: all suite results are also logged
    - `2`: all test results are also logged
    - `3`: debug information for each test is also logged

- `manual`
    Whether the test runner must be manually started after page load (defaults to starting
    automatically). (default: `false`)

- `notrycatch`
    Removes the safety of `try .. catch` statements around each test's run function to let errors
    bubble to the browser. (default: `false`)

- `order`
    Determines the order of test execution:

    - `"fifo"`: tests will be run sequentially as declared in the file system;
    - `"lifo"`: tests will be run sequentially in the reverse order;
    - `"random"`: shuffles tests and suites within their parent suite.

- `preset`
    Environment in which the test runner is running. This parameter is used to
    determine the default value of other features, namely:

    - the user agent;
    - touch support;
    - expected size of the viewport.

- `showdetail`
    Determines how the failed tests must be unfolded in the UI. (default: `"first-fail"`)

- `tag`
    Tag names of tests and suites to run exclusively (case insensitive). (default: empty)

- `timeout`
    Duration (in milliseconds) at the end of which a test will automatically fail.
    (default: `5` seconds)

.. note::
    When selecting tests and suites to run, an implicit `OR` is applied between
    the *including* filters. This means that adding more inclusive filters will
    result in more tests being run. This applies to the `filter`, `id` and `tag`
    filters (*excluding* filters however will remove matching tests from the list
    of tests to run).


Writing tests
=============

Test
----

Writing a test can be very straightforward, as it is just a matter of calling the `test` function
with a name and a function that will contain the test logic.

Here is a simple example:

.. code-block:: javascript

    import { expect, test } from "@odoo/hoot";

    test("My first test", () => {
        expect(2 + 2).toBe(4);
    });


Describe
--------

Most of the time, tests are not that simple. They often require some setup and teardown,
and sometimes they need to be grouped together in a suite. This is where the `describe`
function comes into play.

Here is how you would declare a suite and a test within it:

.. code-block:: javascript

    import { describe, expect, test } from "@odoo/hoot";

    describe("My first suite", () => {
        test("My first test", () => {
            expect(2 + 2).toBe(4);
        });
    });

.. important::
    In Odoo, all test files are run in an isolated environment and are wrapped within a global
    `describe` block (with the name of the suite being the *path* of the test file).

    With that in
    mind you should not need to declare a suite in your test files, although you can still declare
    sub-suites in the same file if you still want to split the file's suite, for organization
    or tagging purposes.


Expect
======

The `expect` function is the main assertion function of the framework. It is used
to assert that a value or an object is what it is expected to be or in the state
it is supposed to be. To do so, it provides a few modifiers and a wide range of
matchers.


Modifiers
---------

An `expect` modifier is a getter that returns another set of *altered* matchers that will behave in
a specific way.

- `not`
    Inverts the result of the following matcher: it will succeed if the matcher fails.

    .. code-block:: javascript

        expect(true).not.toBe(false);

- `resolves`
    Waits for the value (`Promise`) to be *"resolved"* before running the following
    matcher with the resolved value.

    .. code-block:: javascript

        await expect(Promise.resolve(42)).resolves.toBe(42);

- `rejects`
    Waits for the value (`Promise`) to be *"rejected"* before running the following
    matcher with the rejected reason.

    .. code-block:: javascript

        await expect(Promise.reject("error")).rejects.toBe("error");

.. note::
    The `resolves` and `rejects` modifiers are only available when the value is
    a promise, and will return a promise that will resolve once the assertion is
    done.


Regular matchers
----------------

The matchers dictate what to do on the value being tested. Some will take that value
as-is, while others will *transform* that value before performing the assertion
on it (i.e. DOM matchers).

Note that the last argument parameter of all matchers is an optional dictionary with additional
options, in which a custom assertion `message` can be given for added context/specificity.

The first list of matchers are primitive or object based and are the most common ones:

.. js:method:: toBe(expected[, options])

    Expects the received value to be *strictly equal* to the `expected` value.

    - Parameters

        * `expected`: `any`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("foo").toBe("foo");
            expect({ foo: 1 }).not.toBe({ foo: 1 });

.. js:method:: toBeCloseTo(expected[, options])

    Expects the received value to be *close to* the `expected` value up to a given
    amount of digits (default is 2).

    - Parameters

        * `expected`: `any`
        * `options`: `{ message?: string, digits?: number }`

    - Examples

        .. code-block:: javascript

            expect(0.2 + 0.1).toBeCloseTo(0.3);
            expect(3.51).toBeCloseTo(3.5, { digits: 1 });

.. js:method:: toBeEmpty([options])

    Expects the received value to be empty:

        - `iterable`: no items
        - `object`: no keys
        - `node`: no content (i.e. no value or text)
        - anything else: falsy value (`false`, `0`, `""`, `null`, `undefined`)

    - Parameters

        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect({}).toBeEmpty();
            expect(["a", "b"]).not.toBeEmpty();
            expect(queryOne("input")).toBeEmpty();

.. js:method:: toBeGreaterThan(min[, options])

    Expects the received value to be *strictly greater* than `min`.

    - Parameters

        * `min`: `number`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(5).toBeGreaterThan(-1);
            expect(4 + 2).toBeGreaterThan(5);

.. js:method:: toBeInstanceOf(cls[, options])

    Expects the received value to be an instance of the given `cls`.

    - Parameters

        * `cls`: `Function`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect({ foo: 1 }).not.toBeInstanceOf(Object);
            expect(document.createElement("div")).toBeInstanceOf(HTMLElement);

.. js:method:: toBeLessThan(max[, options])

    Expects the received value to be *strictly less* than `max`.

    - Parameters

        * `max`: `number`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(5).toBeLessThan(10);
            expect(8 - 6).toBeLessThan(3);

.. js:method:: toBeOfType(type[, options])

    Expects the received value to be of the given `type`.

    - Parameters

        * `type`: `string`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("foo").toBeOfType("string");
            expect({ foo: 1 }).toBeOfType("object");

.. js:method:: toBeWithin(min, max[, options])

    Expects the received value to be *between* `min` and `max` (both inclusive).

    - Parameters

        * `min`: `number`
        * `max`: `number`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(3).toBeWithin(3, 9);
            expect(-8.5).toBeWithin(-20, 0);
            expect(100).toBeWithin(50, 100);

.. js:method:: toEqual(expected[, options])

    Expects the received value to be *deeply equal* to the `expected` value.

    - Parameters

        * `expected`: `any`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(["foo"]).toEqual(["foo"]);
            expect({ foo: 1 }).toEqual({ foo: 1 });

.. js:method:: toHaveLength(length[, options])

    Expects the received value to have a length of the given `length`.
    Received value can be any `Iterable` or `Object`.

    - Parameters

        * `length`: `number`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("foo").toHaveLength(3);
            expect([1, 2, 3]).toHaveLength(3);
            expect({ foo: 1, bar: 2 }).toHaveLength(2);
            expect(new Set([1, 2])).toHaveLength(2);

.. js:method:: toInclude(item[, options])

    Expects the received value to include an `item` of a given shape.

    Received value can be an iterable or an object (in case it is an object,
    the `item` should be a key or a tuple representing an entry in that object).

    Note that it is NOT a strict comparison: the item will be matched for deep
    equality against each item of the iterable.

    - Parameters

        * `item`: `any`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect([1, 2, 3]).toInclude(2);
            expect({ foo: 1, bar: 2 }).toInclude("foo");
            expect({ foo: 1, bar: 2 }).toInclude(["foo", 1]);
            expect(new Set([{ foo: 1 }, { bar: 2 }])).toInclude({ bar: 2 });

.. js:method:: toMatch(matcher[, options])

    Expects the received value to match the given `matcher`.

    - Parameters

        * `matcher`: `string | number | RegExp`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(new Error("foo")).toMatch("foo");
            expect("a foo value").toMatch(/fo.*ue/);

.. js:method:: toThrow(matcher[, options])

    Expects the received `Function` to throw an error after being called.

    - Parameters

        * `matcher`: `string | number | RegExp`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(() => { throw new Error("Woops!") }).toThrow(/woops/i);
            await expect(Promise.reject("foo")).rejects.toThrow("foo");


DOM matchers
------------

This next list of matchers are node-based and are used to assert the state of a
node or a list of nodes. They generally take a :ref:`custom selector <hoot/custom-dom-selectors>`
as the argument of the `expect` function (although a `Node` or an iterable of `Node`
is also accepted).

.. js:method:: toBeChecked([options])

    Expects the received `Target` to be `"checked"`, or to be `"indeterminate"`
    if the homonymous option is set to `true`.

    - Parameters

        * `options`: `{ message?: string, indeterminate?: boolean }`

    - Examples

        .. code-block:: javascript

            expect("input[type=checkbox]").toBeChecked();

.. js:method:: toBeDisplayed([options])

    Expects the received `Target` to be *"displayed"*, meaning that:

        - it has a bounding box;
        - it is contained in the root document.

    - Parameters

        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(document.body).toBeDisplayed();
            expect(document.createElement("div")).not.toBeDisplayed();

.. js:method:: toBeEnabled([options])

    Expects the received `Target` to be *"enabled"*, meaning that it
    matches the `:enabled` pseudo-selector.

    - Parameters

        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("button").toBeEnabled();
            expect("input[type=radio]").not.toBeEnabled();

.. js:method:: toBeFocused([options])

    Expects the received `Target` to be *"focused"* in its owner document.

    - Parameters

        * `options`: `{ message?: string }`

.. js:method:: toBeVisible([options])

    Expects the received `Target` to be *"visible"*, meaning that:

        - it has a bounding box;
        - it is contained in the root document;
        - it is not hidden by CSS properties.

    - Parameters

        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(document.body).toBeVisible();
            expect("[style='opacity: 0']").not.toBeVisible();

.. js:method:: toHaveAttribute(attribute, value[, options])

    Expects the received `Target` to have the given attribute set, and for that
    attribute value to match the given `value` if any.

    - Parameters

        * `attribute`: `string`
        * `value`: `string | number | RegExp`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("a").toHaveAttribute("href");
            expect("script").toHaveAttribute("src", "./index.js");

.. js:method:: toHaveClass(className[, options])

    Expects the received `Target` to have the given class name(s).

    - Parameters

        * `className`: `string | string[]`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("button").toHaveClass("btn btn-primary");
            expect("body").toHaveClass(["o_webclient", "o_dark"]);

.. js:method:: toHaveCount(amount[, options])

    Expects the received `Target` to contain exactly `amount` element(s).
    Note that the `amount` parameter can be omitted, in which case the function
    will expect *at least* one element.

    - Parameters

        * `amount`: `number`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect(".o_webclient").toHaveCount(1);
            expect(".o_form_view .o_field_widget").toHaveCount();
            expect("ul > li").toHaveCount(4);

.. js:method:: toHaveInnerHTML(expected[, options])

    Expects the `innerHTML` of the received `Target` to match the `expected`
    value (upon formatting).

    - Parameters

        * `expected`: `string | RegExp`
        * `options`: `{ message?: string, type?: "html" | "xml", tabSize?: number, keepInlineTextNodes?: boolean }`

    - Examples

        .. code-block:: javascript

            expect(".my_element").toHaveInnerHTML(`
                Some <strong>text</strong>
            `);

.. js:method:: toHaveOuterHTML(expected[, options])

    Expects the `outerHTML` of the received `Target` to match the `expected`
    value (upon formatting).

    - Parameters

        * `expected`: `string | RegExp`
        * `options`: `{ message?: string, type?: "html" | "xml", tabSize?: number, keepInlineTextNodes?: boolean }`

    - Examples

        .. code-block:: javascript

            expect(".my_element").toHaveOuterHTML(`
                <div class="my_element">
                    Some <strong>text</strong>
                </div>
            `);

.. js:method:: toHaveProperty(property, value[, options])

    Expects the received `Target` to have its given property value match
    the given `value`. If no value is given: the matcher will instead check that
    the given property exists on the target.

    - Parameters

        * `property`: `string`
        * `value`: `any`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("button").toHaveProperty("tabIndex", 0);
            expect("input").toHaveProperty("ontouchstart");
            expect("script").toHaveProperty("src", "./index.js");

.. js:method:: toHaveRect(rect[, options])

    Expects the `DOMRect` of the received `Target` to match the given `rect` object.
    The `rect` object can either be:

        - a `DOMRect` object;
        - a CSS selector string (to get the rect of the *only* matching element);
        - a node.

    If the resulting `rect` value is a node, then both nodes' rects will be compared.

    - Parameters

        * `rect`: `Partial<DOMRect> | Target`
        * `options`: `{ message?: string, trimPadding?: boolean }`

    - Examples

        .. code-block:: javascript

            expect("button").toHaveRect({ x: 20, width: 100, height: 50 });
            expect("button").toHaveRect(".container");

.. js:method:: toHaveStyle(style[, options])

    Expects the received `Target` to match the given style properties.

    - Parameters

        * `style`: `string | Record<string, string | RegExp>`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("button").toHaveStyle({ color: "red" });
            expect("p").toHaveStyle("text-align: center");

.. js:method:: toHaveText(text[, options])

    Expects the `text` content of the received `Target` to either:

        - be strictly equal to a given string;
        - match a given regular expression.

    Note: `innerHTML` is used to retrieve the text content to take CSS visibility
    into account. This also means that text values from child elements will be
    joined using a line-break as separator.

    - Parameters

        * `text`: `string | RegExp`
        * `options`: `{ message?: string, raw?: boolean }`

    - Examples

        .. code-block:: javascript

            expect("p").toHaveText("lorem ipsum dolor sit amet");
            expect("header h1").toHaveText(/odoo/i);

.. js:method:: toHaveValue(value[, options])

    Expects the value of the received `Target` to either:

        - be strictly equal to a given string or number;
        - match a given regular expression;
        - contain file objects matching the given `files` list.

    - Parameters

        * `value`: `any`
        * `options`: `{ message?: string }`

    - Examples

        .. code-block:: javascript

            expect("input[type=email]").toHaveValue("john@doe.com");
            expect("input[type=file]").toHaveValue(new File(["foo"], "foo.txt"));
            expect("select[multiple]").toHaveValue(["foo", "bar"]);

Static methods
--------------

The `expect` helper function also contains static methods that can be used to run
through a detached testing flow that isn't bound to one specific value at a certain
moment.

These methods are mainly used to register steps or errors in the scope of the current
test, and to evaluate them later on.

.. js:function:: expect.assertions(expected)

    :param number expected:

    Expects the current test to have the `expected` amount of assertions. This
    number cannot be less than 1.

    .. note::
        It is generally preferred to use :js:meth:`expect.step` and :js:meth:`expect.verifySteps`
        instead as it is more reliable and allows to test more extensively.

.. js:function:: expect.errors(expected)

    :param number expected:

    Expects the current test to have the `expected` amount of errors.

    This also means that from the moment this function is called, the test will
    accept that amount of errors before being considered as failed.

.. js:function:: expect.step(value)

    :param unknown value:

    Registers a step for the current test, that can be consumed by :js:meth:`expect.verifySteps`.
    Unconsumed steps will fail the test.

.. js:function:: expect.verifyErrors(errors[, options])

    :param unknown[] errors:
    :param { message?\: string } options:
    :returns: `boolean`

    Expects the received matchers to match the errors thrown since the start of
    the test or the last call to :js:meth:`expect.verifyErrors`. Calling this matcher
    will reset the list of current errors.

    .. code-block:: javascript

        expect.verifyErrors([/RPCError/, /Invalid domain AST/]);

.. js:function:: expect.verifySteps(steps[, options])

    :param unknown[] steps:
    :param { ignoreOrder?\: boolean, message?\: string, partial?\: boolean } options:
    :returns: `boolean`

    Expects the received steps to be equal to the steps emitted since the start
    of the test or the last call to :js:meth:`expect.verifySteps`. Calling this
    matcher will reset the list of current steps.

    .. code-block:: javascript

        expect.step("web_read_group");
        expect.step([1, 2]);
        expect.verifySteps(["web_read_group", [1, 2]]);

.. js:function:: expect.waitForErrors(errors[, options])

    :param unknown[] errors:
    :param { message?\: string } options:
    :returns: `Promise<boolean>`

    Same as :js:meth:`expect.verifyErrors`, but will not immediatly fail if errors
    are not caught yet, and will instead wait for a certain timeout (default: 2000ms)
    to allow errors to be caught later.

    Checks are performed initially, at the end of the timeout, and each time an
    error is detected.

    .. code-block:: javascript

        fetch("invalid/url");
        await expect.waitForErrors([/RPCError/]);

.. js:function:: expect.waitForSteps(steps[, options])

    :param unknown[] steps:
    :param { ignoreOrder?\: boolean, message?\: string, partial?\: boolean } options:
    :returns: `Promise<boolean>`

    Same as :js:meth:`expect.verifySteps`, but will not immediatly fail if steps
    have not been registered yet, and will instead wait for a certain timeout (default:
    2000ms) to allow steps to be registered later.

    Checks are performed initially, at the end of the timeout, and each time
    a step is registered.

    .. code-block:: javascript

        // ... step on each 'web_read_group' call
        fetch(".../call_kw/web_read_group");
        await expect.waitForSteps(["web_read_group"]);

DOM: queries
============

.. _hoot/custom-dom-selectors:

Custom DOM selectors
--------------------

Here's a brief section on DOM selectors in Hoot, as they support additional pseudo-classes
that can be used to target elements based on non-standard features, such as their
text content or their global position in the document.

- `:contains(text)`
    matches nodes whose text content matches the given `text`

    - given *text* supports regular expression syntax (e.g. `:contains(/^foo.+/)`) and is
      case-insensitive (unless using the `i` flag at the end of the regex)

- `:displayed`
    matches nodes that are *"displayed"* (see `isDisplayed`)

- `:empty`
    matches nodes that have an empty content (value or text content)

- `:eq(n)`
    returns the *nth* node based on its global position (0-based index);

- `:first`
    returns the first node matching the selector (in the whole document)

- `:focusable`
    matches nodes that can be *"focused"* (see `isFocusable`)

- `:hidden`
    matches nodes that are *not* *"visible"* (see `isVisible`)

- `:iframe`
    matches nodes that are `<iframe>` elements, and returns their `body` if it is ready

- `:last`
    returns the last node matching the selector (in the whole document)

- `:selected`
    matches nodes that are selected (e.g. `<option>` elements)

- `:shadow`
    matches nodes that have shadow roots, and returns their shadow root

- `:scrollable`
    matches nodes that are scrollable (see `isScrollable`)

- `:value(text)`
    matches nodes whose value matches the given `text`

    - given *text* supports regular expression syntax (e.g. `:value(/^foo.+/)`) and is
      case-insensitive (unless using the `i` flag at the end of the regex)

- `:visible`
    matches nodes that are *"visible"* (see `isVisible`)

Query & node properties helpers
-------------------------------

Hoot provides helpers to query nodes and some of their properties in a streamlined
and elegant way. This can mainly be done through the use of `queryX` helpers:

.. js:function:: queryAll(target[, options])

    Returns a list of nodes matching the given `Target`.
    This function can either be used as a `template literal tag <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates>`_
    (only supports string selector without options) or invoked the usual way.

    The target can be:

        - a `Node` (or an iterable of nodes), or `Window` object;
        - a `Document` object (which will be converted to its body);
        - a string representing a :ref:`custom selector <hoot/custom-dom-selectors>`
          (which will be queried from the `root` option).

    An `options` object can be specified to filter [#]_ the results:

        - `count`: the exact number of nodes to match (throws an error if the number of nodes
          doesn't match);
        - `displayed`: whether the nodes must be "displayed" (see `isDisplayed`);
        - `focusable`: whether the nodes must be "focusable" (see `isFocusable`);
        - `root`: the root node to query the selector in (defaults to the current fixture);
        - `visible`: whether the nodes must be "visible" (see `isVisible`).
          * This option implies `displayed`

    .. [#] these filters (except for `count` and `root`) achieve the same result as using their homonym
        pseudo-classes on the final group of the given selector string, e.g.:

        .. code-block:: javascript

            // These 2 will return the same result
            queryAll`ul > li:visible`;
            queryAll("ul > li", { visible: true });

    :returns: `Node[]`

.. js:function:: queryAllAttributes(target, attribute[, options])

    Performs a :js:meth:`queryAll` on the given `target` and returns
    a list of attribute values.

    :returns: `string[]` list of attribute values

.. js:function:: queryAllProperties(target, property[, options])

    Performs a :js:meth:`queryAll` on the given `target` and returns
    a list of property values.

    :returns: `unknown[]` list of property values

.. js:function:: queryAllTexts(target[, options])

    Performs a :js:meth:`queryAll` on the given `target` and returns
    a list of text contents.

    :returns: `string[]` list of text contents

.. js:function:: queryAllValues(target[, options])

    Performs a :js:meth:`queryAll` on the given `target` and returns
    a list of values.

    :returns: `string[]` a list of values

.. js:function:: queryAttribute(target, attribute[, options])

    Performs a :js:meth:`queryOne` with the given arguments and returns
    the value of the given `attribute` of the matching node.

    :returns: `string` the attribute value

.. js:function:: queryFirst(target[, options])

    Performs a :js:meth:`queryAll` with the given arguments and returns
    the first result or `null`.

    :returns: `Node` | `null` the first matching node

.. js:function:: queryOne(target[, options])

    Performs a :js:meth:`queryAll` with the given arguments, along with
    a forced `count: 1` option to ensure only one node matches the given `Target`.

    The returned value is a single node instead of a list of nodes.

    :returns: `Node` a single node

.. js:function:: queryText(target[, options])

    Performs a :js:meth:`queryOne` with the given arguments and returns
    the *text* of the matching node.

    :returns: `string` text of the matching node

.. js:function:: queryValue(target[, options])

    Performs a :js:meth:`queryOne` with the given arguments and returns
    the *value* of the matching node.

    :returns: `string` value of the matching node

All of the above helpers are synchronous, meaning that they will attempt to query
nodes instantly. Although some use cases require the element to be awaited for an
arbitrary amount of time, unknown in advance due to UI fetching and rendering complexity.

Hoot provides 2 methods to wait for an element to appear / disappear within a certain
time frame (by default: `200` milliseconds) for such cases:

.. js:function:: waitFor(target[, options])

    Combination of :js:meth:`queryAll` and :js:meth:`waitUntil`:
    waits for a given target to match elements in the DOM and returns the first
    matching node when it appears (or immediately if it is already present).

    :returns: `Promise<Node>` containing the first matching node

.. js:function:: waitForNone(target[, options])

    Opposite of :js:meth:`waitFor` waits for a given target to disappear from the DOM.

    :returns: `Promise<number>` containing the number of matching nodes


DOM: interaction helpers
========================

Along with querying elements, it is often required to interact with them.
As such, Hoot provides helpers to simulate various user interactions on elements.

These can be split into 2 types based on their parameters: **pointer-based** interaction
helpers, and the **other** ones.

Pointer interaction helpers:
----------------------------

Pointer interaction helpers (such as :js:meth:`click` or :js:meth:`drag`) will simulate
actual pointer movements and events on the given target, and on any previous element
the pointer was *supposed* to have been.

.. js:function:: check(target[, options])

    Ensures that the given `Target` is checked.

    If it is not checked, a :js:meth:`click` is simulated on the input.
    If the input is still not checked after the click, an error is thrown.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        check("input[type=checkbox]"); // Checks the first <input> checkbox element

.. js:function:: click(target[, options])

    Performs a click sequence on the given `Target`.

    The event sequence is as follows:

        - `pointerdown`
        - [desktop] `mousedown`
        - [touch] `touchstart`
        - [target is not active element] `blur`
        - [target is focusable] `focus`
        - `pointerup`
        - [desktop] `mouseup`
        - [touch] `touchend`
        - `click`
        - `dblclick` if click is not prevented & current click count is even

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        click("button"); // Clicks on the first <button> element

.. js:function:: dblclick(target[, options])

    Performs two :js:meth:`click` sequences on the given `Target`.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        dblclick("button"); // Double-clicks on the first <button> element

.. js:function:: drag(target[, options])

    Starts a drag sequence on the given `Target`.

    Returns a set of helper functions to direct the sequence:

        - `moveTo`: moves the pointer to the given target;
        - `drop`: drops the dragged element on the given target (if any);
        - `cancel`: cancels the drag sequence.

    :returns: `Promise<DragHelpers>`

    .. code-block:: javascript

        drag(".card:first").drop(".card:last"); // Drags the first card onto the last one

        drag(".card:first").moveTo(".card:last").drop(); // Same as above

        const { cancel, moveTo } = await drag(".card:first"); // Starts the drag sequence
        moveTo(".card:eq(3)"); // Moves the dragged card to the 4th card
        cancel(); // Cancels the drag sequence

.. js:function:: hover(target[, options])

    Performs a hover sequence on the given `Target`.

    The event sequence is as follows:

        - `pointerover`
        - [desktop] `mouseover`
        - `pointerenter`
        - [desktop] `mouseenter`
        - `pointermove`
        - [desktop] `mousemove`
        - [touch] `touchmove`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        hover("button"); // Hovers the first <button> element

.. js:function:: pointerDown(target[, options])

    Performs a pointer down on the given `Target`.

    The event sequence is as follows:

        - `pointerdown`
        - [desktop] `mousedown`
        - [touch] `touchstart`
        - [target is not active element] `blur`
        - [target is focusable] `focus`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        pointerDown("button"); // Focuses to the first <button> element

.. js:function:: pointerUp(target[, options])

    Performs a pointer up on the given `Target`.

    The event sequence is as follows:

        - `pointerup`
        - [desktop] `mouseup`
        - [touch] `touchend`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        pointerUp("body"); // Triggers a pointer up on the <body> element

.. js:function:: scroll(target, position[, options])

    Performs a scroll event sequence on the given `Target`.

    The event sequence is as follows:

        - [desktop] `wheel`
        - `scroll`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        scroll("body", { y: 0 }); // Scrolls to the top of <body>

.. js:function:: setInputRange(target, value[, options])

    Sets the given value to the current "input[type=range]" `Target`.

    The event sequence is as follows:

        - `pointerdown`
        - `input`
        - `change`
        - `pointerup`

    :returns: `Promise<Event[]>`

.. js:function:: uncheck(target[, options])

    Ensures that the given `Target` is unchecked.

    If it is checked, a :js:meth:`click` is triggered on the input.
    If the input is still checked after the click, an error is thrown.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        uncheck("input[type=checkbox]"); // Unchecks the first <input> checkbox element

Other interaction helpers:
--------------------------

Other interaction helpers will not have a `target` parameter. It is not needed,
since pressing keys on a keyboard (for example) is done on the current *active element*.

.. js:function:: clear([options])

    Clears the value of the current *active element*.

    This is done using the following sequence:

        - pressing `"Control"` & `"A"` to select the whole value;
        - pressing `"Backspace"` to delete the value;
        - (optional) triggering a `"change"` event by pressing `"Enter"`.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        clear(); // Clears the value of the current active element

.. js:function:: edit(value[, options])

    Combination of :js:meth:`clear` and :js:meth:`fill`:

        - first, clears the input value (if any)
        - then fills the input with the given value

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        fill("foo"); // Types "foo" in the active element
        edit("Hello World"); // Replaces "foo" by "Hello World"

.. js:function:: fill(value[, options])

    Fills the current *active element* with the given `value`. This helper is intended
    for `<input>` and `<textarea>` elements, with the exception of `"checkbox"` and
    `"radio"` types, which should be selected using the `check` helper.

    If the target is an editable input, its string `value` will be input one character
    at a time, each generating its corresponding keyboard event sequence. This behavior
    can be overridden by passing the `instantly` option, which will instead simulate
    a `control` + `v` keyboard sequence, resulting in the whole text being pasted.

    Note that the given value is appended to the current value of the element.

    If the active element is a `<input type="file"/>`, the `value` should be a
    `File`/list of `File` object(s).

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        fill("Hello World"); // Types "Hello World" in the active element
        fill("Hello World", { instantly: true }); // Pastes "Hello World" in the active element
        fill(new File(["Hello World"], "hello.txt")); // Uploads a file named "hello.txt" with "Hello World" as content

.. js:function:: keyDown(keyStrokes[, options])

    Performs a key down sequence on the current *active element*.

    The event sequence is as follows:

        - `keydown`

    Additional actions will be performed depending on the key pressed:

        - `Tab`: focus next (or previous with `shift`) focusable element;
        - `c`: copy current selection to clipboard;
        - `v`: paste current clipboard content to current element;
        - `Enter`: submit the form if the target is a `<button type="button">` or
          a `<form>` element, or trigger a `change` event on the target if it is
          an `<input>` element;
        - `Space`: trigger a `click` event on the target if it is an `<input type="checkbox">`
          element.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        keyDown(" "); // Space key

.. js:function:: keyUp(keyStrokes[, options])

    Performs a key up sequence on the current *active element*.

    The event sequence is as follows:

        - `keyup`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        keyUp("Enter");

.. js:function:: leave([options])

    Performs a leave sequence on the current `Window`.

    The event sequence is as follows:

        - `pointermove`
        - [desktop] `mousemove`
        - [touch] `touchmove`
        - `pointerout`
        - [desktop] `mouseout`
        - `pointerleave`
        - [desktop] `mouseleave`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        leave("button"); // Moves out of <button>

.. js:function:: press(keyStrokes[, options])

    Performs a keyboard event sequence on the current *active element*.

    The event sequence is as follows:

        - `keydown`
        - `keyup`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        pointerDown("button[type=submit]"); // Moves focus to <button>
        keyDown("Enter"); // Submits the form

        keyDown("Shift+Tab"); // Focuses previous focusable element

        keyDown(["ctrl", "v"]); // Pastes current clipboard content

.. js:function:: resize([dimensions[, options]])

    Performs a resize event sequence on the current `Window`.

    The event sequence is as follows:

        - `resize`

    The target will be resized to the given dimensions, enforced by `!important` style
    attributes.

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        resize("body", { width: 1000, height: 500 }); // Resizes <body> to 1000x500

.. js:function:: select(value[, options])

    Performs a selection event sequence on the current active element. This helper
    is intended for `<select>` elements only.

    The event sequence is as follows:

        - `change`

    :returns: `Promise<Event[]>`

    .. code-block:: javascript

        click("select[name=country]"); // Focuses <select> element
        select("belgium"); // Selects the <option value="belgium"> element

.. js:function:: setInputFiles(files[, options])

    Gives the given `File` list to the current file input. This helper only
    works if a file input has been previously interacted with (by clicking on it).

    :returns: `Promise<Event[]>`

.. js:function:: unload([options])

    Triggers a "beforeunload" event on the current `Window`.

    :returns: `Promise<Event[]>`


Mocks
=====

By default, a lot of low-level features are mocked by Hoot: `clipboard`, `fetch`, `localStorage`,
etc. These mocks are intended to not produce any side-effect that would disturb the test runner
or the context of other tests, while still providing the same interface to allow tests to rely
on these features seamlessly.

There is also a need (most of the time) to force actions on these features or change their
behavior for a test, so there exist helpers to interact with these mocked features. The following
sections will list the main mocked features and the means to interact with them.

Time
----

Most asynchronous features are mocked: "timers" (`setTimeout`, `setInterval` and
`requestAnimationFrame`), `Date` and `performance` all behave normally, but can be canceled or
sped-up manually to considerably shorten the actual duration of tests. For example: all "timers"
are canceled at the end of each test to avoid side-effects for the next one.

    .. important::
        There are 2 main timing behaviors that are *NOT* mocked:

            - `Promise` objects and related API;
            - OWL's timer functions: to wait for OWL rendering functions, you'll have
              to resort to the `animationFrame` helper.

Related helpers
~~~~~~~~~~~~~~~

.. js:function:: advanceFrame(frameCount)

    Calls `advanceTime` with the duration it would take for a given `frameCount`
    amount of frames to have rendered in the UI (i.e. (1000 / current FPS) x frame count).

.. js:function:: advanceTime(ms)

    Advances the current time by the given amount of milliseconds. This will
    affect all timeouts, intervals, animations and date objects.

    It returns a promise resolved after all related callbacks have been executed.

    :returns: `Promise<number>` time consumed by timers (in ms)

.. js:function:: animationFrame()

    Returns a promise resolved after the next animation frame, typically allowing
    Owl components to render.

    :returns: `Promise<void>`

.. js:function:: cancelAllTimers()

    Cancels all current timeouts, intervals and animations.

.. js:function:: delay()

    Returns a promise resolved after a given amount of milliseconds (default to `0`).

    .. code-block:: javascript

        await delay(1000); // waits for 1 second

    :returns: `Promise<void>`

.. js:function:: microTick()

    Returns a promise resolved after the next microtask tick.

    :returns: `Promise<void>`

.. js:function:: mockDate(date[, tz])

    Mocks the current date and time, and also the time zone if any.

    Date can either be an object describing the date and time to mock, or a
    string in SQL or ISO format (time and millisecond values can be omitted).
    See :js:meth:`mockTimeZone` for the time zone params.

    .. code-block:: javascript

        mockDate("2023-12-25T20:45:00"); // 2023-12-25 20:45:00 UTC
        mockDate({ year: 2023, month: 12, day: 25, hour: 20, minute: 45 }); // same as above
        mockDate("2019-02-11 09:30:00.001", +2);

.. js:function:: mockTimeZone(tz)

    Mocks the current time zone.

    Time zone can either be a locale, a time zone or an offset.

    Returns a function restoring the default zone.

    .. code-block:: javascript

        mockTimeZone(+1); // UTC + 1
        mockTimeZone("Europe/Brussels"); // UTC + 1 (or UTC + 2 in summer)
        mockTimeZone("ja-JP"); // UTC + 9

.. js:function:: runAllTimers([preventTimers])

    Calculates the amount of time needed to run all current timeouts, intervals and
    animations, and then advances the current time by that amount.

    :returns: `Promise<void>`

.. js:function:: setFrameRate(frameRate)

    Sets the current frame rate (in fps) used by animation frames (default to 60fps).

.. js:function:: tick()

    Returns a promise resolved after the next task tick.

    :returns: `Promise<void>`

.. js:function:: waitUntil(predicate[, options])

    Returns a promise fulfilled when the given `predicate` returns a truthy value, with the value of
    the promise being the return value of the `predicate`.

    The `predicate` is run once initially and then each time the DOM is mutated (see `observe` for
    more information).

    The promise automatically rejects after a given `timeout` (defaults to 5 seconds).

    :returns: `Promise<unknown>` promise with the return value of the predicate

Network
-------

In general, we don't want to perform actual network calls in tests. To ensure this, all calls
to `fetch` and `XMLHttpRequest` have been re-routed to a function given to
:js:meth:`mockFetch`.

.. note::
    In Odoo, this is generally implicitly handled by a :ref:`MockServer <mock-server/configuration>`
    which is spawned by the mock environment, i.e. any time a component is rendered using the
    :ref:`mountWithCleanup <web-test-helpers/components>` helper.

Related helpers
~~~~~~~~~~~~~~~

.. js:function:: mockFetch([fetchFn])

    Mocks the fetch function by replacing it with a given `fetchFn`.

    The return value of `fetchFn` is used as the response of the mocked fetch, or
    wrapped in a `MockResponse` object if it does not meet the required format.

    .. code-block:: javascript

        mockFetch((input, init) => {
            if (input === "/../web_search_read") {
                return { records: [{ id: 3, name: "john" }] };
            }
            // ...
        });
        mockFetch((input, init) => {
            if (input === "/translations") {
                const translations = {
                    "Hello, world!": "Bonjour, monde !",
                    // ...
                };
                return new Response(JSON.stringify(translations));
            }
        });

.. js:function:: mockWebSocket([onWebSocketConnected])

    Activates mock WebSocket classe:

        - websocket connections will be handled by `window.fetch`
          (see :js:meth:`mockFetch`);
        - the `onWebSocketConnected` callback will be called after a websocket has been created.

.. js:function:: mockWorker([onWorkerConnected])

    Activates mock `Worker` and `SharedWorker` classes:

        - actual code fetched by worker URLs will then be handled by `window.fetch`
          (see :js:meth:`mockFetch`);
        - the `onWorkerConnected` callback will be called after a worker has been created.

Notable global features
-----------------------

The following features may not have any specific mocked feature added, but they do work as
expected without changing the actual properties they were meant to:

- `Document <https://developer.mozilla.org/en-US/docs/Web/API/Document>`_

    Both `title` and `cookie` can be set and read without changing the actual properties
    of the current document.

- `History <https://developer.mozilla.org/en-US/docs/Web/API/History>`_

    The `history` API is mocked and bound to the `mockLocation` object to return the same
    values and provide consistency.

- `Location <https://developer.mozilla.org/en-US/docs/Web/API/Location>`_

    Hoot returns a `mockLocation` object to use instead of `window.location`, but this relies on
    the use of an indirection in the actual production code.

    .. important::
        This feature will only work if an indirection is set between production code and
        calls to `window.location`. In Odoo, it works because the `@web/core/browser` module
        provides such an indirection, and that module is mocked in test environments to redirect
        to the `mockLocation` object.

- `Navigator <https://developer.mozilla.org/en-US/docs/Web/API/Navigator>`_

    Most used navigator features, such as the `clipboard` API and `userAgent`, have
    been mocked to hijack their actual behaviors. Its `permissions` object has been bound
    to a global mock of the permissions API.

- `Notification <https://developer.mozilla.org/en-US/docs/Web/API/Notification>`_

    Notifications have been mocked, with the "notification" permissions bound to the global
    mocked permissions API.

- `Permissions <https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API>`_

    Permissions can enable or disable other APIs by being given the `"granted"`
    or `"denied"` statuses. This can be done through the `mockPermission` helper.

- `Storage <https://developer.mozilla.org/en-US/docs/Web/API/Storage>`_

    `localStorage` and `sessionStorage` both point to "virtual" storages.

- `Touch <https://developer.mozilla.org/en-US/docs/Web/API/Touch_events>`_

    Touch features can be force-activated or deactivated globally for a given test/suite
    using the :js:meth:`mockTouch` helper. It will mock both the presence
    of touch handlers like `ontouchstart` on window, as well as the `"pointer"` media
    being set to `fine` or `coarse`.

Related helpers
~~~~~~~~~~~~~~~

.. js:function:: mockPermission(name[, value])

    Sets the given value for the given permission. This allows to enable or prevent
    certain APIs (see the `Permissions API <https://developer.mozilla.org/en-US/docs/Web/API/Permissions_API>`_).

    .. code-block:: javascript

        // Prevents the whole notification API from working
        mockPermission("notifications", "denied");

.. js:function:: mockTouch(setTouch)

    Toggles touch features on or off in the current `Window`.


==================================================
SECTION: javascript_modules.rst
PATH: developer/reference/frontend/javascript_modules.rst
==================================================

.. _frontend/js_modules:

==================
Javascript Modules
==================

Odoo supports three different kinds of javascript files:

- :ref:`plain javascript files <frontend/modules/plain_js>` (no module system),
- :ref:`native javascript module <frontend/modules/native_js>`.
- :ref:`Odoo modules <frontend/modules/odoo_module>` (using a custom module system),

As described in the :ref:`assets management page <reference/assets>`,
all javascript files are bundled together and served to the browser.
Note that native javascript files are processed by the Odoo server and transformed into Odoo custom modules.

Let us briefly explain the purpose behind each kind of javascript file. Plain
javascript files should be reserved only for external libraries and some small
specific low level purposes. All new javascript files should be created in the
native javascript module system. The custom module system is only useful for old,
not yet converted files.

.. _frontend/modules/plain_js:

Plain Javascript files
======================

Plain javascript files can contain arbitrary content. It is advised to use the
*iife* :dfn:`immediately invoked function execution` style when writing such a file:

.. code-block:: javascript

  (function () {
    // some code here
    let a = 1;
    console.log(a);
  })();

The advantages of such files is that we avoid leaking local variables to the
global scope.

Clearly, plain javascript files do not offer the benefits of a module system, so
one needs to be careful about the order in the bundle (since the browser will
execute them precisely in that order).

.. note::
  In Odoo, all external libraries are loaded as plain javascript files.

.. _frontend/modules/native_js:

Native Javascript Modules
=========================

Odoo javascript code uses the native javascript module system. This is simpler, and
brings the benefits of a better developer experience with a better integration with the IDE.

Let us consider the following module, located in :file:`web/static/src/file_a.js`:

.. code-block:: javascript

  import { someFunction } from "./file_b";

  export function otherFunction(val) {
      return someFunction(val + 3);
  }

There is a very important point to know: by default Odoo transpiles files under
`/static/src` and `/static/tests` into :ref:`Odoo modules <frontend/modules/odoo_module>`.
This file will then be transpiled into an Odoo module that looks like this:

.. code-block:: javascript

   odoo.define('@web/file_a', ['@web/file_b'], function (require) {
   'use strict';
   let __exports = {};

   const { someFunction } = require("@web/file_b");

   __exports.otherFunction = function otherFunction(val) {
      return someFunction(val + 3);
   };

   return __exports;
   )};

So, as you can see, the transformation is basically adding `odoo.define` on top
and updating the import/export statements. This is an opt-out system, it's possible
to tell the transpiler to ignore the file.

.. code-block:: javascript

  /** @odoo-module ignore **/
  (function () {
    const sum = (a, b) => a + b;
    console.log(sum(1, 2));
  )();

Note the comment in the first line: it describes that this file should be ignored.

In other folders, files aren't transpiled by default, it is opt-in. Odoo will look at the
first line of a JS file and check if it contains a comment with *@odoo-module* and without
the tag *ignore*. If so, it will automatically be converted to an Odoo module.

.. code-block:: javascript

  /** @odoo-module **/
  export function sum(a, b) {
    return a + b;
  }

Another important point is that the transpiled module has an official name:
*@web/file_a*. This is the actual name of the module. Every relative imports
will be converted as well. Every file located in an Odoo addon
:file:`some_addon/static/src/path/to/file.js` will be assigned a name prefixed by the
addon name like this: *@some_addon/path/to/file*.

Relative imports work, but only if the modules are in the same Odoo addon. So, imagine that we have
the following file structure:

::

  addons/
      web/
          static/
              src/
                  file_a.js
                  file_b.js
      stock/
          static/
              src/
                  file_c.js

The file :file:`file_b` can import :file:`file_a` like this:

.. code-block:: javascript

  import {something} from `./file_a`;

But :file:`file_c` need to use the full name:

.. code-block:: javascript

  import {something} from `@web/file_a`;

Aliased modules
---------------

Because :ref:`Odoo modules <frontend/modules/odoo_module>` follow a different module naming pattern, a system exists to allow a smooth
transition towards the new system. Currently, if a file is converted to a module (and therefore
follow the new naming convention), other files not yet converted to ES6-like syntax in the project
won't be able to require the module. Aliases are here to map old names with new ones by creating a
small proxy function. The module can then be called by its new *and* old name.

To add such alias, the comment tag on top of the file should look like this:

.. code-block:: javascript

  /** @odoo-module alias=web.someName**/
  import { someFunction } from './file_b';

  export default function otherFunction(val) {
      return someFunction(val + 3);
  }

Then, the translated module will also create an alias with the requested name:

.. code-block:: javascript

  odoo.define(`web.someName`, ['@web/file_a'], function(require) {
      return require('@web/file_a')[Symbol.for("default")];
  });

The default behaviour of aliases is to re-export the ``default`` value of the
module they alias. This is because "classic" modules generally export a single
value which would be used directly, roughly matching the semantics of default
exports.
However it is also possible to delegate more directly, and follow the exact
behaviour of the aliased module:

.. code-block:: javascript

  /** @odoo-module alias=web.someName default=0**/
  import { someFunction } from './file_b';

  export function otherFunction(val) {
      return someFunction(val + 3);
  }

In that case, this will define an alias with exactly the values exported by the
original module:

.. code-block:: javascript

  odoo.define(`web.someName`, ["@web/file_a"], function(require) {
      return require('@web/file_a');
  });

.. note::
   Only one alias can be defined using this method. If you were to need another one to have, for
   example, three names to call the same module, you would have to add a proxy manually.
   This is not good practice and should be avoided unless there is no other options.

Limitations
-----------

For performance reasons, Odoo does not use a full javascript
parser to transform native modules. There are, therefore, a number of limitations including but not
limited to:

- an `import` or `export` keyword cannot be preceded by a non-space character,
- a multiline comment or string cannot have a line starting by `import` or `export`

  .. code-block:: javascript

    // supported
    import X from "xxx";
    export X;
      export default X;
        import X from "xxx";

    /*
     * import X ...
     */

    /*
     * export X
     */


    // not supported

    var a= 1;import X from "xxx";
    /*
      import X ...
    */

- when you export an object, it can't contain a comment

  .. code-block:: javascript

      // supported
      export {
        a as b,
        c,
        d,
      }

      export {
        a
      } from "./file_a"


      // not supported
      export {
        a as b, // this is a comment
        c,
        d,
      }

      export {
        a /* this is a comment */
      } from "./file_a"

- Odoo needs a way to determine if a module is described by a path (like :file:`./views/form_view`)
  or a name (like `web.FormView`). It has to use a heuristic to do just that: if there is a `/` in
  the name, it is considered a path.  This means that Odoo does not really support module names with
  a `/` anymore.

As "classic" modules are not deprecated and there is currently no plan to remove them, you can and should keep using
them if you encounter issues with, or are constrained by the limitations of, native modules. Both styles can coexist
within the same Odoo addon.


.. _frontend/modules/odoo_module:

Odoo Module System
==================

Odoo has defined a small module system (located in the file
:file:`addons/web/static/src/js/boot.js`, which needs to be loaded first). The Odoo
module system, inspired by AMD, works by defining the function `define`
on the global odoo object. We then define each javascript module by calling that
function.  In the Odoo framework, a module is a piece of code that will be executed
as soon as possible.  It has a name and potentially some dependencies.  When its
dependencies are loaded, a module will then be loaded as well.  The value of the
module is then the return value of the function defining the module.

As an example, it may look like this:

.. code-block:: javascript

    // in file a.js
    odoo.define('module.A', [], function (require) {
        "use strict";

        var A = ...;

        return A;
    });

    // in file b.js
    odoo.define('module.B', ['module.A'], function (require) {
        "use strict";

        var A = require('module.A');

        var B = ...; // something that involves A

        return B;
    });


If some dependencies are missing/non ready, then the module will simply not be
loaded.  There will be a warning in the console after a few seconds.

Note that circular dependencies are not supported. It makes sense, but it means that one
needs to be careful.

Defining a module
-----------------

The `odoo.define` method is given three arguments:

- `moduleName`: the name of the javascript module.  It should be a unique string.
  The convention is to have the name of the odoo addon followed by a specific
  description. For example, `web.Widget` describes a module defined in the `web`
  addon, which exports a `Widget` class (because the first letter is capitalized)

  If the name is not unique, an exception will be thrown and displayed in the
  console.

- `dependencies`: It should be a list of strings, each corresponding to a
  javascript module.  This describes the dependencies that are required to
  be loaded before the module is executed.

- finally, the last argument is a function which defines the module. Its return
  value is the value of the module, which may be passed to other modules requiring
  it.

  .. code-block:: javascript

     odoo.define('module.Something', ['web.ajax'], function (require) {
         "use strict";

         var ajax = require('web.ajax');

         // some code here
         return something;
     });

If an error happens, it will be logged (in debug mode) in the console:

* `Missing dependencies`:
  These modules do not appear in the page. It is possible that the JavaScript
  file is not in the page or that the module name is wrong
* `Failed modules`:
  A javascript error is detected
* `Rejected modules`:
  The module returns a rejected Promise. It (and its dependent modules) is not
  loaded.
* `Rejected linked modules`:
  Modules who depend on a rejected module
* `Non loaded modules`:
  Modules who depend on a missing or a failed module


==================================================
SECTION: javascript_reference.rst
PATH: developer/reference/frontend/javascript_reference.rst
==================================================

.. highlight:: javascript

.. default-domain:: js

====================
Javascript Reference
====================

This document presents the Odoo Javascript framework. This
framework is not a large application in term of lines of code, but it is quite
generic, because it is basically a machine to turn a declarative interface
description into a live application, able to interact with every model and
records in the database.  It is even possible to use the web client to modify
the interface of the web client.

Overview
========

The Javascript framework is designed to work with three main use cases:

- the *web client*: this is the private web application, where one can view and
  edit business data. This is a single page application (the page is never
  reloaded, only the new data is fetched from the server whenever it is needed)
- the *website*: this is the public part of Odoo.  It allows an unidentified
  user to browse some content, to shop or to perform many actions, as a client.
  This is a classical website: various routes with controllers and some
  javascript to make it work.
- the *point of sale*: this is the interface for the point of sale. It is a
  specialized single page application.

Some javascript code is common to these three use cases, and is bundled together
(see below in the assets section).  This document will focus mostly on the architecture
of the web client.

Web client
==========

Single Page Application
-----------------------

The web client is a single-page application: instead of
requesting a full page from the server each time the user performs an action,
it only loads what is needed to update the user interface (UI) as a result of that
action. While doing this, it also takes care of updating information in the URL,
so that, in most cases, refreshing the page or closing the browser and opening it
again shows you the same thing.

Overview of web client JS code
------------------------------

Here, we give a very quick overview of the web client code, in the :file:`web` addon.
The paths will be described relative to :file:`web/static/src`.
The following description is deliberately not exhaustive; the goal is only to
give the reader a bird's eye view of the architecture.

- :file:`module_loader.js`: this is the file that defines the Odoo javascript module
  system.  It needs to be loaded before any other JS module.
- :file:`core/`: this folder contains code that forms the lowest level of the javascript
  framework and that can be used in the web client as well as the website, portal,
  and point of sale application.
- :file:`weblient/`: this folder contains files that are specific to the web client and
  cannot be used in the website or point of sale, such as the action manager and the
  action service.
- :file:`webclient/webclient.js`: this is the webclient component proper. It is mostly
  a wrapper for the action container and the navbar, and does a few things that
  are required upon starting the application, such as loading the state of the url.
- :file:`webclient/actions/`: this folder contains the code responsible for displaying
  and switching between actions.
- :file:`views/`: this folder contains the code for the view infrastructure, as well
  as most of the views (some types of views are added by other addons).
- :file:`views/fields/`: contains the definition of the various field components, as well
  as some utilities used by multiple fields.
- :file:`search/` all these files define the search view (it is not a view
  in the point of view of the web client, only from the server point of view)


What to do if a file is not loaded/updated
------------------------------------------

There are many different reasons why a file may not be properly loaded.  Here
are a few things you can try to solve the issue:

- Make sure you saved your file; forgetting to do that happens to the best of us.
- Take a look at the console (in the dev tools, usually opened with F12) and check
  for errors.
- Try adding a `console.log()` at the beginning of your file so you can see if
  a file has been loaded or not. If it is not loaded, if may not be in the proper
  assets bundle, or the asset bundle may not be up to date.
- Depending on your settings, the server may not regenerate the assets bundles
  after a file has been modified; there are a few options to solve this:

  - restarting the server will force it to check if the asset bundle is up to
    date the next time it is requested
  - in debug mode, there is an option in the debug menu (:icon:`fa-bug` button in the navbar)
    to force the server to regenerate the assets bundle on the fly without restarting.
  - starting the server with the `--dev=xml` option will force the server to check
    if an asset bundle is up to date every time it is requested. We advise you to use
    this option when actively developing, but not in production.

- Make sure you refresh your page after changing the code. Odoo currently does not
  have any hot module reloading mechanism.


Loading Javascript Code
=======================

Large applications are usually broken up into smaller files, that need to be
connected together.  Some file may need to use code defined in
another file. There are two ways of sharing code between files:

- using the global scope (the *window* object) to read/write references to some
  objects or functions,

- using a module system that will provide a way for each modules to export or import
  values, and will make sure that they are loaded in a proper order.

While it's possible to work in the global scope, this has a number of issues:

- It is difficult to ensure that implementation details are not exposed: function
  declarations in the global scope are accessible to all other code.

- There is a single namespace, creating great potential for naming conflicts.

- Dependencies are implicit: if a piece of code depends on another, the order in
  which they are loaded is important, but difficult to guarantee.

Using a module system helps resolve these issues: because modules specify their
dependencies, the module system can load them in the proper order or emit an error
if dependencies are missing or circular. Modules also form their own namespace,
and can choose what to export, preventing exposure of implementation detail and
naming collisions.

While we could use ECMAScript (ES) modules directly, there are a number of
disadvantages to that approach: each ES module requires a network round trip, which
becomes very slow when you have hundreds of files, and many files in Odoo need to
be present despite not being imported by anything because they simply add code
that the framework will use instead of the other way around.

Because of this, Odoo has a system of asset bundles. In these bundles, JavaScript
files are ES modules with a special annotation at the top. These modules will be
bundled together and transpiled to be usable by our module loader. While you can
write code that doesn't use this module system, it is generally not recommended.

(see :ref:`frontend/modules/native_js`)


Patching classes
----------------

While we do our best to provide extension points that don't require it, it is
sometimes necessary to modify the behavior of an existing class *in place*. The
goal is to have a mechanism to change a class and all future/present instances.
This is done by using the `patch` utility function:

.. code-block:: javascript

    import { Hamster } from "@web/core/hamster"
    import { patch } from "@web/core/utils/patch";

    patch(Hamster.prototype, {
        sleep() {
            super.sleep(...arguments);
            console.log("zzzz");
        },
    });

When patching methods, you need to patch the class' prototype, but if you would
like to patch a static property of the class, you need to patch the class itself.

Patching is a dangerous operation and should be done with care as it will
modify all instances of the class, even if they have already been created. To
avoid weird issues, patches should be applied as soon as possible, at the
top-level of your module. Patching classes at runtime can result in extremely
difficult to debug issues if the class has already been instanciated.

Registries
==========

A common need in the Odoo ecosystem is to extend/change the behaviour of the
base system from the outside (by installing an application, i.e. a different
module).  For example, one may need to add a new field widget in some views. In
that case, and many others, the usual process is to create the desired component,
then add it to a registry (registering step), to make the rest of the web client
aware of its existence.

There are a few registries available in the system. The registries that are used
by the framework are categories on the main registry, that can be imported from
:js:data:`@web/core/registry`

field registry
  The field registry contains all field widgets known to the web client.
  Whenever a view (typically form or list/kanban) needs a field widget, this
  is where it will look. A typical use case look like this:

  .. code-block:: javascript

      import { registry } from "@web/core/registry";
      class PadField extends Component { ... }

      registry.category("fields").add("pad", {
        component: PadField,
        supportedTypes: ["char"],
        // ...
      });

view registry
  This registry contains all JS views known to the web client.

action registry
  We keep track of all client actions in this registry.  This
  is where the action manager looks up whenever it needs to create a client
  action. Client actions can be a function - the function will be called when the
  action is invoked, and the returned value will be executed as a follow up action
  if needed - or an Owl component that will be displayed when executing that action.

Services
========

Within the webclient, there are some concerns that cannot be handled by a single
component, as the concern is transversal, involves many components, or needs to
maintain some state for as long as the application is alive.

Services are a solution to these problems: they are created during application
startup, are available to components through the hook `useService`, and stay
alive for the entire lifetime of the application.

For example, we have the *orm* service whose job is to allow interacting with
business objects on the server.

Here is a simplified example on how the orm service is implemented:

.. code-block:: javascript

    import { registry } from "@web/core/registry";
    export const OrmService = {
        start() {
            return {
                read(...) { ... },
                write(...) { ... },
                unlink(...) { ... },
                ...
            }
        },
    };
    registry.category("services").add("orm", OrmService);

Using services
--------------

Services are available in the environment, but should generally be used through
the `useService` hook, which prevents calling methods on the service after a
component has been destroyed, and prevents further code from executing after a
method call if the component was destroyed during the call.

.. code-block:: javascript

    class SomeComponent extends Component {
        setup() {
            this.orm = useService("orm");
        }
        // ...
        getActivityModelViewID(model) {
            return this.orm.call(model, "get_activity_view_id", this.params);
        }
    }

Talking to the server
---------------------

There are typically two use cases when working on Odoo: one may need to call a
method on a (python) model (this goes through the controller `/web/dataset/call_kw`),
or one may need to directly call a controller (available on some route).

* Calling a method on a python model is done through the orm service:

  .. code-block:: javascript

      return this.orm.call("some.model", "some_method", [some, args]);

* Directly calling a controller is done through the rpc service:

  .. code-block:: javascript

      return this.rpc("/some/route/", {
          some: param,
      });

.. note::
    The rpc service doesn't really perform what is generally understood as a
    remote procedure call (RPC), but for historical reasons, within Odoo we
    generally call any network request performed in JavaScript an RPC. As
    highlighted in the previous paragraph, if you want to call a method on a
    model, you should use the orm service.

Notifications
=============

The Odoo framework has a standard way to communicate various information to the
user: notifications, which are displayed on the top right of the user interface.
The types of notification follow the bootstrap toasts:

- *info*: useful to display some informational feedback as a consequence of an
  action that cannot fail.

- *success*: the user performed an action that can sometimes fail but didn't.

- *warning*: the user performed an action that could only be partially completed.
  Also useful if something is wrong but wasn't caused by the user directly, or
  is not particularly actionable.

- *success*: the user tried to performed an action but it couldn't be completed.


Notifications can also be used to ask a question to the user without disturbing
their workflow: e.g. a phone call received through VOIP: a sticky notification
could be displayed with two buttons to *Accept* or *Decline*.

Displaying notifications
------------------------

There are two ways to display notifications in Odoo:

- The *notification* service allows component to display notifications from JS
  code by calling the add method.

- The *display_notification* client action allows to trigger the display
  of a notification from python (e.g. in the method called when the user
  clicked on a button of type object). This client action uses the notification
  service.

Notifications have a few *options*:

- *title*: string, optional. This will be displayed on the top as a title.

- *message*: string, optional. The content of the notification. Can be a markup
  object to display formatted text.

- *sticky*: boolean, optional (default false). If true, the notification
  will stay until the user dismisses it.  Otherwise, the notification will
  be automatically closed after a short delay.

- *type*: string, optional (default "warning"). Determines the style of the
  notification. Possible values: "info", "success", "warning", "danger"

- *className*: string, optional.  This is a css class name that will be
  automatically added to the notification. This could be useful for styling
  purpose, even though its use is discouraged.

Here are some examples on how to display notifications in JS:

.. code-block:: javascript

    // note that we call _t on the text to make sure it is properly translated.
    this.notification.add({
        title: _t("Success"),
        message: _t("Your signature request has been sent.")
    });
    this.notification.add({
        title: _t("Error"),
        message: _t("Filter name is required."),
        type: "danger",
    });

And in Python:

.. code-block:: python

    # note that we call _(string) on the text to make sure it is properly translated.
    def show_notification(self):
        return {
            'type': 'ir.actions.client',
            'tag': 'display_notification',
            'params': {
                'title': _('Success'),
                'message': _('Your signature request has been sent.'),
                'sticky': False,
            }
        }

Systray
=======

The Systray is the right part of the navbar in the interface, where the web
client displays a few widgets, such as the messaging menu.

When the systray is created by the navbar, it will look for all registered
systray items and display them.

There is currently no specific API for systray items.  They are Owl components,
and can communicate with their environment just like other components, e.g. by
interacting with services.

Adding a new Systray Item
-------------------------

Items can be added to the systray by adding them to the "systray" registry:

.. code-block:: javascript

    import { registry } from "@web/core/registry"
    class MySystrayComponent extends Component {
        ...
    }
    registry.category("systray").add("MySystrayComponent", MySystrayComponent, { sequence: 1 });

The items are ordered in the systray according to their sequence in the systray
registry.

Translation management
======================

Some translations are made on the server side (basically all text strings rendered or
processed by the server), but there are strings in the static files that need
to be translated. The way it currently works is the following:

- each translatable string is tagged with the special function *_t*
- these strings are used by the server to generate the proper PO files
- whenever the web client is loaded, it will call the route */web/webclient/translations*,
  which returns a list of all translatable terms
- at runtime, whenever the function `_t` is called, it will look up in this list
  in order to find a translation, and return it or the original string if none
  is found.

Note that translations are explained in more details, from the server point of
view, in the document :doc:`/developer/howtos/translations`.

.. code-block:: javascript

    import { _t } from "@web/core/l10n/translation";

    class SomeComponent extends Component {
        static exampleString = _t("this should be translated");
        ...
        someMethod() {
            const str = _t("some text");
        }
    }

Note that using the translation function requires some care: the string given as
an argument cannot be dynamic, as it is extracted statically from the code to
generate the PO files and serves as the identifier for the term to translate. If
you need to inject some dynamic content in the string, `_t` supports placeholders:

.. code-block:: javascript

    import { _t } from "@web/core/l10n/translation";
    const str = _t("Hello %s, you have %s unread messages.", user.name, unreadCount);

Notice how the string itself is fixed. This allows the translation function to
retrieve the translated string *before* using it for interpolation.


Session
=======

The webclient needs some information from the python to function properly. To
avoid an extra round-trip with the server by making a network request in JavaScript,
this information is serialized directly in the page, and can be accessed in JS
through the `@web/session` module.

Adding information to the session
---------------------------------

When the `/web` route is loaded, the server injects this information in a script
tag. The information is obtained by calling the method `session_info` of
the model `ir.http`. You can override this method to add information to the
returned dictionary.

.. code-block:: python

    from odoo import models
    from odoo.http import request

    class IrHttp(models.AbstractModel):
        _inherit = ['ir.http']

        def session_info(self):
            result = super(IrHttp, self).session_info()
            result['some_key'] = get_some_value_from_db()
            return result

Now, the value can be obtained in javascript by reading it in the session:

.. code-block:: javascript

    import { session } from "@web/session"
    const myValue = session.some_key;
    ...

Note that this mechanism is designed to reduce the amount of communication
needed by the web client to be ready.  It is only appropriate for data which is
cheap to compute (a slow session_info call will delay the loading for the web
client for everyone), and for data which is required early in the initialization
process.

Views
=====

The word "view" has more than one meaning. This section is about the design of
the javascript code of the views, not the structure of the *arch* or anything
else.

While views are just owl components, the built-in views generally have the same
structure: a component called "SomethingController" which is the root of the view.
This component creates an instance of some "model" (an object responsible for
managing the data), and has a subcomponent called a "renderer" that handles the
display logic.

.. _reference/js/widgets:

Fields
======

A good part of the web client experience is about editing and creating data. Most
of that work is done with the help of field widgets, which are aware of the field
type and of the specific details on how a value should be displayed and edited.

.. _reference/javascript_reference/field_decoration:

Decorations
-----------

Like the list view, field widgets have a simple support for decorations. The
goal of decorations is to have a simple way to specify a text color depending on
the record current state.  For example:

.. code-block:: xml

    <field name="state" decoration-danger="amount &lt; 10000"/>

The valid decoration names are:

- `decoration-bf`
- `decoration-it`
- `decoration-danger`
- `decoration-info`
- `decoration-muted`
- `decoration-primary`
- `decoration-success`
- `decoration-warning`

Each decoration *decoration-X* will be mapped to a css class *text-X*, which is
a standard bootstrap css class (except for *text-it* and *text-bf*, which are
handled by odoo and correspond to italic and bold, respectively).  Note that the
value of the decoration attribute should be a valid python expression, which
will be evaluated with the record as evaluation context.

Non-relational fields
---------------------

We document here all non relational fields available by default, in no particular
order.

Integer (`integer`)
    This is the default field type for fields of type `integer`.

    - Supported field types: `integer`

    Options:

    - `type`: setting the input type (`"text"` by default, can be set on `"number"`)

        In edit mode, the field is rendered as an input with the HTML attribute type
        set on `"number"` (so user can benefit the native support, especially on
        mobile). In this case, the default formatting is disabled to avoid incompability.

        .. code-block:: xml

            <field name="int_value" options="{'type': 'number'}" />

    - `step`: set the step to the value up and down when the user click on buttons
      (only for input of type number, `1` by default)

        .. code-block:: xml

            <field name="int_value" options="{'type': 'number', 'step': 100}" />

    - `format`: should the number be formatted. (`true` by default)

        By default, numbers are formatted according to locale parameters.
        This option will prevent the field's value from being formatted.

        .. code-block:: xml

            <field name="int_value" options='{"format": false}' />

Float (`float`)
    This is the default field type for fields of type `float`.

    - Supported field types: `float`

    Attributes:

    - `digits`: displayed precision

        .. code-block:: xml

            <field name="factor" digits="[42,5]" />

    Options:

    - `type`: setting the input type (`"text"` by default, can be set on `"number"`)

        In edit mode, the field is rendered as an input with the HTML attribute type
        set on `"number"` (so user can benefit the native support, especially on
        mobile). In this case, the default formatting is disabled to avoid incompability.

        .. code-block:: xml

            <field name="int_value" options="{'type': 'number'}" />

    - `step`: set the step to the value up and down when the user click on buttons
      (only for input of type number, `1` by default)

        .. code-block:: xml

            <field name="int_value" options="{'type': 'number', 'step': 0.1}" />

    - `format`: should the number be formatted. (`true` by default)

        By default, numbers are formatted according to locale parameters.
        This option will prevent the field's value from being formatted.

        .. code-block:: xml

            <field name="int_value" options="{'format': false}" />

    - `hide_trailing_zeros`: hide zeros to the right of the last non-zero digit,
      e.g. `1.20` becomes `1.2` (`false` by default).

        .. code-block:: xml

            <field name="int_value" options="{'hide_trailing_zeros': true}" />

Time (`float_time`)
    The goal of this widget is to display properly a float value that represents
    a time interval (in hours).  So, for example, `0.5` should be formatted as `0:30`,
    or `4.75` correspond to `4:45`.

    - Supported field types: `float`

Float Factor (`float_factor`)
    This widget aims to display properly a float value that converted using a factor
    given in its options. So, for example, the value saved in database is `0.5` and the
    factor is `3`, the widget value should be formatted as `1.5`.

    - Supported field types: `float`

Float Toggle (`float_toggle`)
    The goal of this widget is to replace the input field by a button containing a
    range of possible values (given in the options). Each click allows the user to loop
    in the range. The purpose here is to restrict the field value to a predefined selection.
    Also, the widget support the factor conversion as the `float_factor` widget (Range values
    should be the result of the conversion).

    - Supported field types: `float`

    .. code-block:: xml

        <field name="days_to_close" widget="float_toggle" options="{'factor': 2, 'range': [0, 4, 8]}" />

Boolean (`boolean`)
    This is the default field type for fields of type `boolean`.

    - Supported field types: `boolean`

Char (`char`)
    This is the default field type for fields of type `char`.

    - Supported field types: `char`

.. _reference/javascript_reference/date_field:

Date (`date`)
    This is the default field type for fields of type `date`. It consists of a text
    box and a date picker.
    The field will show the date in a readable format like this: `Dec 19, 1997`.
    The year will be hidden if it's the current one. When editing the field, the numeric format
    will be shown. This format corresponds to the one set in the current language.

    - Supported field types: `date`

    Options:

    - `min_date` / `max_date`: sets limit dates for accepted values. By default, the earliest
      accepted date is **1000-01-01** and the latest is **9999-12-31**.
      Accepted values are SQL-formatted dates (`yyyy-MM-dd HH:mm:ss`) or `"today"`.

        .. code-block:: xml

            <field name="datefield" options="{'min_date': 'today', 'max_date': '2023-12-31'}" />

    - `warn_future`: displays a warning if the value is in the future (based on today).

        .. code-block:: xml

            <field name="datefield" options="{'warn_future': true}" />

    - `numeric`: when set to true, it shows the date in the format set on the current language.
      (default: `false`).

        .. code-block:: xml

            <field name="datefield" options="{'numeric': true}" />

.. _reference/javascript_reference/datetime_field:

Date & Time (`datetime`)
    This is the default field type for fields of type `datetime`. The values are always
    in the client's timezone. The displayed format has the same behaviour as the date
    field, see :ref:`Date Field <reference/javascript_reference/date_field>` description.
    The readable format looks like this: `Dec 19, 1997, 10:45 AM`.

    - Supported field types: `datetime`

    Options:

    - see :ref:`Date Field <reference/javascript_reference/date_field>` options

    - `rounding`: increment used to generate available minutes in the time picker.
      This does not affect the actual value, just the amount of available options in
      the select dropdown (default: `5`).

        .. code-block:: xml

            <field name="datetimefield" options="{'rounding': 10}" />

    - `show_seconds`: when set to true, it shows the seconds from the datetime field.
      The field will still accept datetime values, but the seconds will be shown in
      the UI (default: `false`).

        .. code-block:: xml

            <field name="datetimefield" widget="datetime" options="{'show_seconds': true}" />

    - `show_time`: when set to false, it hides the time part from the datetime field.
      The field will still accept datetime values, but the time part will be hidden in
      the UI (default: `true`).

        .. code-block:: xml

            <field name="datetimefield" widget="datetime" options="{'show_time': false}" />

    - `show_date`: when set to false, it hides the date part from the datetime field.
      The field will still accept datetime values, but the date part will be hidden in
      the UI (default: `true`).

        .. code-block:: xml

            <field name="datetimefield" widget="datetime" options="{'show_date': false}" />

Date Range (`daterange`)
    This widget allows the user to select start and end date from a single picker.

    - Supported field types: `date`, `datetime`

    Options:

    - see :ref:`Date Field <reference/javascript_reference/date_field>` or :ref:`Date & Time Field <reference/javascript_reference/datetime_field>` options

    - `start_date_field`: field used to get/set the start value of the date range
      (cannot be used with `end_date_field`).

        .. code-block:: xml

            <field name="end_date" widget="daterange" options="{'start_date_field': 'start_date'}" />

    - `end_date_field`: field used to get/set the end value of the date range
      (cannot be used with `start_date_field`).

        .. code-block:: xml

            <field name="start_date" widget="daterange" options="{'end_date_field': 'end_date'}" />

Remaining Days (`remaining_days`)
    This widget can be used on date and datetime fields. In readonly, it displays
    the delta (in days) between the value of the field and today. The widget turns
    into a regular date or datetime field in edit mode.

    - Supported field types: `date`, `datetime`

Monetary (`monetary`)
    This is the default field type for fields of type `monetary`. It is used to
    display a currency.  If there is a currency fields given in option, it will
    use that, otherwise it will fall back to the default currency (in the session)

    - Supported field types: `monetary`, `float`

    Options:

    - `currency_field`: another field name which should be a many2one on currency.

        .. code-block:: xml

            <field name="value" widget="monetary" options="{'currency_field': 'currency_id'}" />

    - `hide_trailing_zeros`: hide zeros to the right of the last non-zero digit,
      e.g. `1.20` becomes `1.2` (`false` by default).

        .. code-block:: xml

            <field name="int_value" options="{'hide_trailing_zeros': true}" />

Text (`text`)
    This is the default field type for fields of type `text`.

    - Supported field types: `text`


Handle (`handle`)
    This field's job is to be displayed as a `handle`, and allows reordering the
    various records by drag and dropping them.

    .. warning:: It has to be specified on the field by which records are sorted.
    .. warning:: Having more than one field with a handle widget on the same list is not supported.

    - Supported field types: `integer`


Email (`email`)
    This field displays email address.  The main reason to use it is that it
    is rendered as an anchor tag with the proper href, in readonly mode.

    - Supported field types: `char`

Phone (`phone`)
    This field displays a phone number.  The main reason to use it is that it
    is rendered as an anchor tag with the proper href, in readonly mode, but
    only in some cases: we only want to make it clickable if the device can
    call this particular number.

    - Supported field types: `char`

URL (`url`)
    This field displays an url (in readonly mode). The main reason to use it is
    that it is rendered as an anchor tag with the proper css classes and href.

    Also, the text of the anchor tag can be customized with the *text* attribute
    (it won't change the href value).

    - Supported field types: `char`

    .. code-block:: xml

        <field name="foo" widget="url" text="Some URL" />

    Options:

    - `website_path`: (default: `false`) by default, the widget forces (if not already
      the case) the href value to begin with `"http://"` except if this option is set
      to `true`, thus allowing redirections to the database's own website.

Domain (`domain`)
    The `domain` field allows the user to construct a technical-prefix domain
    thanks to a tree-like interface and see the selected records in real time.
    In debug mode, an input is also there to be able to enter the prefix char
    domain directly (or to build advanced domains the tree-like interface does
    not allow to).

    Note that this is limited to **static** domains (no dynamic expressions, or access
    to context variable).

    - Supported field types: `char`

  Options:

    - `model`: the name of the char field encoding the `res_model` on which the domain applies.

    - `foldable` (default: `false`): if true, the domain field is rendered compactly and unfolds
      itself upon user interaction.

    - `in_dialog` (default: `false`): if true, the widget opens a dialog when the user wants to edit
      the domain whereas by default, the domain editor is rendered just below the value.

    - `count_limit` (default: `10000`): the domain widget performs search_count requests to validate
      the domain, and to indicate the number of records matching it. This requests might be costly
      on large tables, so by default, the search_count is limited to 10000.

Link button (`link_button`)
    The `LinkButton` widget actually simply displays a span with an icon and the
    text value as content. The link is clickable and will open a new browser
    window with its value as url.

    - Supported field types: `char`

Image File (`image`)
    This widget is used to represent a binary value as an image. In some cases,
    the server returns a `bin_size` instead of the real image (a `bin_size` is a
    string representing a file size, such as `"6.5kb"`).  In that case, the widget
    will make an image with a source attribute corresponding to an image on the
    server.

    - Supported field types: `binary`

    Options:

    - `preview_image`: if the image is only loaded as a `bin_size`, then this
      option is useful to inform the web client that the default field name is
      not the name of the current field, but the name of another field.

        .. code-block:: xml

            <field name="image" widget="image" options="{'preview_image': 'image_128'}" />

    - `accepted_file_extensions`: the file extension the user can pick from the file input dialog box
      (default value is `"image/\*"`)

        (cf: ``accept`` attribute on `<input type="file" />`)

Binary File (`binary`)
    Generic widget to allow saving/downloading a binary file.

    - Supported field types: `binary`

    Attributes:

    - `filename`: saving a binary file will lose its file name, since it only
      saves the binary value. The file name can be saved in another field. To do
      that, a `filename` attribute should be set to a field present in the view.

        .. code-block:: xml

            <field name="datas" filename="datas_fname" />

    Options:

    - `accepted_file_extensions`: the file extension the user can pick from the file input dialog box

        (cf: ``accept`` attribute on `<input type="file" />`)

Priority (`priority`)
    This widget is rendered as a set of stars, allowing the user to click on it
    to select a value or not. This is useful for example to mark a task as high
    priority.

    Note that this widget also works in `readonly` mode, which is unusual.

    - Supported field types: `selection`

Image Attachment (`attachment_image`)
    Image widget for `many2one` fields. If the field is set, this widget will be
    rendered as an image with the proper src url. This widget does not have a
    different behaviour in edit or readonly mode, it is only useful to view an
    image.

    - Supported field types: `many2one`

    .. code-block:: xml

        <field name="displayed_image_id" widget="attachment_image" />

Label Selection (`label_selection`)
    This widget renders a simple non-editable label. This is only useful to
    display some information, not to edit it.

    - Supported field types: `selection`

    Options:

    - `classes`: a mapping from a selection value to a CSS class name

        .. code-block:: xml

            <field
                name="state"
                widget="label_selection"
                options="{
                    'classes': {
                        'draft': 'default',
                        'cancel': 'default',
                        'none': 'danger',
                    },
                }"
            />

State Selection (`state_selection`)
    This is a specialized selection widget. It assumes that the record has some
    hardcoded fields, present in the view: `stage_id`, `legend_normal`,
    `legend_blocked`, `legend_done`. This is mostly used to display and change
    the state of a task in a project, with additional information displayed in
    the dropdown.

    - Supported field types: `selection`

    .. code-block:: xml

        <field name="kanban_state" widget="state_selection" />

State Selection - List View (`list.state_selection`)
    In list views, the `state_selection` field displays by default the label next to the icon.

    - Supported field types: `selection`

    Options:

    - `hide_label`: hide the label next to the icon

        .. code-block:: xml

            <field name="kanban_state" widget="state_selection" options="{'hide_label': true}" />

Favorite (`boolean_favorite`)
    This widget is displayed as an empty (or not) star, depending on a boolean
    value. Note that it also can be edited in readonly mode.

    - Supported field types: `boolean`

Toggle (`boolean_toggle`)
    Displays a toggle switch to represent a boolean. This is a subfield of the
    `boolean` field, mostly used to have a different look.

    - Supported field types: `boolean`

Stat Info (`statinfo`)
    This widget is meant to represent statistical information in a `stat button`.
    It is basically just a label with a number.

    - Supported field types: `integer`, `float`

    Options:

    - `label_field`: if given, the widget will use the value of the `label_field` as text.

        .. code-block:: xml

            <button
                name="%(act_payslip_lines)d"
                icon="fa-money"
                type="action"
            >
                <field
                    name="payslip_count"
                    widget="statinfo"
                    string="Payslip"
                    options="{'label_field': 'label_tasks'}"
                />
            </button>

Percent Pie (`percentpie`)
    This widget is meant to represent statistical information in a `stat button`.
    This is similar to a statinfo widget, but the information is represented in
    a **pie chart** (empty to full).  Note that the value is interpreted as a
    percentage (a number between `0` and `100`).

    - Supported field types: `integer`, `float`

    .. code-block:: xml

        <field name="replied_ratio" string="Replied" widget="percentpie" />

Progress Bar (`progressbar`)
    Represent a value as a progress bar (from `0` to some value)

    - Supported field types: `integer`, `float`

    Options:

    - `editable`: boolean determining whether the `value` is editable

    - `current_value`: get the current value from the field that must be present in the view

    - `max_value`: get the maximum value from the field that must be present in the view

    - `edit_max_value`: boolean determining whether the `max_value` is editable

    - `title`: title of the bar, displayed on top of the bar

        -> not translated, use `title` attribute (not option) instead if the term must be translated

    .. code-block:: xml

        <field
            name="absence_of_today"
            widget="progressbar"
            options="{
                'current_value': 'absence_of_today',
                'max_value': 'total_employee',
                'editable': false,
            }"
        />

Journal Dashboard Graph (`dashboard_graph`)
    This is a more specialized widget, useful to display a graph representing a
    set of data. For example, it is used in the accounting dashboard kanban view.

    It assumes that the field is a JSON serialization of a set of data.

    - Supported field types: `char`

    Attributes:

    - `graph_type`: string, can be either `"line"` or `"bar"`

        .. code-block:: xml

            <field name="dashboard_graph_data" widget="dashboard_graph" graph_type="line" />

Ace Editor (`ace`)
    This widget is intended to be used on Text fields. It provides Ace Editor
    for editing XML and Python.

    - Supported field types: `char`, `text`

Badge (`badge`)
    Displays the value inside a bootstrap badge pill.

    - Supported field types: `char`, `selection`, `many2one`

    By default, the badge has a light grey background, but it can be customized
    by using the :ref:`Decoration <reference/javascript_reference/field_decoration>` mechanism.
    For instance, to display a red badge under a given condition:

    .. code-block:: xml

        <field name="foo" widget="badge" decoration-danger="state == 'cancel'" />

Relational fields
-----------------

Selection (`selection`)

    - Supported field types: `selection`

    Attributes:

    - `placeholder`: a string which is used to display some info when no value is selected

        .. code-block:: xml

            <field name="tax_id" widget="selection" placeholder="Select a tax" />

Radio (`radio`)
    This is a subfield of `FielSelection`, but specialized to display all the
    valid choices as radio buttons.

    Note that if used on a many2one records, then more rpcs will be done to fetch
    the name_gets of the related records.

    - Supported field types: `selection`, `many2one`

    Options:

    - `horizontal`: if `true`, radio buttons will be displayed horizontally.

        .. code-block:: xml

            <field name="recommended_activity_type_id" widget="radio" options="{'horizontal': true}"/>

Badge Selection (`selection_badge`)
    This is a subfield of `selection` field, but specialized to display all the
    valid choices as rectangular badges.

    - Supported field types: `selection`, `many2one`

    .. code-block:: xml

        <field name="recommended_activity_type_id" widget="selection_badge" />

Many2one (`many2one`)
    Default widget for many2one fields.

    - Supported field types: `many2one`

    Attributes:

    - `can_create`: allow the creation of related records
      (takes precedence over `no_create` option)

    - `can_write`: allow the editing of related records (default: `true`)

    Options:

    - `quick_create`: allow the quick creation of related records (default: `true`)

    - `no_create`: prevent the creation of related records - hide both the **Create "xxx"**
      and **Create and Edit** dropdown menu items (default: `false`)

    - `no_quick_create`: prevent the quick creation of related records - hide the **Create "xxx"**
      dropdown menu item (default: `false`)

    - `no_create_edit`: hide the **Create and Edit** dropdown menu item (default: `false`)

    - `create_name_field`: when creating a related record, if this option is set,
      the value of the `create_name_field` will be filled with the value of the input
      (default: `name`)

    - `always_reload`: boolean, default to `false`. If `true`, the widget will always
      do an additional `name_get` to fetch its name value. This is used for the
      situations where the `name_get` method is overridden (please do not do that)

    - `no_open`: boolean, default to `false`. If set to `true`, the many2one will not
      redirect on the record when clicking on it (in readonly mode)

    .. code-block:: xml

        <field name="currency_id" options="{'no_create': true, 'no_open': true}" />

Many2one Barcode (`many2one_barcode`)
    Widget for `many2one` fields allows to open the camera from a mobile device (Android/iOS) to scan a barcode.

    Specialization of `many2one` field where the user is allowed to use the native camera to scan a barcode.
    Then it uses `name_search` to search this value.

    If this widget is set and user is not using the mobile application,
    it will fallback to regular `many2one` (`Many2OneField`)

    - Supported field types: `many2one`

Many2one Avatar (`many2one_avatar`)
    This widget is only supported on `many2one` fields pointing to a model which
    inherits from `image.mixin`. In readonly, it displays the image of the
    related record next to its `display_name`. Note that the `display_name` isn't a
    clickable link in this case. In edit, it behaves exactly like the regular
    `many2one`.

    - Supported field types: `many2one`

Many2one Avatar User (`many2one_avatar_user`)
    This widget is a specialization of the `Many2OneAvatar`. When the avatar is
    clicked, we open a chat window with the corresponding user. This widget can
    only be set on `many2one` fields pointing to the `res.users` model.

    - Supported field types: `many2one` (pointing to `res.users`)

Many2one Avatar Employee (`many2one_avatar_employee`)
    Same as `many2one_avatar_user`, but for `many2one` fields pointing to `hr.employee`.

    - Supported field types: `many2one` (pointing to `hr.employee`)

Many2many (`many2many`)
    Default widget for `many2many` fields.

    - Supported field types: `many2many`

    Attributes:

    - `mode`: string, default view to display

    - `domain`: restrict the data to a specific domain

    Options:

    - `create_text`: allow the customization of the text displayed when adding a new record

    - `link`: domain determining whether records can be added to the relation (default: `true`).

    - `unlink`: domain determining whether records can be removed from the relation (default: `true`).

Many2many Binary File (`many2many_binary`)
    This widget helps the user to upload or delete one or more files at the same time.

    Note that this widget is specific to the model `ir.attachment`.

    - Supported field types: `many2many`

    Options:

    - `accepted_file_extensions`: the file extension the user can pick from the file input dialog box

        (cf: ``accept`` attribute on `<input type="file" />`)

Many2many Tags (`many2many_tags`)
    Display a `many2many` field as a list of tags.

    - Supported field types: `many2many`

    Options:

    - `create`: domain determining whether or not new tags can be created (default: `true`).

        .. code-block:: xml

            <field name="category_id" widget="many2many_tags" options="{'create': [['some_other_field', '>', 24]]}" />

    - `color_field`: the name of a numeric field, which should be present in the view.
      A color will be chosen depending on its value.

        .. code-block:: xml

            <field name="category_id" widget="many2many_tags" options="{'color_field': 'color'}" />

    - `no_edit_color`: set to `true` to remove the possibility to change the color of the tags
      (default: `false`).

        .. code-block:: xml

            <field name="category_id" widget="many2many_tags" options="{'color_field': 'color', 'no_edit_color': true}" />

    - `edit_tags`: set to `true` to add the possibility to update tag related record by clicking on the tags.
      (default: `false`).

        .. code-block:: xml

            <field name="category_id" widget="many2many_tags" options="{'edit_tags': true}" />

Many2many Tags - Form View (`form.many2many_tags`)
    Specialization of `many2many_tags` widget for form views. It has some extra
    code to allow editing the color of a tag.

    - Supported field types: `many2many`

Many2many Tags - Kanban View (`kanban.many2many_tags`)
    Specialization of `many2many_tags` widget for kanban views.

    - Supported field types: `many2many`

Many2many Checkboxes (`many2many_checkboxes`)
    This field displays a list of checkboxes and allows the user to select a
    subset of the choices. Note that the number of displayed values is limited to
    `100`. This limit isn't customizable. It simply allows to handle extreme cases
    where this widget is wrongly set on a field with a huge comodel. In those
    cases, a list view is more adequate as it allows pagination and filtering.

    - Supported field types: `many2many`

One2many (`one2many`)
    Default widget for `one2many` fields.
    It usually displays data in a sub list view, or a sub kanban view.

    - Supported field types: `one2many`

    Options:

    - `create`: domain determining whether or not related records can be created (default: `true`).

    - `delete`: domain determining whether or not related records can be deleted (default: `true`).

        .. code-block:: xml

            <field name="turtles" options="{'create': [['some_other_field', '>', 24]]}" />

    - `create_text`: a string that is used to customize the 'Add' label/text.

        .. code-block:: xml

            <field name="turtles" options="{'create_text': 'Add turtle'}" />

Status Bar (`statusbar`)
    This is a field specific to the form views. It is the bar on top
    of many forms which represent a flow, and allow selecting a specific state.

    - Supported field types: `selection`, `many2one`

Reference (`reference`)
    The `reference` field is a combination of a select (for the model) and a
    `many2one` field (for its value).  It allows the selection of a record on an
    arbitrary model.

    - Supported field types: `char`, `reference`

    Options:

    - `model_field`: name of an `ir.model` containing the model of the records that can be selected.
      When this option is set, the select part of the `reference` field isn't displayed.

.. _reference/javascript_reference/view_widgets:

Widgets
-------

Ribbon (`web_ribbon`)
    This widget displays a ribbon at the top right corner of the kanban card or the form view sheet,
    for instance, to indicate archived records.

    .. code-block:: xml

        <widget name="web_ribbon" title="Archived" bg_color="text-bg-danger"/>

    Attributes:

    - `title`: text displayed in the ribbon.
    - `tooltip`: text displayed in the ribbon's tooltip.
    - `bg-class`: classname to set on the ribbon, typically to define the ribbon's color.

Week Days (`week_days`)
    This widget displays a list of checkboxes for week days, 1 checkbox for each day
    and allow the user to select a subset of the choices.

    .. code-block:: xml

        <widget name="week_days" />

Client actions
==============

A client action is a component that can be displayed as the main element in the
webclient, occupying all the space below the navbar, just like an `act_window_action`.
This is useful when you need a component that is not closely linked to an existing
view or a specific model.  For example, the Discuss application is a client action.

A client action is a term that has various meanings, depending on the context:

- from the perspective of the server, it is a record of the model *ir_action*,
  with a field *tag* of type char
- from the perspective of the web client, it is an Owl component registered in the
  action registry under the same key its tag

Whenever a menu item is associated with a client action, opening it will simply
fetch the action definition from the server, then lookup its tag in the action
registry to get the component definition. This component will then be rendered by
the action container.

Adding a client action
----------------------

A client action is a component that will control the part of the screen below the
navbar. Defining a client action is as simple as creating an Owl component and
adding it to the action registry.

.. code-block:: javascript

    import { registry } from "@web/core/registry";
    class MyClientAction extends Component { ... }
    registry.category("actions").add("my-custom-action", ClientAction);

Then, to use the client action in the web client, we need to create a client
action record (a record of the model ``ir.actions.client``) with the proper
``tag`` attribute:

.. code-block:: xml

    <record id="my_client_action" model="ir.actions.client">
        <field name="name">Some Name</field>
        <field name="tag">my-custom-action</field>
    </record>


==================================================
SECTION: mobile.rst
PATH: developer/reference/frontend/mobile.rst
==================================================

.. _reference/mobile:

=================
Mobile JavaScript
=================

Introduction
============

In Odoo 10.0 we released a mobile app which allows you to access all **Odoo apps**
(even your customized modules).

The application is a combination of **Odoo Web** and **Native Mobile components**. In other words it
is a Odoo Web instance loaded inside a native, mobile, WebView container.

This page documents how you can access mobile native components like Camera,
Vibration, Notification and Toast through Odoo Web (via JavaScript). For this, you
do not need to be a mobile developer, if you know Odoo JavaScript API you can
access all available mobile features.

.. warning::
   These features work with **Odoo Enterprise 10.0+** only

How does it work?
=================

Internal workings of the mobile application:

.. image:: mobile/mobile_working.jpg

Of course, it is a web page that loads on a Mobile Native Web container. But it
is integrated in such a way that you can access native resources from your web
JavaScript.

WebPages (Odoo Web) is on the top of each layer, where the second layer is a Bridge
between Odoo Web (JS) and the native mobile components.

When any call from JavaScript is triggered it passes through Bridge and Bridge
passes it to the native invoker to perform that action.

When the native component has done its work, it is passed to the Bridge again and
you get the output in JavaScript.

Process time taken by the Native component depends on what you are requesting
from the Native resources. For example the Camera or GPS Location.

How to use it?
==============

Just like the Odoo Web Framework, the Mobile API can be used anywhere by getting the object from
**web_mobile.rpc**

.. image:: mobile/odoo_mobile_api.png

The mobile RPC object provides a list of methods that are available (this only works with the mobile
app).

Check if the method is available and then execute it.

Methods
-------

.. note:: Each of the methods returns a JQuery Deferred object which returns
   a data JSON dictionary

Show Toast in device
~~~~~~~~~~~~~~~~~~~~

.. js:function:: showToast

    :param object args: **message** text to display

A toast provides simple feedback about an operation in a small popup. It only
fills the amount of space required for the message and the current activity
remains visible and interactive.

.. code-block:: javascript

    mobile.methods.showToast({'message': 'Message sent'});

.. image:: mobile/toast.png

Vibrating device
~~~~~~~~~~~~~~~~

.. js:function:: vibrate

    :param object args: Vibrates constantly for the specified period of time
           (in milliseconds).

Vibrate mobile device with given duration.

.. code-block:: javascript

    mobile.methods.vibrate({'duration': 100});

Show snackbar with action
~~~~~~~~~~~~~~~~~~~~~~~~~

.. js:function:: showSnackBar

    :param object args: (*required*) **Message** to show in snackbar and action **button label** in Snackbar (optional)
    :returns:  ``True`` if the user clicks on the Action button, ``False`` if SnackBar auto dismissed after some time.

Snackbars provide lightweight feedback about an operation. They show a brief
message at the bottom of the screen on mobile or in the lower left corner on larger devices.
Snackbars appear above all the other elements on the screen and only one can be
displayed at a time.

.. code-block:: javascript

    mobile.methods.showSnackBar({'message': 'Message is deleted', 'btn_text': 'Undo'}).then(function(result){
        if(result){
            // Do undo operation
        }else{
            // Snack Bar dismissed
        }
    });

.. image:: mobile/snackbar.png

Showing notification
~~~~~~~~~~~~~~~~~~~~

.. js:function:: showNotification

    :param object args: **title** (first row) of the notification, **message** (second row) of the notification, in a standard notification.

A notification is a message you can display to the user outside of your
application's normal UI. When you tell the system to issue a notification, it
first appears as an icon in the notification area. To see the details of the
notification, the user opens the notification drawer. Both the notification
area and the notification drawer are system-controlled areas that the user can
view at any time.

.. code-block:: javascript

    mobile.showNotification({'title': 'Simple Notification', 'message': 'This is a test for a simple notification'})

.. image:: mobile/mobile_notification.png


Create contact in device
~~~~~~~~~~~~~~~~~~~~~~~~

.. js:function:: addContact

    :param object args: Dictionary with contact details. Possible keys (name, mobile, phone, fax, email, website, street, street2, country_id, state_id, city, zip, parent_id, function and image)

Create a new device contact with the given contact details.

.. code-block:: javascript

    var contact = {
        'name': 'Michel Fletcher',
        'mobile': '9999999999',
        'phone': '7954856587',
        'fax': '765898745',
        'email': 'michel.fletcher@agrolait.example.com',
        'website': 'http://www.agrolait.com',
        'street': '69 rue de Namur',
        'street2': false,
        'country_id': [21, 'Belgium'],
        'state_id': false,
        'city': 'Wavre',
        'zip': '1300',
        'parent_id': [8, 'Agrolait'],
        'function': 'Analyst',
        'image': '<<BASE 64 Image Data>>'
    }

    mobile.methods.addContact(contact);

.. image:: mobile/mobile_contact_create.png

Scanning barcodes
~~~~~~~~~~~~~~~~~

.. js:function:: scanBarcode

    :returns: Scanned ``code`` from any barcode

The barcode API detects barcodes in real-time, on the device, in any orientation.

The barcode API can read the following barcode formats:

* 1D barcodes: EAN-13, EAN-8, UPC-A, UPC-E, Code-39, Code-93, Code-128, ITF, Codabar
* 2D barcodes: QR Code, Data Matrix, PDF-417, AZTEC

.. code-block:: javascript

    mobile.methods.scanBarcode().then(function(code){
        if(code){
            // Perform operation with the scanned code
        }
    });

Switching account in device
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. js:function:: switchAccount

Use switchAccount to switch from one account to another on the device.

.. code-block:: javascript

    mobile.methods.switchAccount();

.. image:: mobile/mobile_switch_account.png


==================================================
SECTION: mock_server.rst
PATH: developer/reference/frontend/unit_testing/mock_server.rst
==================================================

===========
Mock server
===========

Rationale
=========

Test cases can range in complexity; from testing the return value of a simple helper
function, to rendering an entire webclient to simulate interactions across several
components/services.

In the latter cases, many interactions will trigger server requests, without
which the components or features will stop functioning properly. However, it is
important that these requests *do not* land on the actual server, as they could
affect the database, which is definitely not something a test should be doing.

To overcome this, each request should be intercepted and replaced by a function
emulating actual server responses with test (i.e. fake) data.

Since some of these requests are very common (e.g. ORM calls, such as `web_search_read`
or `web_save`, or other methods such as `get_views`), a mock server has been
implemented by default for every test that spawns an :abbr:`env (Odoo environment)` [#]_.

These mock servers act independently for each test, can be configured separately,
and provide out of the box helpers for the most used routes in Odoo.

.. [#] A mock server is needed as soon as an environment is spawned because some :doc:`services <../services>`
    do send server requests as soon as they start.

Overview
========

A mock server is actually quite simple in itself: it is an object containing a *collection*
of all defined mock models, and a *mapping* between routes and callbacks returning
the test data.

The mock models themselves hold most of the CRUD logic, as well as the data used
to simulate server records.

Once a mock server starts, it hijacks *all* server requests, and for each of them
it will check in its *mapping* whether one of its registered routes matches
the requested URL. The most notable example of its pre-defined routes is
`/web/dataset/call_kw`, which is responsible for calling an ORM method on the
appropriate mock model.

.. note::
    Like most test helpers not provided by Hoot, mock server-related helpers and
    classes can be found in the `"@web/../tests/web_test_helpers"` module.

.. _mock-server/configuration:

Configuration
=============

By default, a mock server is *"empty"*, meaning that it has no defined mock model.

This does not mean that it is useless though, as it will already handle a few pre-defined
routes, such as the ones responsible for fetching `menus` and `translations`, which
are spawned by :doc:`services <../services>` as soon as an `env` is spawned.

But this means that ORM methods will fail, as the model that they target has not
been defined yet.

To create and define a mock model, you need 2 things:

- a `class` extending the `models.Model` class;

    - special keys prefixed with a `_` act as metadata holders, like in Python
      (e.g. `_name`, `_order`, `_description`, etc.) [#]_ [#]_;

    - `_records` holds the list of objects representing fake record data;

    - `_views` can be a mapping of view types and XML arches;

    - other `public class fields <public-class-fields_>`_
      will be interpreted as fields (by calling the appropriate method from `fields`);

    - model-specific methods (such as `has_group` for `"res.users"`) can also be
      defined here.

- calling `defineModels` with the class defined above.

.. [#] Only a subset of these special keys will have an actual effect. For example,
    `_inherit` will not work as intended, prefer standard class extension.

.. [#] These can be altered by each test without thinking about cleaning up: any change
    performed on a special key will be reverted at the end of a test.

Here is a basic example of a simple, fake, `"res.partner"` model:

.. code-block:: javascript

    import { defineModels, fields, models } from "@web/../tests/web_test_helpers";

    class ResPartner extends models.Model {
        _name = "res.partner";

        name = fields.Char({ required: true );

        _records = [
            { name: "Mitchel Admin" },
        ];

        _views = {
            form: /* xml */`
                <form>
                    <field name="name" />
                </form>
            `,
            list: /* xml */`
                <list>
                    <field name="display_name" />
                </list>
            `,
        };
    }

    defineModels({ ResPartner });

This code will make these data available for *all* tests in the current test file.
Of course, defining a class and calling `defineModels` can also be done from *within*
a given test to limit the scope of that model to the current test.

Other methods such as `defineMenus`, `defineActions` or `defineParams` can also
be used to configure the current mock server. Most of their API is quite straightforward
(i.e. they receive JSON-like descriptions of menus, actions, etc.).

Mock models: requests
---------------------

Many test cases only require one or a few mock models to work. But sometimes,
it is either too bothersome to implement the mocking logic within a model, or a
*route* (i.e. server request URL) is simply not associated to a Python model at all.

In such cases, the `onRpc` method is to be called, to associate a route or an ORM
method to a callback.

.. note::
    Multiple `onRpc` calls can be associated to the same route / ORM method;
    in which case they will be called sequentially from last to first defined.
    Returning a *non-null-or-undefined* value will interrupt the current chain,
    and return that value as final result of the server request.

It can be used in 4 different ways:

`onRpc`: with a route (`"/"`)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the first argument is a `string` starting with a `"/"`, the callback
is expected to be a *route* callback, receiving a `Request_`
object:

.. code-block:: javascript

    onRpc("/route/to/test", async (request) => {
        const { ids }  = await request.json();
        expect.step(ids);
        return {};
    });

By default, the return value of these callbacks are wrapped within the `body`
of a mock `Response_` object.

This is fine for most use-cases, but sometimes the callback needs to respond with
a `Response_` object with custom `status` or `headers`.

In such cases, an *optional* dictionary can be passed as a 3rd argument to specify
whether the callback is to be considered *"pure"*, meaning that its return value
should be returned as-is to the server caller:

.. code-block:: javascript

    onRpc(
        "/not/found",
        () => new Response("{}", { status: 404 }),
        { pure: true }
    );

.. note::
    Using *"pure"* request callbacks can also be used to return anything else than
    a `Response_` object, in which case the returned value will still be wrapped
    in the body of a mock `Response_` to comply with the `fetch_` / `XMLHttpRequest_`
    APIs.

`onRpc`: with method name(s)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the first argument is a `string` *NOT* starting with a `"/"` or a list of `strings`,
the callback is expected to be an ORM callback, only called when the request's `method`
matches the one given as argument.

The callback will receive an object containing:

- the *spread* `params` value contained in the request body (typically: `args`,
  `kwargs`, `model` and `method`);

- a `parent()` function, which when invoked will call the defined ORM callback *preceding*
  this one;

- a `route` key, containing the `pathname` of the request (typically: `/web/dataset/call_kw`);

- the `request` object.

.. code-block:: javascript

    onRpc("web_read", async ({ args, parent }) => {
        const result = parent();
        expect.step(args[0]); // Contains the list of IDs
        result.some_meta_data = { foo: "bar" };
        return result;
    });

`onRpc`: with model name(s) AND method name(s)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When:

- the first argument is a `string` *NOT* starting with a `"/"` or a list of `strings`;

- the second argument is also a `string` or a list of `strings`;

Then the callback is expected to be an ORM callback, only called when the request's
`method` *AND* `model` match the ones given in the arguments.

This works just the same as the above shape, with an added `model` filter:

.. code-block:: javascript

    onRpc("web_read", "res.partner", ({ args }) => {
        expect.step(args[0]);
    });

`onRpc`: for *every* ORM method/model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When the *only* argument is a callback, it is expected to be an ORM callback to
be called for *every* ORM call:

.. code-block:: javascript

    onRpc(({ method }) => {
        expect.step(method); // Will step every ORM method call on every model
    });

Mock models: fields
-------------------

Model fields can be declared in 2 ways:

- as `public class fields <public-class-fields_>`_;

- under the `_fields` special key. For example:

    .. code-block:: javascript

        test("test view with date fields", async () => {
            // `_fields` can be assigned over, or extended directly.
            ResPartner._fields.date = fields.Date({ string: "Registration date" });
        });

Field constructors can take a parameters dictionary to dictate their behaviour.
It will be required for some of them, like relational fields, which need a `relation`
property to work correctly.

There are limits to what can be done with a mock field compared to an actual Python
server field, but expect the most basic properties to be supported:
`readonly`, `required`, `string`, etc.

`compute` and `related` do work for the most basic use-cases, but do not expect
them to function reliably as they would on the actual server.

.. note::
    There are 4 default fields pre-defined for each created model: `id`, `display_name`,
    `created_at` and `updated_at`. They match their server-side counterpart in their
    behaviour (e.g. `id` is incremental and `display_name` has a `compute` function
    similar to its server counterpart), and can be overridden if needed.

Mock models: records
--------------------

Model records are generated based on each object contained in the `_records`
special key *when the model is loaded*. They are validated based on the fields available
on the current models; if a property does not match a field defined on the model,
an error is thrown.

.. important::
    `_records` *cannot* be altered *after* the model has been loaded, i.e. after
    the mock server has started. This key is only used to generate initial records.
    If records should be added *after* model creation, do it either form the available
    components in the UI, or through direct ORM calls on the mock server instance.

Mock models: views
------------------

Since actual views need an `"ir.ui.view"` model to be declared, mock models
use a simplified *mapping* to provide view arches.

The `_view` special key is a dictionary, with its *keys* being view types, optionally
accompanied by a view ID, and its *values* being the XML arch string representation.

By default, view IDs are `false`, but can be specified explicitly with a comma-separated
key combining the view type and its ID:

.. code-block:: javascript

    // Will simulate a list view with no ID (false).
    ResPartner._views.list = /* xml */ `
        <list>
            <field name="display_name" />
        </list>
    `;

    // Will simulate a form view with ID 418.
    ResPartner._views["form,418"] = /* xml */ `
        <form>
            <field name="name" />
            <field name="date" />
        </form>
    `;

.. _mock-server/spawning:

Spawning a mock server
======================

Just like in most cases, only one server can be active for a given test.

As mentioned above, creating an `env` will automatically deploy a mock server.

This means that all of these methods will *also* create a mock server, since
they do create an `env`:

- :ref:`makeMockEnv <web-test-helpers/environment>`;

- :ref:`mountWithCleanup <web-test-helpers/components>` (calling :ref:`makeMockEnv <web-test-helpers/environment>`);

- :ref:`mountView <web-test-helpers/views>` (calling :ref:`mountWithCleanup <web-test-helpers/components>`).

However, some low-level features may require to spawn a mock server *without* an
environment. For that purpose, a `makeMockServer` helper can be called separately
to initiate a mock server.

.. note::
    `makeMockServer` should *only* be used by low-level features, such as testing
    the `rpc` function without the environment. It is not meant to be used as a
    means to retrieve the current mock server instance. For that purpose, refer to
    :ref:`MockServer.current <mock-server/interacting>`.

.. note::
    It is to be noted that subsequent calls to `makeMockServer` after a mock server
    has been started are simply ignored.

.. _mock-server/interacting:

Interacting with the server
===========================

While most of the server interactions are expected to be done directly or indirectly
by production code spawned in the test case, it is sometimes meaningful to bypass
the UI and call the mock server directly (e.g. to simulate that another user,
somewhere else, somehow, has altered the database).

This can be done by retrieving the `MockServer.current` static property containing
the current mock server instance (only after initialization):

.. code-block:: javascript

    // Most common ORM methods are provided out of the box by server models,
    // and are synchronous. Although, be careful that this will NOT trigger a
    // UI re-render, and will ONLY affect the (fake) database.
    const ids = MockServer.env["res.partner"].create([
        { name: "foo" },
        { name: "bar" },
    ]);

.. tip::
    `MockServer.env` is just a shortcut to `MockServer.current.env`.

.. _fetch: https://developer.mozilla.org/en-US/docs/Web/API/Window/fetch
.. _public-class-fields: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Public_class_fields
.. _Request: https://developer.mozilla.org/en-US/docs/Web/API/Request
.. _Response: https://developer.mozilla.org/en-US/docs/Web/API/Response
.. _XMLHttpRequest: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest


==================================================
SECTION: odoo_editor.rst
PATH: developer/reference/frontend/odoo_editor.rst
==================================================

===========
Odoo Editor
===========

Odoo Editor is Odoo's own rich text editor. Its sources can be found in the
`odoo-editor directory
<{GITHUB_PATH}/addons/web_editor/static/src/js/editor/odoo-editor>`_.

Powerbox
========

The Powerbox is a piece of user interface that contains
:ref:`commands <reference/frontend/odoo_editor/powerbox/command>` organized
into :ref:`categories <reference/frontend/odoo_editor/powerbox/category>`. It
appears when typing `/` in the editor. The commands can be filtered when the
user inputs text, and navigated with the arrow keys.

.. image:: odoo_editor/powerbox.png
   :align: center
   :alt: The Powerbox opened after typing "/".

Modifying the Powerbox
----------------------

Only one Powerbox should be instantiated at the time, and that job is done by
the editor itself. Its Powerbox instance can be found in its `powerbox` instance
variable.
To change the Powerbox's contents and options, change the options passed to the
editor before it gets instantiated.

.. important::
   Never instantiate the Powerbox yourself. Always use the current editor's own
   instance instead.

.. example::
    Say we want to add a new command `Document` to the Powerbox, just for the
    `mass_mailing` module. We want to add it to a new category called
    `Documentation` and we want it all the way at the top of the Powerbox.

    `mass_mailing` `extends
    <{GITHUB_PATH}/addons/mass_mailing/static/src/js/wysiwyg.js>`_
    `web_editor`'s `Wysiwyg class
    <{GITHUB_PATH}/addons/web_editor/static/src/js/wysiwyg/wysiwyg.js>`_, which
    instantiates the editor in its `start` method. Before doing so, it
    calls its own `_getPowerboxOptions` method, which can conveniently be
    overridden to add our new commands.

    Since `mass_mailing` already overrides `_getPowerboxOptions`, let's just add
    our new command to it:

    .. code-block:: javascript

      _getPowerboxOptions: function () {
          const options = this._super();
          // (existing code before the return statement)
          options.categories.push({
              name: _t('Documentation'),
              priority: 300,
          });
          options.commands.push({
              name: _t('Document'),
              category: _t('Documentation'),
              description: _t("Add this text to your mailing's documentation"),
              fontawesome: 'fa-book',
              priority: 1, // This is the only command in its category anyway.
          });
          return options;
      }

    .. important::
      In order to allow the names and descriptions of your commands and
      categories to be translated, make sure to wrap them in the `_t` function.

    .. tip::
      To avoid out-of-control escalations, don't use random numbers for your
      priorities: look at which other priorities already exist and choose your
      value accordingly (like you would do for a `z-index`).

Opening a custom Powerbox
-------------------------

It is possible to open the Powerbox with a custom set of categories and
commands, bypassing all pre-existing ones. To do that, call the `open` method of
the Powerbox and pass it your custom commands and categories.

.. image:: odoo_editor/powerbox-custom.png
   :align: center
   :alt: The Powerbox opened with custom categories and commands when pasting an
         image URL.

.. example::
    We need the current instance of the Powerbox, which can be found in the
    current editor. In the `Wysiwyg class
    <{GITHUB_PATH}/addons/web_editor/static/src/js/wysiwyg/wysiwyg.js>`_, you
    will find it as `this.odooEditor.powerbox`.

    Now to open it with our custom "Document" command in a custom
    "Documentation" category:

    .. code-block:: javascript

      this.odooEditor.powerbox.open(
          [{
              name: _t('Document'),
              category: _t('Documentation'),
              description: _t("Add this text to your mailing's documentation"),
              fontawesome: 'fa-book',
              priority: 1, // This is the only command in its category anyway.
          }],
          [{
              name: _t('Documentation'),
              priority: 300,
          }]
      );

Filtering commands
------------------

There are three ways to filter commands:

#. Via the `powerboxFilters`
   :ref:`Powerbox option <reference/frontend/odoo_editor/powerbox/options>`.
#. Via a given
   :ref:`command <reference/frontend/odoo_editor/powerbox/command>`'s
   `isDisabled` entry.
#. The user can filter commands by simply typing text after opening the
   Powerbox. It will fuzzy-match that text with the names of the categories and
   commands.

.. image:: odoo_editor/powerbox-filtered.png
   :align: center
   :alt: The Powerbox with its commands filtered using the word "head".

Reference
---------

.. _reference/frontend/odoo_editor/powerbox/category:

Category
~~~~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `name`
      - `string`
      - the name of the category
    * - `priority`
      - `number`
      - used to order the category: a category with a higher priority is
        displayed higher into the Powerbox (categories with the same priority
        are ordered alphabetically)

.. note::
    If several categories exist with the same name, they will be grouped into
    one. Its priority will be that defined in the version of the category that
    was declared last.

.. _reference/frontend/odoo_editor/powerbox/command:

Command
~~~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `name`
      - `string`
      - the name of the command
    * - `category`
      - `string`
      - the name of the category the command belongs to
    * - `description`
      - `string`
      - a short text to describe the command
    * - `fontawesome`
      - `string`
      - the name of a *Font Awesome* that will serve as the command's icon
    * - `priority`
      - `number`
      - used to order the command: a command with a higher priority is displayed
        higher into the Powerbox (commands with the same priority are ordered
        alphabetically)
    * - `callback`
      - `function` (`() => void`)
      - the function to execute when the command is picked (can be asynchronous)
    * - `isDisabled` (optional)
      - `function` (`() => void`)
      - a function used to disable the command under certain conditions (when it
        returns `true`, the command will be disabled)

.. note::
    If the command points to a category that doesn't exist yet, that category
    will be created and appended at the end of the Powerbox.

.. _reference/frontend/odoo_editor/powerbox/options:

Options
~~~~~~~

The following options can be passed to OdooEditor, that will then be passed to
the instance of the Powerbox:

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `commands`
      - `array of commands`
      - commands to add to the default defined by the editor
    * - `categories`
      - `array of categories`
      - categories to add to the default defined by the editor
    * - `powerboxFilters`
      - `array of functions` (`commands => commands`)
      - functions used to filter commands displayed in the Powerbox
    * - `getContextFromParentRect`
      - `function` (`() => DOMRect`)
      - a function that returns the `DOMRect` of an ancestor of the editor (can
        be useful when the editor is in an iframe)


==================================================
SECTION: owl_components.rst
PATH: developer/reference/frontend/owl_components.rst
==================================================

.. _frontend/components:

==============
Owl components
==============

The Odoo Javascript framework uses a custom component framework called Owl. It
is a declarative component system, loosely inspired by Vue and React. Components
are defined using :doc:`QWeb templates <qweb>`, enriched with some Owl
specific directives. The official
`Owl documentation <https://github.com/odoo/owl/blob/master/doc/readme.md>`_
contains a complete reference and a tutorial.

.. important::

   Although the code can be found in the `web` module, it is maintained from a
   separate GitHub repository. Any modification to Owl should therefore be made
   through a pull request on https://github.com/odoo/owl.

.. note::
   Currently, all Odoo versions (starting in version 14) share the same Owl version.

Using Owl components
====================

The `Owl documentation`_ already documents in detail the Owl framework, so this
page will only provide Odoo specific information. But first, let us see how we
can make a simple component in Odoo.

.. code-block:: javascript

    import { Component, xml, useState } from "@odoo/owl";

    class MyComponent extends Component {
        static template = xml`
            <div t-on-click="increment">
                <t t-esc="state.value">
            </div>
        `;

        setup() {
            this.state = useState({ value: 1 });
        }

        increment() {
            this.state.value++;
        }
    }

This example shows that Owl is available as a library in the global namespace as
`owl`: it can simply be used like most libraries in Odoo. Note that we
defined here the template as a static property, but without using the `static`
keyword, which is not available in some browsers (Odoo javascript code should
be Ecmascript 2019 compliant).

We define here the template in the javascript code, with the help of the `xml`
helper. However, it is only useful to get started. In practice, templates in
Odoo should be defined in an xml file, so they can be translated. In that case,
the component should only define the template name.

In practice, most components should define 2 or 3 files, located at the same
place: a javascript file (`my_component.js`), a template file (`my_component.xml`)
and optionally a scss (or css) file (`my_component.scss`). These files should
then be added to some assets bundle. The web framework will take care of
loading the javascript/css files, and loading the templates into Owl.

Here is how the component above should be defined:

.. code-block:: javascript

    import { Component, useState } from "@odoo/owl";

    class MyComponent extends Component {
        static template = 'myaddon.MyComponent';

        ...
    }

And the template is now located in the corresponding xml file:

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8" ?>
    <templates xml:space="preserve">

    <t t-name="myaddon.MyComponent">
      <div t-on-click="increment">
        <t t-esc="state.value"/>
      </div>
    </t>

    </templates>

.. note::

   Template names should follow the convention `addon_name.ComponentName`.


.. seealso::
    - `Owl Repository <https://github.com/odoo/owl>`_

.. _frontend/owl/best_practices:

Best practices
==============

First of all, components are classes, so they have a constructor. But constructors
are special methods in javascript that are not overridable in any way. Since this
is an occasionally useful pattern in Odoo, we need to make sure that no component
in Odoo directly uses the constructor method. Instead, components should use the
`setup` method:

.. code-block:: javascript

    // correct:
    class MyComponent extends Component {
        setup() {
            // initialize component here
        }
    }

    // incorrect. Do not do that!
    class IncorrectComponent extends Component {
        constructor(parent, props) {
            // initialize component here
        }
    }

Another good practice is to use a consistent convention for template names:
`addon_name.ComponentName`. This prevents name collision between odoo addons.

Reference List
==============

The Odoo web client is built with `Owl <https://github.com/odoo/owl>`_ components.
To make it easier, the Odoo javascript framework provides a suite of generic
components that can be reused in some common situations, such as dropdowns,
checkboxes or datepickers. This page explains how to use these generic components.

.. list-table::
   :widths: 30 70
   :header-rows: 1

   * - Technical Name
     - Short Description
   * - :ref:`ActionSwiper <frontend/owl/actionswiper>`
     - a swiper component to perform actions on touch swipe
   * - :ref:`CheckBox <frontend/owl/checkbox>`
     - a simple checkbox component with a label next to it
   * - :ref:`ColorList <frontend/owl/colorlist>`
     - a list of colors to choose from
   * - :ref:`Dropdown <frontend/owl/dropdown>`
     - full-featured dropdown
   * - :ref:`Notebook <frontend/owl/notebook>`
     - a component to navigate between pages using tabs
   * - :ref:`Pager <frontend/pager>`
     - a small component to handle pagination
   * - :ref:`SelectMenu <frontend/select_menu>`
     - a dropdown component to choose between different options
   * - :ref:`TagsList <frontend/tags_list>`
     - a list of tags displayed in rounded pills

.. _frontend/owl/actionswiper:

ActionSwiper
------------

Location
~~~~~~~~

`@web/core/action_swiper/action_swiper`

Description
~~~~~~~~~~~

This is a component that can perform actions when an element is swiped
horizontally. The swiper is wrapping a target element to add actions to it.
The action is executed once the user has released the swiper passed
a portion of its width.

.. code-block:: xml

  <ActionSwiper onLeftSwipe="Object" onRightSwipe="Object">
    <SomeElement/>
  </ActionSwiper>

The simplest way to use the component is to use it around your target element directly
in an xml template as shown above. But sometimes, you may want to extend an existing element
and would not want to duplicate the template. It is possible to do just that.

If you want to extend the behavior of an existing element, you must place the element
inside, by wrapping it directly. Also, you can conditionnally add props to manage when the
element might be swipable, its animation and the minimum portion to swipe to perform the action.

You can use the component to interact easily with records, messages, items in lists and much more.

.. image:: owl_components/actionswiper.png
  :width: 400 px
  :alt: Example of ActionSwiper usage
  :align: center

The following example creates a basic ActionSwiper component.
Here, the swipe is enabled in both directions.

.. code-block:: xml

  <ActionSwiper
    onRightSwipe="
      {
        action: '() => Delete item',
        icon: 'fa-delete',
        bgColor: 'bg-danger',
      }"
    onLeftSwipe="
      {
        action: '() => Star item',
        icon: 'fa-star',
        bgColor: 'bg-warning',
      }"
  >
    <div>
      Swipable item
    </div>
  </ActionSwiper>

.. note:: Actions are permuted when using right-to-left (RTL) languages.

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `animationOnMove`
      - `Boolean`
      - optional boolean to determine if a translate effect is present during the swipe
    * - `animationType`
      - `String`
      - optional animation that is used after the swipe ends (`bounce` or `forwards`)
    * - `onLeftSwipe`
      - `Object`
      - if present, the actionswiper can be swiped to the left
    * - `onRightSwipe`
      - `Object`
      - if present, the actionswiper can be swiped to the right
    * - `swipeDistanceRatio`
      - `Number`
      - optional minimum width ratio that must be swiped to perform the action

You can use both `onLeftSwipe` and `onRightSwipe` props at the same time.

The `Object`'s used for the left/right swipe must contain:

    - `action`, which is the callable `Function` serving as a callback.
      Once the swipe has been completed in the given direction, that action
      is performed.
    - `icon` is the icon class to use, usually to represent the action.
      It must be a `string`.
    - `bgColor` is the background color, given to decorate the action.
      can be one of the following `bootstrap contextual color
      <https://getbootstrap.com/docs/3.3/components/#available-variations>`_ (`danger`,
      `info`, `secondary`, `success` or `warning`).

    Those values must be given to define the behavior and the visual aspect
    of the swiper.

Example: Extending existing components
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the following example, you can use `xpath`'s to wrap an existing element
in the ActionSwiper component. Here, a swiper has been added to mark
a message as read in mail.

.. code-block:: xml

  <xpath expr="//*[hasclass('o_Message')]" position="after">
    <ActionSwiper
      onRightSwipe="messaging.device.isMobile and messageView.message.isNeedaction ?
        {
          action: () => messageView.message.markAsRead(),
          icon: 'fa-check-circle',
          bgColor: 'bg-success',
        } : undefined"
    />
  </xpath>
  <xpath expr="//ActionSwiper" position="inside">
    <xpath expr="//*[hasclass('o_Message')]" position="move"/>
  </xpath>

.. _frontend/owl/checkbox:

CheckBox
--------

Location
~~~~~~~~

`@web/core/checkbox/checkbox`

Description
~~~~~~~~~~~

This is a simple checkbox component with a label next to it. The checkbox is
linked to the label: the checkbox is toggled whenever the label is clicked.

.. code-block:: xml

  <CheckBox value="boolean" disabled="boolean" t-on-change="onValueChange">
    Some Text
  </CheckBox>

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `value`
      - `boolean`
      - if true, the checkbox is checked, otherwise it is unchecked
    * - `disabled`
      - `boolean`
      - if true, the checkbox is disabled, otherwise it is enabled

.. _frontend/owl/colorlist:

ColorList
---------

Location
~~~~~~~~

`@web/core/colorlist/colorlist`

Description
~~~~~~~~~~~

The ColorList let you choose a color from a predefined list. By default, the component displays the current
selected color, and is not expandable until the `canToggle` props is present. Different props can change its
behavior, to always expand the list, or make it act as a toggler once it is clicked, to display the list of
available colors until a choice is selected.

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `canToggle`
      - `boolean`
      - optional. Whether the colorlist can expand the list on click
    * - `colors`
      - `array`
      - list of colors to display in the component. Each color has a unique `id`
    * - `forceExpanded`
      - `boolean`
      - optional. If true, the list is always expanded
    * - `isExpanded`
      - `boolean`
      - optional. If true, the list is expanded by default
    * - `onColorSelected`
      - `function`
      - callback executed once a color is selected
    * - `selectedColor`
      - `number`
      - optional. The color `id` that is selected

Color `id`'s are the following:

.. list-table::
    :header-rows: 1

    * - Id
      - Color
    * - `0`
      - `No color`
    * - `1`
      - `Red`
    * - `2`
      - `Orange`
    * - `3`
      - `Yellow`
    * - `4`
      - `Light blue`
    * - `5`
      - `Dark purple`
    * - `6`
      - `Salmon pink`
    * - `7`
      - `Medium blue`
    * - `8`
      - `Dark blue`
    * - `9`
      - `Fuchsia`
    * - `12`
      - `Green`
    * - `11`
      - `Purple`

.. _frontend/owl/dropdown:

Dropdown
--------

Location
~~~~~~~~

`@web/core/dropdown/dropdown` and `@web/core/dropdown/dropdown_item`

Description
~~~~~~~~~~~

The Dropdown lets you show a menu with a list of items when a toggle is
clicked on. They can be combined with DropdownItems to invoke callbacks
and close the menu when items are selected.

Dropdowns are surprisingly complicated components, the list of features they
provide is as follow:

- Toggle the item list on click
- Close on outside click
- Call a function when items are selected
- Optionally close the item list when an item is selected
- SIY: style it yourself
- Support sub dropdowns, up to any level
- Configurable hotkey to open/close a dropdown or select a dropdown item
- Keyboard navigation (arrows, tab, shift+tab, home, end, enter and escape)
- Reposition itself whenever the page scrolls or is resized
- Smartly chose the direction it should open (right-to-left direction is automatically handled).
- Direct siblings dropdowns: when one is open, toggle others on hover

To properly use a `<Dropdown/>` component, you need to populate two
`OWL slots <https://github.com/odoo/owl/blob/master/doc/reference/slots.md>`_ :

- `default` slot: it contains the *toggle* elements of your dropdown. By default, click events will
  be attached to this element to open and close the dropdown.
- `content` slot: it contains the *elements* of the dropdown menu itself and is rendered inside a popover.
  Although it is not mandatory, you can put some `DropdownItem` inside this slot, the dropdown will
  automatically close when these items are selected.

.. code-block:: xml

  <Dropdown>
    <!-- The content of the "default" slot is the component's toggle -->
    <button class="my-btn" type="button">
      Click me to toggle the dropdown menu!
    </button>

    <!-- The "content" slot is rendered inside the menu that pops up next to the toggle -->
    <t t-set-slot="content">
      <DropdownItem onSelected="selectItem1">Menu Item 1</DropdownItem>
      <DropdownItem onSelected="selectItem2">Menu Item 2</DropdownItem>
    </t>
  </Dropdown>

Dropdown Props
~~~~~~~~~~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `menuClass`
      - `String`
      - Optional classname added to the dropdown's menu
    * - `disabled`
      - `Boolean`
      - Optional, if true, disables the dropdown so the user is not able to open it anymore. (default: `false`)
    * - `items`
      - `Array`
      - Optional list of items to be displayed as DropdownItems inside the dropdown's menu
    * - `position`
      - `String`
      - Optionally defines the desired menu opening position. RTL direction is automatically applied. Should be a valid :ref:`usePosition <frontend/hooks/useposition>` hook position. (default: `bottom-start`)
    * - `beforeOpen`
      - `Function`
      - Optional function called just before opening. May be asynchronous.
    * - `onOpened`
      - `Function`
      - Optional function called just after opening.
    * - `onStateChanged`
      - `Function`
      - Optional function called after opening or closing (gives a boolean as single argument that represents whether the dropdown is open or not).
    * - `state`
      - `Object`
      - Optional object with `open()`, `close()` and `isOpen` properties to manually control when the dropdown opens and closes.
    * - `manual`
      - `Boolean`
      - Optional, when true, the Dropdown component will not add click event listeners to the toggler. This allows for more control as when to open the dropdown. (This should be used in tandem with the `state` prop)
    * - `navigationOptions`
      - `Boolean`
      - Optionally overrides the navigation options of the dropdown, (see `web/core/navigation/navigation`).
    * - `holdOnHover`
      - `Boolean`
      - Optional, if true, keeps the Dropdown's menu at the same position while the mouse is hovering it, creating a better UX when the menu's content changes.
    * - `menuRef`
      - `Function`
      - Optional, allows to get a ref of the dropdown's menu, (expects a function returned from `useChildRef`)

DropdownItem Props
~~~~~~~~~~~~~~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `class`
      - `String` or `Object`
      - Optional value added to the root span classname (supports both strings and `OWL classname object notation <https://github.com/odoo/owl/blob/master/doc/reference/templates.md#dynamic-class-attribute>`_).
    * - `onSelected`
      - `Function`
      - Optional function called when the dropdown item is selected.
    * - `closingMode`
      - `"none"` | `"closest"` | `"all"`
      - Optional, controls which parent dropdown should close when the item is selected:
        `none`: the dropdown will not close, `closest`: the direct parent will close, `all`: every nested parent dropdown will close (default: `all`)
    * - `attrs`
      - `Object`
      - Optional object representing attributes that are added to the root element. `<DropdownItem attrs="{ title: 'A tooltip', 'data-hotkey': 'shift+a' }">`. (If `href` is set, the element will automatically become an `a` element).

.. important::
   When writing custom css for you components, do not forget that the menu elements are not next to the toggle
   but inside the overlay container, at the bottom of the document. Thus, use the `menuClass` and `class` props to more
   easily write your selectors. (This DOM magic let us avoid lots of z-index issues.)


Nested Dropdown
~~~~~~~~~~~~~~~

Dropdown can be nested, to do this simply put new Dropdown components inside other dropdown's content slot. When the parent
dropdown is open, child dropdowns will open automatically on hover.

By default, selecting a DropdownItem will close the whole Dropdown tree.

.. example::

   This example shows how one could make a nested File dropdown menu, with submenus for the New sub elements.

   .. code-block:: xml

    <Dropdown>
      <button>File</button>
      <t t-set-slot="content">
        <DropdownItem onSelected="() => this.onItemSelected('file-save')">Save</DropdownItem>
        <DropdownItem onSelected="() => this.onItemSelected('file-open')">Open</DropdownItem>

        <Dropdown>
          <button>New</button>
          <t t-set-slot="content">
            <DropdownItem onSelected="() => this.onItemSelected('file-new-document')">Document</DropdownItem>
            <DropdownItem onSelected="() => this.onItemSelected('file-new-spreadsheet')">Spreadsheet</DropdownItem>
          </t>
        </Dropdown>
      </t>
    </Dropdown>

   In the example bellow, we recursively call a template to display a tree-like structure.

   .. code-block:: xml

    <t t-name="addon.MainTemplate">
      <div>
        <t t-call="addon.RecursiveDropdown">
          <t t-set="name" t-value="'Main Menu'" />
          <t t-set="items" t-value="state.menuItems" />
        </t>
      </div>
    </t>

    <t t-name="addon.RecursiveDropdown">
      <Dropdown>
        <button t-esc="name"></button>
        <t t-set-slot="content">
          <t t-foreach="items" t-as="item" t-key="item.id">

            <!-- If this item has no child: make it a <DropdownItem/> -->
            <DropdownItem t-if="!item.childrenTree.length" onSelected="() => this.onItemSelected(item)" t-esc="item.name"/>

            <!-- Else: recursively call the current dropdown template. -->
            <t t-else="" t-call="addon.RecursiveDropdown">
              <t t-set="name" t-value="item.name" />
              <t t-set="items" t-value="item.childrenTree" />
            </t>
          </t>
        </t>
      </Dropdown>
    </t>

Controlled Dropdown
~~~~~~~~~~~~~~~~~~~

If needed, you can also open or close the dropdown using code. To do this you must use the `useDropdownState` hook along
with the `state` prop. `useDropdownState` returns an object that has an `open` and a `close` method (as well as an `isOpen` getter).
Give the object to the `state` prop of the dropdown you want to control and calling the respective functions should now open and
close your dropdown.

You can also set `manual` to `true` if you don't want the default click handlers to be added on the toggle.

.. example::

   The following example shows a dropdown that opens automatically when mounted and only has a 50% chance
   of closing when clicking on the button inside.

   .. code-block:: javascript

    import { Component, onMounted } from "@odoo/owl";
    import { Dropdown } from "@web/core/dropdown/dropdown";
    import { DropdownItem } from "@web/core/dropdown/dropdown_item";
    import { useDropdownState } from "@web/core/dropdown/dropdown_hooks";

    class MyComponent extends Component {

      static components = { Dropdown, DropdownItem };
      static template = xml`
        <Dropdown state="this.dropdown">
          <div>My Dropdown</div>

          <t t-set-slot="content">
            <button t-on-click="() => this.mightClose()">Close It!<button>
          </t>
        </Dropdown>
      `;

      setup() {
        this.dropdown = useDropdownState();

        onMounted(() => {
          this.dropdown.open();
        });
      }

      mightClose() {
        if (Math.random() > 0.5) {
          this.dropdown.close();
        }
      }
    }

DropdownGroup
~~~~~~~~~~~~~

**Location:** `@web/core/dropdown/dropdown_group`

You can use the DropdownGroup component to make Dropdowns share a common group, this means that when
one of these Dropdown is open, the others will automatically open themselves on mouse hover, without
the need for a click.

To do this, either surround all the Dropdowns with a single DropdownGroup or surround them with
DropdownGroups with the same `group` key.

.. example::
   In the example bellow, all dropdown in the snippet bellow will share the same group:

   .. code-block:: xml

    <DropdownGroup>
      <Dropdown>...</Dropdown>
      <Dropdown>...</Dropdown>
      <Dropdown>...</Dropdown>
    </DropdownGroup>

   Whereas in the following snippet, only the first, second and fourth dropdown share the same group:

   .. code-block:: xml

    <DropdownGroup group="'my-group'">
      <Dropdown>...</Dropdown>
      <Dropdown>...</Dropdown>
    </DropdownGroup>

    <DropdownGroup group="'my-other-group'">
      <Dropdown>...</Dropdown>
    </DropdownGroup>

    <DropdownGroup group="'my-group'">
      <Dropdown>...</Dropdown>
    </DropdownGroup>

.. _frontend/owl/notebook:

Notebook
--------

Location
~~~~~~~~

`@web/core/notebook/notebook`

Description
~~~~~~~~~~~

The Notebook is made to display multiple pages in a tabbed interface. Tabs can be located
at the top of the element to display horizontally, or at the left for a vertical layout.

There are two ways to define your Notebook pages to instanciate, either by using `slot`'s,
or by passing a dedicated `props`.

A page can be disabled with the `isDisabled` attribute, set directly on the slot node, or
in the page declaration, if the Notebook is used with the `pages` given as props. Once disabled,
the corresponding tab is greyed out and set as inactive as well.

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `anchors`
      - `object`
      - optional. Allow anchors navigation to elements inside tabs that are not visible.
    * - `className`
      - `string`
      - optional. Classname set on the root of the component.
    * - `defaultPage`
      - `string`
      - optional. Page `id` to display by default.
    * - `icons`
      - `array`
      - optional. List of icons used in the tabs.
    * - `orientation`
      - `string`
      - optional. Whether tabs direction is `horizontal` or `vertical`.
    * - `onPageUpdate`
      - `function`
      - optional. Callback executed once the page has changed.
    * - `pages`
      - `array`
      - optional. Contain the list of `page`'s to populate from a template.

.. example::

   The first approach is to set the pages in the slots of the component.

   .. code-block:: xml

    <Notebook orientation="'vertical'">
      <t t-set-slot="page_1" title="'Page 1'" isVisible="true">
        <h1>My First Page</h1>
        <p>It's time to build Owl components. Did you read the documentation?</p>
      </t>
      <t t-set-slot="page_2" title="'2nd page'" isVisible="true">
        <p>Wise owl's silent flight. Through the moonlit forest deep, guides my path to code</p>
      </t>
    </Notebook>

   The other way to define your pages is by passing the props. This can be useful if some pages share
   the same structure. Create first a component for each page template that you may use.

   .. code-block:: javascript

      import { Component, xml } from "@odoo/owl";
      import { Notebook } from "@web/core/notebook/notebook";

      class MyTemplateComponent extends Component {
        static template = xml`
          <h1 t-esc="props.title" />
          <p t-esc="props.text" />
        `;
      }

      class MyComponent extends Component {
        static template = xml`
          <Notebook defaultPage="'page_2'" pages="pages" />
        `;

        get pages() {
          return [
            {
              Component: MyTemplateComponent,
              title: "Page 1",
              props: {
                title: "My First Page",
                text: "This page is not visible",
              },
            },
            {
              Component: MyTemplateComponent,
              id: "page_2",
              title: "Page 2",
              props: {
                title: "My second page",
                text: "You're at the right place!",
              },
            },
          ]
        }
      }

  Both examples are shown here:

  .. image:: owl_components/notebook.png
     :width: 400 px
     :alt: Examples with vertical and horizontal layout
     :align: center


.. _frontend/pager:

Pager
-----

Location
~~~~~~~~

`@web/core/pager/pager`

Description
~~~~~~~~~~~

The Pager is a small component to handle pagination. A page is defined by an `offset` and a `limit` (the size of the page). It displays the current page and the `total` number of elements, for instance, "9-12 / 20". In the previous example, `offset` is 8, `limit` is 4 and `total` is 20. It has two buttons ("Previous" and "Next") to navigate between pages.

.. note::
    The pager can be used anywhere but its main use is in the control panel. See the :ref:`usePager <frontend/hooks/usepager>` hook in order to manipulate the pager of the control panel.

.. code-block:: xml

  <Pager offset="0" limit="80" total="50" onUpdate="doSomething" />

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `offset`
      - `number`
      - Index of the first element of the page. It starts with 0 but the pager displays `offset + 1`.
    * - `limit`
      - `number`
      - Size of the page. The sum of `offset` and `limit` corresponds to the index of the last element of the page.
    * - `total`
      - `number`
      - Total number of elements the page can reach.
    * - `onUpdate`
      - `function`
      - Function that is called when page is modified by the pager. This function can be async, the pager cannot be edited while this function is executing.
    * - `isEditable`
      - `boolean`
      - Allows to click on the current page to edit it (`true` by default).
    * - `withAccessKey`
      - `boolean`
      - Binds access key `p` on the previous page button and `n` on the next page one (`true` by default).

.. _frontend/select_menu:

SelectMenu
----------

Location
~~~~~~~~

`@web/core/select_menu/select_menu`

Description
~~~~~~~~~~~

This component can be used when you want to do more than using the native `select` element. You can define your own option template, allowing to search
between your options, or group them in subsections.

.. note::
    Prefer the native HTML `select` element, as it provides by default accessibility features, and has a better user interface on mobile devices.
    This component is designed to be used for more complex use cases, to overcome limitations of the native element.

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `choices`
      - `array`
      - optional. List of `choice`'s to display in the dropdown.
    * - `class`
      - `string`
      - optional. Classname set on the root of the SelectMenu component.
    * - `groups`
      - `array`
      - optional. List of `group`'s, containing `choices` to display in the dropdown.
    * - `multiSelect`
      - `boolean`
      - optional. Enable multiple selections. When multiple selection is enabled, selected values are displayed as :ref:`tag <frontend/tags_list>`'s in the SelectMenu input.
    * - `togglerClass`
      - `string`
      - optional. classname set on the toggler button.
    * - `required`
      - `boolean`
      - optional. Whether the selected value can be unselected.
    * - `searchable`
      - `boolean`
      - optional. Whether a search box is visible in the dropdown.
    * - `searchPlaceholder`
      - `string`
      - optional. Text displayed as the search box placeholder.
    * - `value`
      - `any`
      - optional. Current selected value. It can be from any kind of type.
    * - `onSelect`
      - `function`
      - optional. Callback executed when an option is chosen.

The shape of a `choice` is the following:

    - `value` is actual value of the choice. It is usually a technical string, but can be from `any` type.
    - `label` is the displayed text associated with the option. This one is usually a more friendly and translated `string`.

The shape of a `group` is the following:

    - `choices` is the list of `choice`'s to display for this group.
    - `label` is the displayed text associated with the group. This is a `string` displayed at the top of the group.

.. example::

   In the following example, the SelectMenu will display four choices. One of them is displayed on top of the options,
   since no groups are associated with it, but the other ones are separated by the label of their group.

   .. code-block:: javascript

      import { Component, xml } from "@odoo/owl";
      import { SelectMenu } from "@web/core/select_menu/select_menu";

      class MyComponent extends Component {
        static template = xml`
          <SelectMenu
            choices="choices"
            groups="groups"
            value="'value_2'"
          />
        `;

        get choices() {
          return [
              {
                value: "value_1",
                label: "First value"
              }
          ]
        }
        get groups() {
          return [
            {
                label: "Group A",
                choices: [
                    {
                      value: "value_2",
                      label: "Second value"
                    },
                    {
                      value: "value_3",
                      label: "Third value"
                    }
                ]
            },
            {
                label: "Group B",
                choices: [
                    {
                      value: "value_4",
                      label: "Fourth value"
                    }
                ]
            }
          ]
        }
      }

   You can also customize the appearance of the toggler and set a custom template for the choices, using the appropriate component `slot`'s.

   .. code-block:: xml

      <SelectMenu
        choices="choices"
        groups="groups"
        value="'value_2'"
      >
        Make a choice!
        <t t-set-slot="choice" t-slot-scope="choice">
          <span class="coolClass" t-esc="' ' + choice.data.label + ' '" />
        </t>
      </SelectMenu>

   .. image:: owl_components/select_menu.png
      :width: 400 px
      :alt: Example of SelectMenu usage and customization
      :align: center

   When SelectMenu is used with multiple selection, the `value` props must be an `Array` containing the values of the selected choices.

   .. image:: owl_components/select_menu_multiSelect.png
      :width: 350 px
      :alt: Example of SelectMenu used with multiple selection
      :align: center

   For more advanced use cases, you can customize the bottom area of the dropdown, using the `bottomArea` slot. Here, we choose to display
   a button with the corresponding value set in the search input.

   .. code-block:: xml

      <SelectMenu
          choices="choices"
      >
          <span class="select_menu_test">Select something</span>
          <t t-set-slot="bottomArea" t-slot-scope="select">
              <div t-if="select.data.searchValue">
                  <button class="btn text-primary" t-on-click="() => this.onCreate(select.data.searchValue)">
                      Create this article "<i t-esc="select.data.searchValue" />"
                  </button>
              </div>
          </t>
      </SelectMenu>

   .. image:: owl_components/select_menu_bottomArea.png
      :width: 400 px
      :alt: Example of SelectMenu's bottom area customization
      :align: center

.. _frontend/tags_list:

TagsList
--------

Location
~~~~~~~~

`@web/core/tags_list/tags_list`

Description
~~~~~~~~~~~

This component can display a list of tags in rounded pills. Those tags can either simply list a few values, or can be editable, allowing the removal of items.
It can be possible to limit the number of displayed items using the `itemsVisible` props. If the list is longer than this limit, the number of additional items is
shown in a circle next to the last tag.

Props
~~~~~

.. list-table::
    :widths: 20 20 60
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `displayBadge`
      - `boolean`
      - optional. Whether the tag is displayed as a badge.
    * - `displayText`
      - `boolean`
      - optional. Whether the tag is displayed with a text or not.
    * - `itemsVisible`
      - `number`
      - optional. Limit of visible tags in the list.
    * - `tags`
      - `array`
      - list of `tag`'s elements given to the component.

The shape of a `tag` is the following:

    - `colorIndex` is an optional color id.
    - `icon` is an optional icon displayed just before the displayed text.
    - `id` is a unique identifier for the tag.
    - `img` is an optional image displayed in a circle, just before the displayed text.
    - `onClick` is an optional callback that can be given to the element. This allows the parent element to handle any functionality depending on the tag clicked.
    - `onDelete` is an optional callback that can be given to the element. This makes the removal of the item from the list of tags possible, and must be handled by the parent element.
    - `text` is the displayed `string` associated with the tag.

.. example::

   In the next example, a TagsList component is used to display multiple tags.
   It's at the developer to handle from the parent what would happen when the tag is pressed, or when the delete button is clicked.

   .. code-block:: javascript

      import { Component, xml } from "@odoo/owl";
      import { TagsList } from "@web/core/tags_list/tags_list";

      class Parent extends Component {
        static template = xml`<TagsList tags="tags" />`;
        static components = { TagsList };

        setup() {
          this.tags = [{
              id: "tag1",
              text: "Earth"
          }, {
              colorIndex: 1,
              id: "tag2",
              text: "Wind",
              onDelete: () => {...}
          }, {
              colorIndex: 2,
              id: "tag3",
              text: "Fire",
              onClick: () => {...},
              onDelete: () => {...}
          }];
        }
      }

   Depending the attributes given to each tag, their appearance and behavior will differ.

   .. image:: owl_components/tags_list.png
      :width: 350 px
      :alt: Examples of TagsList using different props and attributes
      :align: center


==================================================
SECTION: patching_code.rst
PATH: developer/reference/frontend/patching_code.rst
==================================================

=============
Patching code
=============

Sometimes, we need to customize the way the UI works.  Many common needs are
covered by some supported API. For example, all registries are good extension
points: the field registry allows adding/removing specialized field components,
or the main component registry allows adding components that should be displayed
all the time.

However, there are situations for which it is not sufficient. In those cases, we
may need to modify an object or a class in place. To achieve that, Odoo
provides the utility function `patch`. It is mostly useful to override/update
the behavior of some other component/piece of code that one does not control.

Description
===========

The patch function is located in `@web/core/utils/patch`:

.. js:function:: patch(objToPatch, extension)

    :param object objToPatch: the object that should be patched
    :param object extension: an object mapping each key to an extension
    :returns: a function to remove the patch

    The `patch` function modifies in place the `objToPatch` object (or class) and
    applies all key/value described in the `extension` object.  An unpatch
    function is returned, so it can be used to remove the patch later if necessary.

    Most patch operations provide access to the parent value by using the
    native `super` keyword (see below in the examples).

Patching a simple object
========================

Here is a simple example of how an object can be patched:

.. code-block:: javascript

  import { patch } from "@web/core/utils/patch";

  const object = {
    field: "a field",
    fn() {
      // do something
    },
  };

  patch(object, {
    fn() {
      // do things
    },
  });


When patching functions, we usually want to be able to access the ``parent``
function.  To do so, we can simply use the native ``super`` keyword:

.. code-block:: javascript

  patch(object, {
    fn() {
      super.fn(...arguments);
      // do other things
    },
  });

.. warning::

    ``super`` can only be used in a method not a function. This means that the
    following constructs are invalid for javascript.

    .. code-block:: javascript

      const obj = {
        a: function () {
          // Throws: "Uncaught SyntaxError: 'super' keyword unexpected here"
          super.a();
        },
        b: () => {
          // Throws: "Uncaught SyntaxError: 'super' keyword unexpected here"
          super.b();
        },
      };

Getters and setters are supported too:

.. code-block:: javascript

    patch(object, {
      get number() {
        return super.number / 2;
      },
      set number(value) {
        super.number = value;
      },
    });

.. _frontend/patching_class:

Patching a javascript class
===========================

The ``patch`` function is designed to work with anything: object or ES6 class.

However, since javascript classes work with the prototypal inheritance, when
one wishes to patch a standard method from a class, then we actually need to patch
the `prototype`:

.. code-block:: javascript

  class MyClass {
    static myStaticFn() {...}
    myPrototypeFn() {...}
  }

  // this will patch static properties!!!
  patch(MyClass, {
    myStaticFn() {...},
  });

  // this is probably the usual case: patching a class method
  patch(MyClass.prototype, {
    myPrototypeFn() {...},
  });


Also, Javascript handles the constructor in a special native way which makes it
impossible to be patched. The only workaround is to call a method in the original
constructor and patch that method instead:

.. code-block:: javascript

  class MyClass {
    constructor() {
      this.setup();
    }
    setup() {
      this.number = 1;
    }
  }

  patch(MyClass.prototype, {
    setup() {
      super.setup(...arguments);
      this.doubleNumber = this.number * 2;
    },
  });

.. warning::

    It is impossible to patch directly the `constructor` of a class!

Patching a component
====================

Components are defined by javascript classes, so all the information above still
holds.  For these reasons, Owl components should use the `setup` method, so they
can easily be patched as well (see the section on :ref:`best practices<frontend/owl/best_practices>`).

.. code-block:: javascript

  patch(MyComponent.prototype, {
    setup() {
      useMyHook();
    },
  });

Removing a patch
================

The `patch` function returns its counterpart. This is mostly useful for
testing purposes, when we patch something at the beginning of a test, and
unpatch it at the end.

.. code-block:: javascript

    const unpatch = patch(object, { ... });
    // test stuff here
    unpatch();

Applying the same patch to multiple objects
===========================================

It could happen that one wants to apply the same patch to multiple objects but
because of the way the `super` keyword works, the `extension` can only be used
for patching once and cannot be copied/cloned (`check the documentation of the keyword <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/super#description>`_).
A function returning the object used to patch can be used to make it unique.

.. code-block:: javascript

    const obj1 = {
      method() {
        doSomething();
      },
    };

    const obj2 = {
      method() {
        doThings();
      },
    };

    function createExtensionObj() {
      return {
        method() {
          super.method();
          doCommonThings();
        },
      };
    }

    patch(obj1, createExtensionObj());
    patch(obj2, createExtensionObj());

.. warning::

  If an `extension` is based on another then the two extensions should
  be applied separately. Do not copy/clone an extension.

  .. code-block:: javascript

      const object = {
        method1() {
          doSomething();
        },
        method2() {
          doAnotherThing();
        },
      };

      const ext1 = {
        method1() {
          super.method1();
          doThings();
        },
      };

      const invalid_ext2 = {
        ...ext1, // this will not work: super will not refer to the correct object in methods coming from ext1
        method2() {
          super.method2();
          doOtherThings();
        },
      };

      patch(object, invalid_ext2);
      object.method1(); // throws: Uncaught TypeError: (intermediate value).method1 is not a function

      const valid_ext2 = {
        method2() {
          super.method2();
          doOtherThings();
        },
      };

      patch(object, ext1); // first patch base extension
      patch(object, valid_ext2); // then the new one
      object.method1(); // works as expected


==================================================
SECTION: qweb.rst
PATH: developer/reference/frontend/qweb.rst
==================================================

.. highlight:: xml

.. _reference/qweb:

==============
QWeb Templates
==============

QWeb is the primary templating_ engine used by Odoo\ [#othertemplates]_. It
is an XML templating engine\ [#genshif]_ and used mostly to generate HTML_
fragments and pages.

Template directives are specified as XML attributes prefixed with ``t-``,
for instance ``t-if`` for :ref:`reference/qweb/conditionals`, with elements
and other attributes being rendered directly.

To avoid element rendering, a placeholder element ``<t>`` is also available,
which executes its directive but doesn't generate any output in and of
itself::

    <t t-if="condition">
        <p>Test</p>
    </t>

will result in::

    <p>Test</p>

if ``condition`` is true, but::

    <div t-if="condition">
        <p>Test</p>
    </div>

will result in::

    <div>
        <p>Test</p>
    </div>

.. _reference/qweb/output:

Data output
===========

QWeb's output directive ``out`` will automatically HTML-escape its input,
limiting XSS_ risks when displaying user-provided content.

``out`` takes an expression, evaluates it and injects the result in the document::

    <p><t t-out="value"/></p>

rendered with the value ``value`` set to ``42`` yields::

    <p>42</p>

See :ref:`reference/qweb/advanced-output` for more advanced topics (e.g.
injecting raw HTML, etc...).

.. _reference/qweb/conditionals:

Conditionals
============

QWeb has a conditional directive ``if``, which evaluates an expression given
as attribute value::

    <div>
        <t t-if="condition">
            <p>ok</p>
        </t>
    </div>

The element is rendered if the condition is true::

    <div>
        <p>ok</p>
    </div>

but if the condition is false it is removed from the result::

    <div>
    </div>

The conditional rendering applies to the bearer of the directive, which does
not have to be ``<t>``::

    <div>
        <p t-if="condition">ok</p>
    </div>

will give the same results as the previous example.

Extra conditional branching directives ``t-elif`` and ``t-else`` are also
available::

    <div>
        <p t-if="user.birthday == today()">Happy birthday!</p>
        <p t-elif="user.login == 'root'">Welcome master!</p>
        <p t-else="">Welcome!</p>
    </div>


.. _reference/qweb/loops:

Loops
=====

QWeb has an iteration directive ``foreach`` which take an expression returning
the collection to iterate on, and a second parameter ``t-as`` providing the
name to use for the "current item" of the iteration::

    <t t-foreach="[1, 2, 3]" t-as="i">
        <p><t t-out="i"/></p>
    </t>

will be rendered as::

    <p>1</p>
    <p>2</p>
    <p>3</p>

Like conditions, ``foreach`` applies to the element bearing the directive's
attribute, and

::

    <p t-foreach="[1, 2, 3]" t-as="i">
        <t t-out="i"/>
    </p>

is equivalent to the previous example.

``foreach`` can iterate on an array (the current item will be the current
value) or a mapping (the current item will be the current key). Iterating on an
integer (equivalent to iterating on an array between 0 inclusive and the
provided integer exclusive) is still supported but deprecated.

In addition to the name passed via ``t-as``, ``foreach`` provides a few other
variables for various data points:

.. warning:: ``$as`` will be replaced by the name passed to ``t-as``

.. rst-class:: o-definition-list

:samp:`{$as}_all` (deprecated)
    the object being iterated over

    .. note:: This variable is only available on JavaScript QWeb, not Python.

:samp:`{$as}_value`
    the current iteration value, identical to ``$as`` for lists and integers,
    but for mappings it provides the value (where ``$as`` provides the key)
:samp:`{$as}_index`
    the current iteration index (the first item of the iteration has index 0)
:samp:`{$as}_size`
    the size of the collection if it is available
:samp:`{$as}_first`
    whether the current item is the first of the iteration (equivalent to
    :samp:`{$as}_index == 0`)
:samp:`{$as}_last`
    whether the current item is the last of the iteration (equivalent to
    :samp:`{$as}_index + 1 == {$as}_size`), requires the iteratee's size be
    available
:samp:`{$as}_parity` (deprecated)
    either ``"even"`` or ``"odd"``, the parity of the current iteration round
:samp:`{$as}_even` (deprecated)
    a boolean flag indicating that the current iteration round is on an even
    index
:samp:`{$as}_odd` (deprecated)
    a boolean flag indicating that the current iteration round is on an odd
    index

These extra variables provided and all new variables created into the
``foreach`` are only available in the scope of the ``foreach``. If the
variable exists outside the context of the ``foreach``, the value is copied
at the end of the foreach into the global context.

::

    <t t-set="existing_variable" t-value="False"/>
    <!-- existing_variable now False -->

    <p t-foreach="[1, 2, 3]" t-as="i">
        <t t-set="existing_variable" t-value="True"/>
        <t t-set="new_variable" t-value="True"/>
        <!-- existing_variable and new_variable now True -->
    </p>

    <!-- existing_variable always True -->
    <!-- new_variable undefined -->

.. _reference/qweb/attributes:

attributes
==========

QWeb can compute attributes on-the-fly and set the result of the computation
on the output node. This is done via the ``t-att`` (attribute) directive which
exists in 3 different forms:

.. rst-class:: o-definition-list

:samp:`t-att-{$name}`
    an attribute called ``$name`` is created, the attribute value is evaluated
    and the result is set as the attribute's value::

        <div t-att-a="42"/>

    will be rendered as::

        <div a="42"></div>
:samp:`t-attf-{$name}`
    same as previous, but the parameter is a :term:`format string`
    instead of just an expression, often useful to mix literal and non-literal
    string (e.g. classes)::

        <t t-foreach="[1, 2, 3]" t-as="item">
            <li t-attf-class="row {{ (item_index % 2 === 0) ? 'even' : 'odd' }}">
                <t t-out="item"/>
            </li>
        </t>

    will be rendered as::

        <li class="row even">1</li>
        <li class="row odd">2</li>
        <li class="row even">3</li>

    .. tip::
       There are two equivalent syntaxes for format strings: ``"plain_text {{code}}"`` (aka
       jinja-style) and ``"plain_text #{code}"`` (aka ruby-style).

:samp:`t-att=mapping`
    if the parameter is a mapping, each (key, value) pair generates a new
    attribute and its value::

        <div t-att="{'a': 1, 'b': 2}"/>

    will be rendered as::

        <div a="1" b="2"></div>
:samp:`t-att=pair`
    if the parameter is a pair (tuple or array of 2 element), the first
    item of the pair is the name of the attribute and the second item is the
    value::

        <div t-att="['a', 'b']"/>

    will be rendered as::

        <div a="b"></div>

.. _reference/qweb/set:

setting variables
=================

QWeb allows creating variables from within the template, to memoize a computation (to use it
multiple times), give a piece of data a clearer name, ...

This is done via the ``set`` directive, which takes the name of the variable
to create. The value to set can be provided in two ways:

* a ``t-value`` attribute containing an expression, and the result of its
  evaluation will be set::

    <t t-set="foo" t-value="2 + 1"/>
    <t t-out="foo"/>

  will print ``3``
* if there is no ``t-value`` attribute, the node's body is rendered and set
  as the variable's value::

    <t t-set="foo">
        <li>ok</li>
    </t>
    <t t-out="foo"/>

.. _reference/qweb/call:

.. _reference/qweb/sub-templates:

calling sub-templates
=====================

QWeb templates can be used for top-level rendering, but they can also be used
from within another template (to avoid duplication or give names to parts of
templates) using the ``t-call`` directive::

    <t t-call="other-template"/>

This calls the named template with the execution context of the parent, if
``other_template`` is defined as::

    <p><t t-value="var"/></p>

the call above will be rendered as ``<p/>`` (no content), but::

    <t t-set="var" t-value="1"/>
    <t t-call="other-template"/>

will be rendered as ``<p>1</p>``.

However, this has the problem of being visible from outside the ``t-call``.
Alternatively, content set in the body of the ``call`` directive will be
evaluated *before* calling the sub-template, and can alter a local context::

    <t t-call="other-template">
        <t t-set="var" t-value="1"/>
    </t>
    <!-- "var" does not exist here -->

The body of the ``call`` directive can be arbitrarily complex (not just
``set`` directives), and its rendered form will be available within the called
template as a magical ``0`` variable::

    <div>
        This template was called with content:
        <t t-out="0"/>
    </div>

being called thus::

    <t t-call="other-template">
        <em>content</em>
    </t>

will result in::

    <div>
        This template was called with content:
        <em>content</em>
    </div>

.. _reference/qweb/advanced-output:

Advanced Output
===============

By default, ``out`` should HTML-escape content which needs to be escaped,
protecting the system against XSS_

Content which does *not* need to be escaped will instead be injected as-is in
the document, and may become part of the document's actual markup.

The only cross-platform "safe" content is the output of
:ref:`t-call <reference/qweb/call>` or a :ref:`t-set <reference/qweb/set>`
used with a "body" (as opposed to ``t-value`` or ``t-valuef``).

Python
------

Usually you should not have to care too much: APIs for which it makes sense
should generate "safe" content automatically, and things should work
transparently.

For the cases where things need to be clearer though the following APIs output
safe content which will by default not be (re-)escaped when injected into
templates:

* :class:`HTML fields <odoo.fields.Html>`.
* :func:`~odoo.tools.misc.html_escape` and :func:`markupsafe.escape` (they are
  aliases, and have no risk of double-escaping).
* :func:`~odoo.tools.mail.html_sanitize`.
* :class:`markupsafe.Markup`.

  .. warning:: :class:`markupsafe.Markup` is an unsafe API, it's an *assertion*
               that you want the content to be markup-safe but necessarily can
               not check that, it should be used with care.
* :func:`~odoo.tools.pycompat.to_text` does not mark the content as safe, but
  will not strip that information from safe content.

forcing double-escaping
-----------------------

If content is marked as safe but for some reason needs to be escaped anyway
(e.g. printing the markup of an HTML fields), it can just be converted back
to a normal string to "strip" the safety flag e.g. `str(content)` in Python and
`String(content)` in Javascript.

.. note::

    Because :class:`~markupsafe.Markup` is a much richer type than
    :js:class:`Markup`, some operations will strip the safety information from
    a :js:class:`Markup` but not a :class:`~markupsafe.Markup` e.g. string
    concatenation (``'' + content``) in Python will result in a
    :class:`~markupsafe.Markup` with the other operand having been properly
    escaped, while in Javascript will yield a :js:class:`String` where the
    other operand was *not* escaped before the concatenation.

Deprecated output directives
----------------------------

.. rst-class:: o-definition-list

``esc``
    An alias for ``out``, would originally HTML-escape its input. Not yet
    formally deprecated as the only difference between ``out`` and ``esc`` is
    that the latter is a bit unclear / incorrect.
``raw``
    A version of ``out`` which *never* escapes its content. Content is emitted
    as-is, whether it's safe or not.

    .. deprecated:: 15.0

        Use ``out`` with a :class:`markupsafe.Markup` value instead.

        ``t-raw`` was deprecated because as the code *producting* the content
        evolves it can be hard to track that it's going to be used for markup,
        leading to more complicated reviews and more dangerous lapses.

Python
======

Exclusive directives
--------------------

Asset bundles
~~~~~~~~~~~~~

.. todo:: have fme write these up because I've no idea how they work

"smart records" fields formatting
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The ``t-field`` directive can only be used when performing field access
(``a.b``) on a "smart" record (result of the ``browse`` method). It is able
to automatically format based on field type, and is integrated in the
website's rich text editing.

``t-options`` can be used to customize fields, the most common option
is ``widget``, other options are field- or widget-dependent.

Debugging
---------

.. rst-class:: o-definition-list

``t-debug``
    with an empty value, invokes the :func:`breakpoint` builtin
    function, which usually invokes a debugger (:mod:`pdb` by
    default).

    The behaviour can be configured via :envvar:`PYTHONBREAKPOINT` or
    :func:`sys.breakpointhook`.

Helpers
-------

Request-based
~~~~~~~~~~~~~

Most Python-side uses of QWeb are in controllers (and during HTTP requests),
in which case templates stored in the database (as
:ref:`views <reference/view_architectures/qweb>`) can be trivially rendered by calling
:meth:`odoo.http.HttpRequest.render`:

.. code-block:: python

    response = http.request.render('my-template', {
        'context_value': 42
    })

This automatically creates a :class:`~odoo.http.Response` object which can
be returned from the controller (or further customized to suit).

View-based
~~~~~~~~~~

At a deeper level than the previous helper is the ``_render`` method on
``ir.qweb`` (use the datable) and the public module method ``render``
(don't use the database):

.. py:method:: _render(id[, values])

    Renders a QWeb view/template by database id or :term:`external id`.
    Templates are automatically loaded from ``ir.qweb`` records.

    ``_prepare_environment`` method sets up a number of default values in
    the rendering context. The ``http_routing`` and ``website`` addons,
    also default values they need.
    You can use ``minimal_qcontext=False`` option to avoid this default
    value like the public method ``render``:

    .. rst-class:: o-definition-list

    ``request``
        the current :class:`~odoo.http.Request` object, if any
    ``debug``
        whether the current request (if any) is in ``debug`` mode
    :func:`quote_plus <werkzeug.urls.url_quote_plus>`
        url-encoding utility function
    :mod:`json`
        the corresponding standard library module
    :mod:`time`
        the corresponding standard library module
    :mod:`datetime`
        the corresponding standard library module
    `relativedelta <https://labix.org/python-dateutil#head-ba5ffd4df8111d1b83fc194b97ebecf837add454>`_
        see module
    ``keep_query``
        the ``keep_query`` helper function

    :param values: context values to pass to QWeb for rendering
    :param str engine: name of the Odoo model to use for rendering, can be
                       used to expand or customize QWeb locally (by creating
                       a "new" qweb based on ``ir.qweb`` with alterations)

.. py:method:: render(template_name, values, load, **options)

    :func:`load(ref)`
        returns etree object, ref

.. _reference/qweb/javascript:

.. todo:: the members below are no longer relevant, section to rewrite

.. API
.. ---

.. It is also possible to use the ``ir.qweb`` model directly (and extend it, and
.. inherit from it):

.. .. automodule:: odoo.addons.base.ir.ir_qweb
..     :members: QWeb, QWebContext, FieldConverter, QwebWidget

Javascript
==========

Exclusive directives
--------------------

Defining templates
~~~~~~~~~~~~~~~~~~

The ``t-name`` directive can only be placed at the top-level of a template
file (direct children to the document root)::

    <templates>
        <t t-name="template-name">
            <!-- template code -->
        </t>
    </templates>

It takes no other parameter, but can be used with a ``<t>`` element or any
other. With a ``<t>`` element, the ``<t>`` should have a single child.

The template name is an arbitrary string, although when multiple templates
are related (e.g. called sub-templates) it is customary to use dot-separated
names to indicate hierarchical relationships.

.. _reference/qweb/template_inheritance:

Template inheritance
~~~~~~~~~~~~~~~~~~~~

Template inheritance is used to either:
 - Alter existing templates in-place, e.g. to add information to templates
created by other modules.
 - Create a new template from a given parent template

Template inheritance is performed via the use of two directives:
 - ``t-inherit`` which is the name of the template to inherit from,
 - ``t-inherit-mode`` which is the behaviour of the inheritance: it can either be
   set to ``primary`` to create a new child template from the parented one or
   to ``extension`` to alter the parent template in place.

An optional ``t-name`` directive can also be specified. It will be the name of
the newly created template if used in primary mode, else it will be added as a
comment on the transformed template to help retrace inheritances.

For the inheritance itself, the changes are done using xpaths directives.
See the XPATH_ documentation for the complete set of available instructions.

Primary inheritance (child template)::

    <t t-name="child.template" t-inherit="base.template" t-inherit-mode="primary">
        <xpath expr="//ul" position="inside">
            <li>new element</li>
        </xpath>
    </t>

Extension inheritance (in-place transformation)::

    <t t-inherit="base.template" t-inherit-mode="extension">
        <xpath expr="//tr[1]" position="after">
            <tr><td>new cell</td></tr>
        </xpath>
    </t>

Old inheritance mechanism (deprecated)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Template inheritance is performed via the ``t-extend`` directive which takes
the name of the template to alter as parameter.

The directive ``t-extend`` will act as a primary inheritance when combined with
``t-name`` and as an extension one when used alone.

In both cases the alteration is then performed with any number of ``t-jquery``
sub-directives::

    <t t-extend="base.template">
        <t t-jquery="ul" t-operation="append">
            <li>new element</li>
        </t>
    </t>

The ``t-jquery`` directives takes a `CSS selector`_. This selector is used
on the extended template to select *context nodes* to which the specified
``t-operation`` is applied:

.. rst-class:: o-definition-list

``append``
    the node's body is appended at the end of the context node (after the
    context node's last child)
``prepend``
    the node's body is prepended to the context node (inserted before the
    context node's first child)
``before``
    the node's body is inserted right before the context node
``after``
    the node's body is inserted right after the context node
``inner``
    the node's body replaces the context node's children
``replace``
    the node's body is used to replace the context node itself
``attributes``
    the nodes's body should be any number of ``attribute`` elements,
    each with a ``name`` attribute and some textual content, the named
    attribute of the context node will be set to the specified value
    (either replaced if it already existed or added if not)
No operation
    if no ``t-operation`` is specified, the template body is interpreted as
    javascript code and executed with the context node as ``this``

    .. warning:: while much more powerful than other operations, this mode is
                 also much harder to debug and maintain, it is recommended to
                 avoid it

debugging
---------

The javascript QWeb implementation provides a few debugging hooks:

.. rst-class:: o-definition-list

``t-log``
    takes an expression parameter, evaluates the expression during rendering
    and logs its result with ``console.log``::

        <t t-set="foo" t-value="42"/>
        <t t-log="foo"/>

    will print ``42`` to the console
``t-debug``
    triggers a debugger breakpoint during template rendering::

        <t t-if="a_test">
            <t t-debug=""/>
        </t>

    will stop execution if debugging is active (exact condition depend on the
    browser and its development tools)
``t-js``
    the node's body is javascript code executed during template rendering.
    Takes a ``context`` parameter, which is the name under which the rendering
    context will be available in the ``t-js``'s body::

        <t t-set="foo" t-value="42"/>
        <t t-js="ctx">
            console.log("Foo is", ctx.foo);
        </t>

Helpers
-------

.. js:attribute:: core.qweb

    (core is the ``web.core`` module) An instance of :js:class:`QWeb2.Engine` with all module-defined template
    files loaded, and references to standard helper objects ``_``
    (underscore), ``_t`` (translation function) and JSON_.

    :js:func:`core.qweb.render <QWeb2.Engine.render>` can be used to
    easily render basic module templates

.. _reference/qweb/api:

API
---

.. js:class:: QWeb2.Engine

    The QWeb "renderer", handles most of QWeb's logic (loading,
    parsing, compiling and rendering templates).

    Odoo Web instantiates one for the user in the core module, and
    exports it to ``core.qweb``. It also loads all the template files
    of the various modules into that QWeb instance.

    A :js:class:`QWeb2.Engine` also serves as a "template namespace".

    .. js:function:: QWeb2.Engine.render(template[, context])

        Renders a previously loaded template to a String, using
        ``context`` (if provided) to find the variables accessed
        during template rendering (e.g. strings to display).

        :param String template: the name of the template to render
        :param Object context: the basic namespace to use for template
                               rendering
        :returns: String

    The engine exposes an other method which may be useful in some
    cases (e.g. if you need a separate template namespace with, in
    Odoo Web, Kanban views get their own :js:class:`QWeb2.Engine`
    instance so their templates don't collide with more general
    "module" templates):

    .. js:function:: QWeb2.Engine.add_template(templates)

        Loads a template file (a collection of templates) in the QWeb
        instance. The templates can be specified as:

        An XML string
            QWeb will attempt to parse it to an XML document then load
            it.

        A URL
            QWeb will attempt to download the URL content, then load
            the resulting XML string.

        A ``Document`` or ``Node``
            QWeb will traverse the first level of the document (the
            child nodes of the provided root) and load any named
            template or template override.

        :type templates: String | Document | Node

    A :js:class:`QWeb2.Engine` also exposes various attributes for
    behavior customization:

    .. js:attribute:: QWeb2.Engine.prefix

        Prefix used to recognize directives during parsing. A string. By
        default, ``t``.

    .. js:attribute:: QWeb2.Engine.debug

        Boolean flag putting the engine in "debug mode". Normally,
        QWeb intercepts any error raised during template execution. In
        debug mode, it leaves all exceptions go through without
        intercepting them.

    .. js:attribute:: QWeb2.Engine.jQuery

        The jQuery instance used during template inheritance processing.
        Defaults to ``window.jQuery``.

    .. js:attribute:: QWeb2.Engine.preprocess_node

        A ``Function``. If present, called before compiling each DOM
        node to template code. In Odoo Web, this is used to
        automatically translate text content and some attributes in
        templates. Defaults to ``null``.

.. [#genshif] it is similar in that to Genshi_, although it does not use (and
              has no support for) `XML namespaces`_

.. [#othertemplates] although it uses a few others, either for historical
                     reasons or because they remain better fits for the
                     use case. Odoo 9.0 still depends on Jinja_ and Mako_.

.. _templating:
    https://en.wikipedia.org/wiki/Template_processor

.. _Jinja: http://jinja.pocoo.org
.. _Mako: https://www.makotemplates.org
.. _Genshi: https://genshi.edgewall.org
.. _XML namespaces: https://en.wikipedia.org/wiki/XML_namespace
.. _HTML: https://en.wikipedia.org/wiki/HTML
.. _XSS: https://en.wikipedia.org/wiki/Cross-site_scripting
.. _JSON: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON
.. _CSS selector: https://api.jquery.com/category/selectors/
.. _XPATH: https://developer.mozilla.org/en-US/docs/Web/XPath


==================================================
SECTION: registries.rst
PATH: developer/reference/frontend/registries.rst
==================================================

.. _frontend/registries:

==========
Registries
==========

Registries are (ordered) key/value maps. They are the main web client extension
points: many features provided by the Odoo javascript framework simply look up
into a registry whenever it needs a definition for some object (such as fields,
views, client actions or services). Customizing the web client is then simply
done by adding specific values in the correct registry.

.. code-block:: javascript

   import { Registry } from "@web/core/registry";

   const myRegistry = new Registry();

   myRegistry.add("hello", "odoo");

   console.log(myRegistry.get("hello"));

A useful feature of registries is that they maintain a set of sub registries,
obtained by the `category` method. If the sub registry does not exist yet, it
is created on the fly. All registries used by the web client are obtained
in such a way from one root registry, exported in `@web/core/registry`.

.. code-block:: javascript

   import { registry } from "@web/core/registry";

   const fieldRegistry = registry.category("fields");
   const serviceRegistry = registry.category("services");
   const viewRegistry = registry.category("views");

Registry API
============

.. js:class:: Registry()

    Creates a new registry. Note that a registry is an event bus, so one can
    listen to the `UPDATE` event if necessary. Registries are ordered: the
    :js:meth:`getAll <Registry.getAll>` method returns a list of
    values ordered according to their sequence number.

    .. js:method:: add(key, value[, options])

        :param string key: key for the new entry
        :param any value: value for the new entry
        :param Object options: options
        :param boolean [options.force]: do not throw if key already exists
        :param number [options.sequence]: sequence number (useful to order entries)
        :returns: Registry

        Inserts a value at a specific key. If the key is already used, this method
        throws an error (unless the option `force` is set to true). The option
        `sequence` is useful to insert the value at a specific position. This method
        also triggers an `UPDATE` event.

        Returns the same registry, so `add` method calls can be chained.

    .. js:method:: get(key[, defaultValue])

        :param string key: key for the entry
        :param defaultValue any: return value if no entry for key exists

        Returns the value corresponding to the `key` argument. If the registry does
        not contain that key, this method returns `defaultValue` if given, or throws
        an error otherwise.

    .. js:method:: contains(key)

        :param string key: key for the entry
        :returns: boolean

        Returns `true` if `key` is present in the registry

    .. js:method:: getAll()

        :returns: any[]

        Returns the list of all elements in the registry. It is ordered
        according to the sequence numbers.

    .. js:method:: remove(key)

        :param string key: the key for the entry that should be removed

        Removes a key/value pair from the registry. This operation triggers an
        `UPDATE` event.

    .. js:method:: category(subcategory)

        :param string subcategory: the name for the sub category
        :returns: Registry

        Returns the sub registry associated with the `subcategory`. If it does not
        exist yet, the sub registry is created on the fly.

Reference List
==============

.. list-table::
   :widths: 30 70
   :header-rows: 1

   * - Category
     - Content
   * - :ref:`effects <frontend/registries/effects>`
     - implementation for all available effects
   * - :ref:`formatters <frontend/registries/formatters>`
     - utility functions to format values (mostly used for field values)
   * - :ref:`main_components <frontend/registries/main_components>`
     - top level components
   * - :ref:`parsers <frontend/registries/parsers>`
     - utility functions to parse values (mostly used for field values)
   * - :ref:`services <frontend/registries/services>`
     - all services that should be activated
   * - :ref:`systray <frontend/registries/systray>`
     - components displayed in the systray zone in the navbar
   * - :ref:`user_menuitems <frontend/registries/usermenu>`
     - menu items displayed in the user menu (top right of navbar)

.. _frontend/registries/effects:

Effect registry
---------------

The `effects` registry contains the implementations of all available effects.
See the section on the :ref:`effect service <frontend/services/effect_registry>`
for more details.

.. _frontend/registries/formatters:

Formatter registry
------------------

The `formatters` registry contains functions to format values. Each formatter
has the following API:

.. js:function:: format(value[, options])

    :param value: a value of a specific type, or `false` if no value is given
    :type value: T | false
    :param Object options: various options
    :returns: string

    Formats a value and returns a string

.. seealso::
    - :ref:`Parsers registry <frontend/registries/parsers>`

.. _frontend/registries/main_components:

Main components registry
------------------------

The main component registry (`main_components`) is useful for adding top level
components in the web client.  The webclient has a `MainComponentsContainer` as
direct child. This component is basically a live representation of the ordered
list of components registered in the main components registry.

API
    .. code-block:: text

        interface {
            Component: Owl Component class
            props?: any
        }


For example, the `LoadingIndicator` component can be added in the registry like
this:

.. code-block:: javascript

   registry.category("main_components").add("LoadingIndicator", {
     Component: LoadingIndicator,
   });

.. _frontend/registries/parsers:

Parser registry
---------------

The `parsers` registry contains functions to parse values. Each parser
has the following API:

.. js:function:: parse(value[, options])
    :noindex:

    :param value: a string representing a value
    :type value: string
    :param Object options: various options (parser specific)
    :returns: T a valid value

    Parses a string and returns a value. If the string does not represent a valid
    value, parsers can fail and throw errors.

.. seealso::
    - :ref:`Formatters registry <frontend/registries/formatters>`

.. _frontend/registries/services:

Service registry
----------------

The service registry (category: `services`) contains all
:ref:`services <frontend/services>` that should be activated by the Odoo
framework.

.. code-block:: javascript

    import { registry } from "@web/core/registry";

    const myService = {
        dependencies: [...],
        start(env, deps) {
            // some code here
        }
    };

    registry.category("services").add("myService", myService);

.. _frontend/registries/systray:

Systray registry
----------------

The systray is the zone on the right of the navbar that contains various small
components, that usually display some sort of information (like the number of
unread messages), notifications and/or let the user interact with them.

The `systray` registry contains a description of these systray items, as objects
with the following three keys:

- `Component`: the component class that represents the item. Its root element
  should be a `<li>` tag, otherwise it might not be styled properly.
- `props (optional)`: props that should be given to the component
- `isDisplayed (optional)`: a function that takes the :ref:`env <frontend/framework/environment>`
  and returns a boolean. If true, the systray item is displayed. Otherwise it is
  removed.

For example:

.. code-block:: javascript

    import { registry } from "@web/core/registry";

    class MySystrayItem extends Component {
        // some component ...
    }

    registry.category("systray").add("myAddon.myItem", {
        Component: MySystrayItem,
    });


The systray registry is an ordered registry (with the `sequence` number):

.. code-block:: javascript

    const item = {
        Component: MySystrayItem
    };
    registry.category("systray").add("myaddon.some_description", item, { sequence: 43 });

The sequence number defaults to 50. If given, this number will be used
to order the items. The lowest sequence is on the right and the highest sequence
is on the left in the systray menu.

.. _frontend/registries/usermenu:

Usermenu registry
-----------------

The user menu registry (category: `user_menuitems`) contains all menu items that
are shown when opening the user menu (the navbar element with the user name, on
the top right).

User menu items are defined by a function taking the :ref:`env <frontend/framework/environment>`
and returning a plain object, containing the following information:

* `description` : the menu item text,
* `href` : (optional) if given (and truthy), the item text is put in a `a` tag with given attribute href,
* `callback` : callback to call when the item is selected,
* `hide`: (optional) indicates if the item should be hidden (default: `false`),
* `sequence`: (optional) determines the rank of the item among the other dropwdown items (default: 100).

The user menu calls all the functions defining items every time it is opened.

Example:

.. code-block:: javascript

    import { registry } from "@web/core/registry";

    registry.category("user_menuitems").add("my item", (env) => {
        return {
            description: env._t("Technical Settings"),
            callback: () => { env.services.action_manager.doAction(3); },
            hide: (Math.random() < 0.5),
        };
    });


==================================================
SECTION: services.rst
PATH: developer/reference/frontend/services.rst
==================================================


.. _frontend/services:

========
Services
========

Services are long lived pieces of code that provide a feature. They may be
imported by components (with ``useService``) or by other services. Also, they
can declare a set of dependencies. In that sense, services are basically a
DI :dfn:`dependency injection` system. For example, the ``notification`` service
provides a way to display a notification, or the ``rpc`` service is the proper
way to perform a request to the Odoo server.

The following example registers a simple service that displays a notification
every 5 seconds:

.. code-block:: javascript

    import { registry } from "@web/core/registry";

    const myService = {
        dependencies: ["notification"],
        start(env, { notification }) {
            let counter = 1;
            setInterval(() => {
                notification.add(`Tick Tock ${counter++}`);
            }, 5000);
        }
    };

    registry.category("services").add("myService", myService);

At startup, the web client starts all services present in the `services`
registry. Note that the name used in the registry is the name of the service.

.. note::

   Most code that is not a component should be *packaged* in a service, in
   particular if it performs some side effect.  This is very useful for testing
   purposes: tests can choose which services are active, so there are less chance
   for unwanted side effects interfering with the code being tested.

Defining a service
==================

A service needs to implement the following interface:

.. js:data:: dependencies

    Optional list of strings. It is the list of all dependencies (other services)
    that this service needs

.. js:function:: start(env, deps)

    :param Environment env: the application environment
    :param Object deps: all requested dependencies
    :returns: value of service or Promise<value of service>

    This is the main definition for the service. It can return either a value or
    a promise. In that case, the service loader simply waits for the promise to
    resolve to a value, which is then the value of the service.

    Some services do not export any value. They may just do their work without a
    need to be directly called by other code. In that case, their value will be
    set to ``null`` in ``env.services``.

.. js:data:: async

    Optional value. If given, it should be `true` or a list of strings.

    Some services need to provide an asynchronous API. For example, the `rpc`
    service is an asynchronous function, or the `orm` service provides a set of
    functions to call the Odoo server.

    In that case, it is possible for components that use a service to be
    destroyed before the end of an asynchronous function call. Most of the time,
    the asynchronous function call needs to be ignored. Doing otherwise is
    potentially very risky, because the underlying component is no longer active.
    The `async` flag is a way to do just that: it signals to the service creator
    that all asynchronous calls coming from components should be left pending if
    the component is destroyed.


Using a service
===============

A service that depends on other services and has properly declared its
``dependencies`` simply receives a reference to the corresponding services
in the second argument of the ``start`` method.

The ``useService`` hook is the proper way to use a service in a component. It
simply returns a reference to the service value, that can then be used by the
component later. For example:

.. code-block:: javascript

    import { rpc } from "@web/core/network/rpc";

    class MyComponent extends Component {
      setup() {
        onWillStart(async () => {
          const result = await rpc(...);
        })
      }
    }

Reference List
==============

.. list-table::
   :widths: 25 75
   :header-rows: 1

   * - Technical Name
     - Short Description
   * - :ref:`cookie <frontend/services/cookie>`
     - read or modify cookies
   * - :ref:`effect <frontend/services/effect>`
     - display graphical effects
   * - :ref:`http <frontend/services/http>`
     - perform low level http calls
   * - :ref:`notification <frontend/services/notification>`
     - display notifications
   * - :ref:`router <frontend/services/router>`
     - manage the browser url
   * - :ref:`rpc <frontend/services/rpc>`
     - send requests to the server
   * - :ref:`scroller <frontend/services/scroller>`
     - handle clicks on anchors elements
   * - :ref:`title <frontend/services/title>`
     - read or modify the window title
   * - :ref:`user <frontend/services/user>`
     - provides some information related to the current user

.. _frontend/services/cookie:

Cookie service
--------------

Overview
~~~~~~~~

- Technical name: `cookie`
- Dependencies: none

Provides a way to manipulate cookies. For example:

.. code-block:: javascript

   cookieService.setCookie("hello", "odoo");

API
~~~

.. js:data:: current

   Object representing each cookie and its value if any (or empty string)

.. js:function:: setCookie(name[, value, ttl])

    :param string name: the name of the cookie that should be set
    :param any value: optional. If given, the cookie will be set to that value
    :param number ttl: optional. the time in seconds before the cookie will be deleted (default=1 year)

    Sets the cookie `name` to the value `value` with a max age of `ttl`

.. js:function:: deleteCookie(name)

    :param string name: name of the cookie

    Deletes the cookie `name`.

.. _frontend/services/effect:

Effect service
--------------

Overview
~~~~~~~~

* Technical name: `effect`
* Dependencies: None

Effects are graphical elements that can be temporarily displayed on top of the page, usually to provide feedback to the user that something interesting happened.

A good example would be the rainbow man:

.. image:: services/rainbow_man.png
    :alt: The rainbow man effect
    :width: 600
    :align: center


Here's how this can be displayed:

.. code-block:: javascript

    const effectService = useService("effect");
    effectService.add({
      type: "rainbow_man", // can be omitted, default type is already "rainbow_man"
      message: "Boom! Team record for the past 30 days.",
    });

.. warning ::
    The hook `useEffect` is not related to the effect service.

API
~~~

.. js:function:: effectService.add(options)

  :param object options: the options for the effect. They will get passed along to the underlying effect component.

  Display an effect.

The options are defined by:

.. code-block:: ts

  interface EffectOptions {
    // The name of the desired effect
    type?: string;
    [paramName: string]: any;
  }

Available effects
~~~~~~~~~~~~~~~~~

Currently, the only effect is the rainbow man.

RainbowMan
**********

.. code-block:: javascript

  effectService.add({ type: "rainbow_man" });

.. list-table::
    :widths: 20 40 40
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `params.Component`
      - `owl.Component?`
      - Component class to instantiate inside the RainbowMan (will replace the message).
    * - `params.props`
      - `object?={}`
      - If params.Component is given, its props can be passed with this argument.
    * - `params.message`
      - `string?="Well Done!"`
      - Message is the notice the rainbowman holds.

        If effects are disabled for the user, the rainbowman won't appear and a simple notification
        will get displayed as a fallback.

        If effects are enabled and params.Component is given, params.message is not used.

        The message is a simple string or a string representing html
        (prefer using params.Component if you want interactions in the DOM).
    * - `params.messageIsHtml`
      - `boolean?=false`
      - Set to true if the message represents html, s.t. it will be correctly inserted into the DOM.
    * - `params.img_url`
      - `string?=/web/static/img/smile.svg`
      - The url of the image to display inside the rainbow.
    * - `params.fadeout`
      - `("slow"|"medium"|"fast"|"no")?="medium"`
      - Delay for rainbowman to disappear.

        `"fast"` will make rainbowman dissapear quickly.

        `"medium"` and `"slow"` will wait little longer before disappearing (can be used when `params.message` is longer).

        `"no"` will keep rainbowman on screen until user clicks anywhere outside rainbowman.


How to add an effect
~~~~~~~~~~~~~~~~~~~~

.. _frontend/services/effect_registry:

The effects are stored in a registry called `effects`.
You can add new effects by providing a name and a function.

.. code-block:: javascript

  const effectRegistry = registry.category("effects");
  effectRegistry.add("rainbow_man", rainbowManEffectFunction);

The function must follow this API:

.. js:function:: <newEffectFunction>(env, params)

    :param Env env: the environment received by the service

    :param object params: the params received from the add function on the service.

    :returns: `({Component, props} | void)` A component and its props or nothing.

This function must create a component and return it. This component is mounted inside the
effect component container.

Example
~~~~~~~

Let's say we want to add an effect that add a sepia look at the page.

.. code-block:: javascript

  import { registry } from "@web/core/registry";
  import { Component, xml } from "@odoo/owl";

  class SepiaEffect extends Component {
    static template = xml`
      <div style="
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
          pointer-events: none;
          background: rgba(124,87,0, 0.4);
      "></div>
    `;
  }

  export function sepiaEffectProvider(env, params = {}) {
      return {
          Component: SepiaEffect,
      };
  }

  const effectRegistry = registry.category("effects");
  effectRegistry.add("sepia", sepiaEffectProvider);


And then, call it somewhere you want and you will see the result.
Here, it is called in webclient.js to make it visible everywhere for the example.

.. code-block:: javascript

  const effectService = useService("effect");
  effectService.add({ type: "sepia" });

.. image:: services/odoo_sepia.png
    :alt: Odoo in sepia
    :width: 600
    :align: center

.. _frontend/services/http:

Http Service
------------

Overview
~~~~~~~~

* Technical name: `http`
* Dependencies: None

While most interactions between the client and the server in odoo are `RPCs` (`XMLHTTPRequest`), lower level
control on requests may sometimes be required.

This service provides a way to send `get` and `post` `http requests <https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods>`_.

API
~~~

.. js:function:: async get(route[,readMethod = "json"])

  :param string route: the url to send the request to
  :param string readMethod: the response content type. Can be "text", "json", "formData", "blob", "arrayBuffer".
  :returns: the result of the request with the format defined by the readMethod argument.

  Sends a get request.

.. js:function:: async post(route [,params = {}, readMethod = "json"])

  :param string route: the url to send the request to
  :param object params: key value data to be set in the form data part of the request
  :param string readMethod: the response content type. Can be "text", "json", "formData", "blob", "arrayBuffer".
  :returns: the result of the request with the format defined by the readMethod argument.

  Sends a post request.

Example
~~~~~~~

.. code-block:: javascript

  const httpService = useService("http");
  const data = await httpService.get("https://something.com/posts/1");
  // ...
  await httpService.post("https://something.com/posts/1", { title: "new title", content: "new content" });

.. _frontend/services/notification:

Notification service
--------------------

Overview
~~~~~~~~

* Technical name: `notification`
* Dependencies: None

The `notification` service allows to display notifications on the screen.

.. code-block:: javascript

  const notificationService = useService("notification");
  notificationService.add("I'm a very simple notification");

API
~~~

.. js:function:: add(message[, options])

    :param string message: the notification message to display
    :param object options: the options of the notification
    :returns: a function to close the notification

    Shows a notification.

    The options are defined by:

    .. list-table::
      :widths: 15 30 55
      :header-rows: 1

      * - Name
        - Type
        - Description
      * - `title`
        - string
        - Add a title to the notification
      * - `type`
        - `warning` | `danger` | `success` | `info`
        - Changes the background color according to the type
      * - `sticky`
        - boolean
        - Whether or not the notification should stay until dismissed
      * - `className`
        - string
        - additional css class that will be added to the notification
      * - `onClose`
        - function
        - callback to be executed when the notification closes
      * - `buttons`
        - button[] (see below)
        - list of button to display in the notification
      * - `autocloseDelay`
        - number
        - duration in milliseconds before the notification is closed automatically


    The buttons are defined by:

    .. list-table::
      :widths: 15 30 55
      :header-rows: 1

      * - Name
        - Type
        - Description
      * - `name`
        - string
        - The button text
      * - `onClick`
        - function
        - callback to execute when the button is clicked
      * - `primary`
        - boolean
        - whether the button should be styled as a primary button

Examples
~~~~~~~~

A notification for when a sale deal is made with a button to go some kind of commission page.

.. code-block:: javascript

  // in setup
  this.notificationService = useService("notification");
  this.actionService = useService("action");

  // later
  this.notificationService.add("You closed a deal!", {
    title: "Congrats",
    type: "success",
    buttons: [
        {
            name: "See your Commission",
            onClick: () => {
                this.actionService.doAction("commission_action");
            },
        },
    ],
  });

.. image:: services/notification_service.png
  :width: 600 px
  :alt: Example of notification
  :align: center

A notification that closes after a second:

.. code-block:: javascript

  const notificationService = useService("notification");
  const close = notificationService.add("I will be quickly closed");
  setTimeout(close, 1000);

.. _frontend/services/router:

Router Service
--------------

Overview
~~~~~~~~

- Technical name: `router`
- Dependencies: none

The `router` service provides three features:

* information about the current route
* a way for the application to update the url, depending on its state
* listens to every hash change, and notifies the rest of the application

API
~~~

.. js:data:: current
   :noindex:

   The current route can be accessed with the ``current`` key. It is an object
   with the following information:

   * `pathname (string)`: the path for the current location (most likely `/web` )
   * `search (object)`: a dictionary mapping each search keyword (the querystring)
     from the url to its value. An empty string is the value if no value was
     explicitely given
   * `hash (object)`: same as above, but for values described in the hash.

For example:

.. code-block:: javascript

  // url = /web?debug=assets#action=123&owl&menu_id=174
  const { pathname, search, hash } = env.services.router.current;
  console.log(pathname); //   /web
  console.log(search); //   { debug="assets" }
  console.log(hash); //   { action:123, owl: "", menu_id: 174 }

Updating the URL is done with the  `pushState` method:

.. js:function:: pushState(hash: object[, replace?: boolean])

  :param Object hash: object containing a mapping from some keys to some values
  :param boolean replace: if true, the url will be replaced, otherwise only
    key/value pairs from the `hash` will be updated.

  Updates the URL with each key/value pair from the `hash` object. If a value is
  set to an empty string, the key is added to the url without any corresponding
  value.

  If true, the `replace` argument tells the router that the url hash should be
  completely replaced (so values not present in the `hash` object will be removed).

  This method call does not reload the page. It also does not trigger a
  `hashchange` event, nor a `ROUTE_CHANGE` in the :ref:`main bus <frontend/framework/bus>`.
  This is because this method is intended to only updates the url. The code calling
  this method has the responsibility to make sure that the screen is updated as
  well.

For example:

.. code-block:: javascript

  // url = /web#action_id=123
  routerService.pushState({ menu_id: 321 });
  // url is now /web#action_id=123&menu_id=321
  routerService.pushState({ yipyip: "" }, replace: true);
  // url is now /web#yipyip


Finally, the `redirect` method will redirect the browser to a specified url:

.. js:function:: redirect(url[, wait])

  :param string url: a valid url
  :param boolean wait: if true, wait for the server to be ready, and redirect after

  Redirect the browser to `url`. This method reloads the page. The `wait`
  argument is rarely used: it is useful in some cases where we know that the
  server will be unavailable for a short duration, typically just after an addon
  update or install operation.

.. note::
   The router service emits a `ROUTE_CHANGE` event on the :ref:`main bus <frontend/framework/bus>`
   whenever the current route has changed.

.. _frontend/services/rpc:

RPC service
-----------

Overview
~~~~~~~~

- Technical name: `rpc`
- Dependencies: none

The `rpc` service provides a single asynchronous function to send requests to
the server. Calling a controller is very simple: the route should be the first
argument and optionally, a ``params`` object can be given as a second argument.

.. code-block:: javascript

  import { rpc } from "@web/core/network/rpc";

   // somewhere else, in an async function:
   const result = await rpc("/my/route", { some: "value" });

.. note::

    Note that the ``rpc`` service is considered a low-level service. It should
    only be used to interact with Odoo controllers. To work with models (which
    is by far the most important usecase), one should use the ``orm`` service
    instead.

API
~~~

.. js:function:: rpc(route, params, settings)

    :param string route: route targeted by the request
    :param Object params: (optional) parameters sent to the server
    :param Object settings: (optional) request settings (see below)

    The ``settings`` object can contain:

    - ``xhr``, which should be a ``XMLHTTPRequest`` object. In that case,
      the ``rpc`` method will simply use it instead of creating a new one. This
      is useful when one accesses advanced features of the `XMLHTTPRequest` API.
    - ``silent (boolean)`` If set to ``true``, the web client will not provide
      a feedback that there is a pending rpc.

The ``rpc`` service communicates with the server by using a ``XMLHTTPRequest``
object, configured to work with the ``application/json`` content type. So clearly
the content of the request should be JSON serializable. Each request done by
this service uses the ``POST`` http method.

Server errors actually return the response with an http code 200. But the ``rpc``
service will treat them as error.

Error Handling
~~~~~~~~~~~~~~

An rpc can fail for two main reasons:

* either the odoo server returns an error (so, we call this a ``server`` error).
  In that case the http request will return with an http code 200 BUT with a
  response object containing an ``error`` key.

* or there is some other kind of network error

When a rpc fails, then:

* the promise representing the rpc is rejected, so the calling code will crash,
  unless it handles the situation
* an event ``RPC_ERROR`` is triggered on the main application bus. The event payload
  contains a description of the cause of the error:

  If it is a server error (the server code threw an exception). In that case
  the event payload will be an object with the following keys:


  * ``type = 'server'``
  * ``message(string)``
  *
    ``code(number)``

  *
    ``name(string)`` (optional, used by the error service to look for an appropriate
    dialog to use when handling the error)

  * ``subType(string)`` (optional, often used to determine the dialog title)
  * ``data(object)`` (optional object that can contain various keys among which
    ``debug`` : the main debug information, with the call stack)

  If it is a network error, then the error description is simply an object
  ``{type: 'network'}``.
  When a network error occurs, a :ref:`notification <frontend/services/notification>` is
  displayed and the server is regularly contacted until it responds. The
  notification is closed as soon as the server responds.

.. _frontend/services/scroller:

Scroller service
----------------

Overview
~~~~~~~~

- Technical name: `scroller`
- Dependencies: none

Whenever the user clicks on an anchor in the web client, this service automatically scrolls
to the target (if appropriate).

The service adds an event listener to get `click`'s on the document. The service checks
if the selector contained in its href attribute is valid to distinguish anchors and Odoo
actions (e.g. `<a href="#target_element"></a>`). It does nothing if it is not the case.

An event `SCROLLER:ANCHOR_LINK_CLICKED` is triggered on the main application bus if the click seems to be
targeted at an element. The event contains a custom event containing the `element` matching and its `id` as a reference.
It may allow other parts to handle a behavior relative to anchors themselves. The original event is also
given as it might need to be prevented. If the event is not prevented, then the user interface will
scroll to the target element.

API
~~~

The following values are contained in the `anchor-link-clicked` custom event explained above.

.. list-table::
    :widths: 25 25 50
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - `element`
      - `HTMLElement | null`
      - The anchor element targeted by the href
    * - `id`
      - `string`
      - The id contained in the href
    * - `originalEv`
      - `Event`
      - The original click event

.. note::
   The scroller service emits a `SCROLLER:ANCHOR_LINK_CLICKED` event on the :ref:`main bus <frontend/framework/bus>`.
   To avoid the default scroll behavior of the scroller service, you must use `preventDefault()` on the event given
   to the listener so that you can implement your own behavior correctly from the listener.

.. _frontend/services/title:

Title Service
-------------

Overview
~~~~~~~~

- Technical name: `title`
- Dependencies: none

The `title` service offers a simple API that allows to read/modify the document
title. For example, if the current document title is "Odoo", we can change it
to "Odoo 15 - Apple" by using the following command:

.. code-block:: javascript

   // in some component setup method
   const titleService = useService("title");

   titleService.setParts({ odoo: "Odoo 15", fruit: "Apple" });

API
~~~


The ``title`` service manipulates the following interface:

.. code-block:: ts

   interface Parts {
       [key: string]: string | null;
   }

Each key represents the identity of a part of the title, and each value is the
string that is displayed, or `null` if it has been removed.

Its API is:

.. js:data:: current
   :noindex:

   This is a string representing the current title. It is structured in the
   following way: ``value_1 - ... - value_n`` where each `value_i` is a (non null)
   value found in the `Parts` object (returned by the `getParts` function)

.. js:function:: getParts

   :returns: Parts the current `Parts` object maintained by the title service

.. js:function:: setParts(parts)

   :param Parts parts: object representing the required change

   The ``setParts`` method allows to add/replace/delete several parts of the title.
   Delete a part (a value) is done by setting the associated key value to `null`.

   Note that one can only modify a single part without affecting the other
   parts. For example, if the title is composed of the following parts:

   .. code-block:: javascript

      { odoo: "Odoo", action: "Import" }

   with ``current`` value being ``Odoo - Import`` , then

   .. code-block:: javascript

      setParts({
        action: null,
      });

   will change the title to ``Odoo``.


.. _frontend/services/user:

User service
------------

Overview
~~~~~~~~

* Technical name: `user`
* Dependencies: `rpc`

The `user` service provides a bunch of data and a few helper functions concerning
the connected user.


API
~~~

.. list-table::
    :widths: 25 25 50
    :header-rows: 1

    * - Name
      - Type
      - Description
    * - ``context``
      - ``Object``
      - The :ref:`user context<frontend/framework/user_context>`
    * - ``db``
      - ``Object``
      - Info about the database
    * - ``home_action_id``
      - ``(number | false)``
      - Id of the action used as home for the user
    * - ``isAdmin``
      - ``boolean``
      - Whether the user is an admin (group `base.group_erp_manager` or superuser)
    * - ``isSystem``
      - ``boolean``
      - Whether the user is part of the system group (`base.group_system`)
    * - ``lang``
      - ``string``
      - language used
    * - ``name``
      - ``string``
      - Name of the user
    * - ``partnerId``
      - ``number``
      - Id of the partner instance of the user
    * - ``tz``
      - ``string``
      - The timezone of the user
    * - ``userId``
      - ``number``
      - Id of the user
    * - ``userName``
      - ``string``
      - Alternative nick name of the user


.. js:function:: updateContext(update)

    :param object update: the object to update the context with

    update the :ref:`user context<frontend/framework/user_context>` with the given object.

    .. code-block:: javascript

      userService.updateContext({ isFriend: true })

.. js:function:: removeFromContext(key)

    :param string key: the key of the targeted attribute

    remove the value with the given key from the :ref:`user context<frontend/framework/user_context>`

    .. code-block:: javascript

      userService.removeFromContext("isFriend")

.. js:function:: hasGroup(group)

    :param string group: the xml_id of the group to look for

    :returns: `Promise<boolean>` is the user in the group

    check if the user is part of a group

    .. code-block:: javascript

      const isInSalesGroup = await userService.hasGroup("sale.group_sales")


==================================================
SECTION: unit_testing.rst
PATH: developer/reference/frontend/unit_testing.rst
==================================================

:show-content:
:show-toc:

=======================
JavaScript Unit Testing
=======================

Writing unit tests is as important as writing the code itself: it helps to
ensure that the code is written according to a given specification and that it
remains correct as it evolves.

Testing Framework
=================

Testing the code starts with a testing framework. The framework provides a level
of abstraction that makes it possible to write tests in an easy and efficient way.
It also provides a set of tools to run the tests, make assertions and report the
results.

Odoo developers use a home-grown testing framework called :abbr:`HOOT (Hierarchically Organized
Odoo Tests)`. The main reason for using a custom framework is that it allows us to extend it based
on our needs (tags system, mocking of global objects, etc.).

On top of that framework we have built a set of tools to help us write tests for the web client
(`web_test_helpers`), and a mock server to simulate the server side (`mock_server`).

You can find links to the reference of each of these parts below, as well as a section filled with
examples and best practices for writing tests.

Setup
=====

Before learning how to write tests, it is good to start with the basics. The following steps
will ensure that your test files are properly picked up by the test runner.

Note that in existing addons, most of these steps can be skipped since the proper
folder structure and asset bundles are probably set up.

#. Writing files in the right **place**:

    All JavaScript test files should be put under the `/static/tests` folder of the
    related addon (e.g. :file:`/web/static/tests/env.test.js`).

#. Using the right **name**:

    Test files must end with :file:`.test.js`. This is not only a convention, but a requirement
    for test files to be picked up by the runner. All other JavaScript files will be
    interpreted either as production code (i.e. the code to be tested), or as test
    helper files (such as `web_test_helpers <{GITHUB_PATH}/addons/web/static/tests/web_test_helpers.js>`_).

    .. note::
        It is to be noted that there is an exception for :file:`.hoot.js` files, which are not
        considered as test files, but as global modules for the whole test run, while other
        JavaScript modules are re-created for each test suite. Since the same instance of
        these modules will be running for the whole test run, they follow strict constraints,
        such as restricted imports, or advanced memory management techniques to
        ensure no side-effects are affecting tests.

#. Calling the files in the right **bundle**:

    Test files, added in the right folder, must be included in the `web.assets_unit_tests`
    bundle. For ease of use, this can be done with glob syntax to import all test
    and test helper files:

    .. code:: python

        # Unit test files
        'web.assets_unit_tests': [
            'my_addon/static/tests/**/*',
        ],

#. Heading to the right **URL**:

    To run tests, you can then go to the `/web/tests` URL.

    .. tip::
        This page can be accessed through :icon:`fa-bug` :menuselection:`Debug menu --> Run Unit Tests`.

Writing tests
=============

After creating and including test files, it is time to write tests. You may refer
to the following documentation sections to learn about the testing framework.

.. toctree::
    :titlesonly:

    unit_testing/hoot
    unit_testing/web_helpers
    unit_testing/mock_server


==================================================
SECTION: web_helpers.rst
PATH: developer/reference/frontend/unit_testing/web_helpers.rst
==================================================

================
Web test helpers
================

Overview
========

After the :doc:`"@odoo/hoot" <./hoot>` module, the second most-solicited module
in test files should be `"@web/../tests/web_test_helpers"`.

This module contains all the helpers that combine the low-level helpers provided
by Hoot, with all the most common features that are used in tests in Odoo.

These helpers are many, and this section of the documentation will only highlight
the most common ones, and the way they interact with one another.

For a full list of available helpers, you may refer to the `web_test_helpers file <{GITHUB_PATH}/addons/web/static/tests/web_test_helpers.js>`_.

.. _web-test-helpers/environment:

Mock environment
================

The `makeMockEnv` helper is the lowest helper that can spawn an `env`.

It will take care of

- creating the `env` object itself, pre-configured with all the required properties
  for the proper functioning of web components, such as `getTemplate` or `translateFn`;

- spawning a `MockServer` (if one did not exist already for that test);

- starting all registered :doc:`services <../services>`, and awaiting until they are all ready;

- initiating other features that are not tied to a service, such as the web `router`;

- guaranteeing the teardown of all the features in its setup at the end of the test.

This method is great for testing low-level features, such as :doc:`services <../services>` that are
not tied to a Component_:

.. code-block:: javascript

    // Can be further configured, but is already packed with all the necessary stuff
    const env = await makeMockEnv();

    expect(env.isSmall).toBe(false);

.. note::
    Like :ref:`makeMockServer <mock-server/spawning>`, only one `env` can be active for a given test.
    It is not necessary to call `makeMockEnv` manually to retrieve the current environment
    instance; the `getMockEnv` helper can be called instead.

.. example::

    - `DateTime input tests <{GITHUB_PATH}/addons/web/static/tests/core/components/datetime/datetime_input.test.js>`_

    - `Name service tests <{GITHUB_PATH}/addons/web/static/tests/core/name_service.test.js>`_

.. _web-test-helpers/components:

Mounting components
===================

Instantiating and appending `components <Component_>`_ to the DOM is meant to be easy,
through the use of the `mountWithCleanup` helper. It will prepare an `env` internally
(if one does not exist yet), which in turn also makes sure that a `MockServer` is
running.

It takes a `Component` class as its first argument, and an *optional* parameters
second argument, used to specify `props` or a custom `target`:

.. code-block:: javascript

    await mountWithCleanup(Checkbox, {
        props: {
            value: false
        },
    });

This helper will return the active `Component` instance.

.. important::
    It is generally *ill-advised* to retrieve the `Component` instance to directly
    interact with it or to perform assertions on its internal variables. The only
    "accepted" use cases are when the `Component` is displaying hard-to-retrieve information
    in the DOM, such as graphs in a `canvas <https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API>`_.
    For most cases, it is highly preferred to query derived information in the DOM.

.. example::

    - `Checkbox tests <{GITHUB_PATH}/addons/web/static/tests/core/checkbox.test.js>`_

    - `Popover tests <{GITHUB_PATH}/addons/web/static/tests/core/popover/popover.test.js>`_

    - `DateTimePicker tests <{GITHUB_PATH}/addons/web/static/tests/core/components/datetime/datetime_picker.test.js>`_

.. _web-test-helpers/views:

Mounting views
==============

Mounting a view is simply a matter of using :ref:`mountWithCleanup <web-test-helpers/components>`
with the View_ component and the correct properties.

For that purpose, web test helpers export a `mountView` helper, taking a parameters
object determining the view `type`, `resModel`, and other optional properties such
as an XML `arch`:

.. code-block:: javascript

    // Resolves when the view is fully ready
    await mountView({
        type: "list",
        resModel: "res.partner",
        arch: /* xml */ `
            <list>
                <field name="display_name" />
            </list>
        `,
    });

Like the previous helpers on top of which `mountView` is built, it will ensure that
both an `env` and a `MockServer` are running for the current test.

.. note::
    Like :ref:`mountWithCleanup <web-test-helpers/components>`, it is *NOT*
    recommended to retrieve the returned View_ component instance. It can however
    be done, for cases like the `Graph view <{GITHUB_PATH}/addons/web/static/src/views/graph/graph_view.js>`_.

.. example::

    - `Calendar view tests <{GITHUB_PATH}/addons/web/static/tests/views/calendar/calendar_view.test.js>`_

    - `Graph view tests <{GITHUB_PATH}/addons/web/static/tests/views/graph/graph_view.test.js>`_

    - `Kanban view tests <{GITHUB_PATH}/addons/web/static/tests/views/kanban/kanban_view.test.js>`_

Interacting with components
===========================

Hoot provides helpers to interact with the DOM (e.g. `click`, `press`, etc.). However,
these helpers present 2 issues when interacting with more complex components:

#. helpers try to interact instantly, while sometimes the element has yet to be
   appended to the document (in an unknown amount of time);

#. helpers only wait a single micro-task tick per dispatched event, while most
   Owl-based UIs take at least a full animation frame to update.

.. code-block:: javascript

    // Edit record name
    await click(".o_field_widget[name=name]");
    await edit("Gaston Lagaffe");

    // Potential error 1: button may not be in the DOM yet
    await click(".btn:contains(Save)");

    // Potential error 2: view is not yet updated
    expect(".o_field_widget[name=name]").toHaveText("Gaston Lagaffe");

With these constraints in mind, web test helpers provide the `contains` helper:

.. code-block:: javascript

    // Combines 'click' + 'edit' + 'animationFrame' calls
    await contains(".o_field_widget[name=name]").edit("Gaston Lagaffe");
    // Waits for (at least) a full animation frame after the click
    await contains(".btn:contains(Save)").click();
    expect(".o_field_widget[name=name]").toHaveText("Gaston Lagaffe");

This approach, while seemingly drifting a bit further away from the concept of "unit
testing", is still a nice and convenient way to test more complex units such as `views <View_>`_,
the `WebClient <{GITHUB_PATH}/addons/web/static/src/webclient/webclient.js>`_, or
interactions between couples of :doc:`services <../services>` and components.

It should however not become the default for all interactions, as some of them still
need to happen *precisely* within a given time frame, which is a concept completely
ignored by `contains`.

.. note::
    Most helpers in Hoot are available as methods of a `contains` instance, with
    (generally) the same shape and API.

.. _Component: https://github.com/odoo/owl/blob/master/doc/reference/component.md
.. _View: {GITHUB_PATH}/addons/web/static/src/views/view.js
