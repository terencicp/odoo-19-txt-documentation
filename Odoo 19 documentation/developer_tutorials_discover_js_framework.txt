

==================================================
SECTION: 01_owl_components.rst
PATH: developer/tutorials/discover_js_framework/01_owl_components.rst
==================================================

=========================
Chapter 1: Owl components
=========================

This chapter introduces the `Owl framework <https://github.com/odoo/owl>`_, a tailor-made component
system for Odoo. The main building blocks of OWL are `components
<{OWL_PATH}/doc/reference/component.md>`_ and `templates <{OWL_PATH}/doc/reference/templates.md>`_.

In Owl, every part of user interface is managed by a component: they hold the logic and define the
templates that are used to render the user interface. In practice, a component is represented by a
small JavaScript class subclassing the `Component` class.

To get started, you need a running Odoo server and a development environment setup. Before getting
into the exercises, make sure you have followed all the steps described in this
:ref:`tutorial introduction <tutorials/discover_js_framework/setup>`.

.. tip::
   If you use Chrome as your web browser, you can install the `Owl Devtools` extension. This
   extension provides many features to help you understand and profile any Owl application.

   `Video: How to use the DevTools <https://www.youtube.com/watch?v=IUyQjwnrpzM>`_

In this chapter, we use the `awesome_owl` addon, which provides a simplified environment that
only contains Owl and a few other files. The goal is to learn Owl itself, without relying on Odoo
web client code.

.. spoiler:: Solutions

   The solutions for each exercise of the chapter are hosted on the `official Odoo tutorials
   repository
   <https://github.com/odoo/tutorials/commits/{CURRENT_MAJOR_BRANCH}-discover-js-framework-solutions/awesome_owl>`_. It
   is recommended to try to solve them first without looking at the solution!

Example: a `Counter` component
==============================

First, let us have a look at a simple example. The `Counter` component shown below is a component
that maintains an internal number value, displays it, and updates it whenever the user clicks on the
button.

.. code-block:: js

   import { Component, useState } from "@odoo/owl";

   export class Counter extends Component {
       static template = "my_module.Counter";

       setup() {
           this.state = useState({ value: 0 });
       }

       increment() {
           this.state.value++;
       }
   }

The `Counter` component specifies the name of a template that represents its html. It is written in XML
using the QWeb language:

.. code-block:: xml

   <templates xml:space="preserve">
      <t t-name="my_module.Counter">
         <p>Counter: <t t-esc="state.value"/></p>
         <button class="btn btn-primary" t-on-click="increment">Increment</button>
      </t>
   </templates>


1. Displaying a counter
=======================

.. image:: 01_owl_components/counter.png
   :align: center

As a first exercise, let us modify the `Playground` component located in
:file:`awesome_owl/static/src/` to turn it into a counter. To see the result, you can go to the
`/awesome_owl` route with your browser.


#. Modify :file:`playground.js` so that it acts as a counter like in the example above.
   Keep `Playground` for the class name. You will need to use the `useState hook
   <{OWL_PATH}/doc/reference/hooks.md#usestate>`_ so that the component is re-rendered
   whenever any part of the state object that has been read by this component is modified.
#. In the same component, create an `increment` method.
#. Modify the template in :file:`playground.xml` so that it displays your counter variable. Use
   `t-esc <{OWL_PATH}/doc/reference/templates.md#outputting-data>`_ to output the data.
#. Add a button in the template and specify a `t-on-click
   <{OWL_PATH}/doc/reference/event_handling.md#event-handling>`_ attribute in the button to
   trigger the `increment` method whenever the button is clicked.

.. tip::
   The Odoo JavaScript files downloaded by the browser are minified. For debugging purpose, it's
   easier when the files are not minified. Switch to :ref:`debug mode with assets
   <developer-mode/activation>` so that the files are not minified.

This exercise showcases an important feature of Owl: the `reactivity system <{OWL_PATH}/doc/reference/reactivity.md>`_.
The `useState` function wraps a value in a proxy so Owl can keep track of which component
needs which part of the state, so it can be updated whenever a value has been changed. Try
removing the `useState` function and see what happens.

2. Extract `Counter` in a sub component
=======================================

For now we have the logic of a counter in the `Playground` component, but it is not reusable. Let us
see how to create a `sub-component <{OWL_PATH}/doc/reference/component.md#sub-components>`_ from it:

#. Extract the counter code from the `Playground` component into a new `Counter` component.
#. You can do it in the same file first, but once it's done, update your code to move the
   `Counter` in its own folder and file. Import it relatively from `./counter/counter`. Make sure
   the template is in its own file, with the same name.
#. Use `<Counter/>` in the template of the `Playground` component to add two counters in your
   playground.

.. image:: 01_owl_components/double_counter.png
   :align: center

.. tip::
   By convention, most components code, template and css should have the same snake-cased name
   as the component. For example, if we have a `TodoList` component, its code should be in
   `todo_list.js`, `todo_list.xml` and if necessary, `todo_list.scss`

.. _tutorials/discover_js_framework/simple_card:

3. A simple `Card` component
============================

Components are really the most natural way to divide a complicated user interface into multiple
reusable pieces. But to make them truly useful, it is necessary to be able to communicate
some information between them. Let us see how a parent component can provide information to a
sub component by using attributes (most commonly known as `props <{OWL_PATH}/doc/reference/props.md>`_).

The goal of this exercise is to create a `Card` component, that takes two props: `title` and `content`.
For example, here is how it could be used:

.. code-block:: xml

   <Card title="'my title'" content="'some content'"/>

The above example should produce some html using bootstrap that look like this:

.. code-block:: html

         <div class="card d-inline-block m-2" style="width: 18rem;">
             <div class="card-body">
                 <h5 class="card-title">my title</h5>
                 <p class="card-text">
                  some content
                 </p>
             </div>
         </div>

#. Create a `Card` component
#. Import it in `Playground` and display a few cards in its template

.. image:: 01_owl_components/simple_card.png
   :align: center

4. Using `markup` to display html
=================================

If you used `t-esc` in the previous exercise, then you may have noticed that Owl automatically escapes
its content. For example, if you try to display some html like this: `<Card title="'my title'" content="this.html"/>`
with `this.html = "<div>some content</div>""`,
the resulting output will simply display the html as a string.

In this case, since the `Card` component may be used to display any kind of content, it makes sense
to allow the user to display some html. This is done with the
`t-out directive <{OWL_PATH}/doc/reference/templates.md#outputting-data>`_.

However, displaying arbitrary content as html is dangerous, it could be used to inject malicious code, so
by default, Owl will always escape a string unless it has been explicitely marked as safe with the `markup`
function.

#. Update `Card` to use `t-out`
#. Update `Playground` to import `markup`, and use it on some html values
#. Make sure that you see that normal strings are always escaped, unlike markuped strings.

.. note::

   The `t-esc` directive can still be used in Owl templates. It is slightly faster than `t-out`.

.. image:: 01_owl_components/markup.png
   :align: center

5. Props validation
===================

The `Card` component has an implicit API. It expects to receive two strings in its props: the `title`
and the `content`. Let us make that API more
explicit. We can add a props definition that will let Owl perform a validation step in `dev mode
<{OWL_PATH}/doc/reference/app.md#dev-mode>`_. You can activate the dev mode in the `App
configuration <{OWL_PATH}/doc/reference/app.md#configuration>`_ (but it is activated by default
on the `awesome_owl` playground).

It is a good practice to do props validation for every component.

#. Add `props validation <{OWL_PATH}/doc/reference/props.md#props-validation>`_ to the `Card`
   component.
#. Rename the `title` props into something else in the playground template, then check in the
   :guilabel:`Console` tab of your browser's dev tools that you can see an error.

6. The sum of two `Counter`
===========================

We saw in a previous exercise that `props` can be used to provide information from a parent
to a child component. Now, let us see how we can communicate information in the opposite
direction: in this exercise, we want to display two `Counter` components, and below them, the sum of
their values. So, the parent component (`Playground`) need to be informed whenever one of
the `Counter` value is changed.

This can be done by using a `callback prop <{OWL_PATH}/doc/reference/props.md#binding-function-props>`_:
a prop that is a function meant to be called back. The child component can choose to call
that function with any argument. In our case, we will simply add an optional `onChange` prop that will
be called whenever the `Counter` component is incremented.

#. Add prop validation to the `Counter` component: it should accept an optional `onChange`
   function prop.
#. Update the `Counter` component to call the `onChange` prop (if it exists) whenever it
   is incremented.
#. Modify the `Playground` component to maintain a local state value (`sum`), initially
   set to 2, and display it in its template
#. Implement an `incrementSum` method in `Playground`
#. Give that method as a prop to two (or more!) sub `Counter` components.

.. image:: 01_owl_components/sum_counter.png
   :align: center

.. important::

   There is a subtlety with callback props: they usually should be defined with the `.bind`
   suffix. See the `documentation <{OWL_PATH}/doc/reference/props.md#binding-function-props>`_.

7. A todo list
==============

Let us now discover various features of Owl by creating a todo list.  We need two components: a
`TodoList` component that will display a list of `TodoItem` components. The list of todos is a
state that should be maintained by the `TodoList`.

For this tutorial, a `todo` is an object that contains three values: an `id` (number), a `description`
(string) and a flag `isCompleted` (boolean):

.. code-block:: js

   { id: 3, description: "buy milk", isCompleted: false }

#. Create a `TodoList` and a `TodoItem` components.
#. The `TodoItem` component should receive a `todo` as a prop, and display its `id` and `description` in a `div`.
#. For now, hardcode the list of todos:

   .. code-block:: js

      // in TodoList
      this.todos = useState([{ id: 3, description: "buy milk", isCompleted: false }]);

#. Use `t-foreach <{OWL_PATH}/doc/reference/templates.md#loops>`_ to display each todo in a `TodoItem`.
#. Display a `TodoList` in the playground.
#. Add props validation to `TodoItem`.

.. image:: 01_owl_components/todo_list.png
   :align: center

.. tip::
   Since the `TodoList` and `TodoItem` components are so tightly coupled, it makes
   sense to put them in the same folder.

.. note::
   The `t-foreach` directive is not exactly the same in Owl as the QWeb python implementation: it
   requires a `t-key` unique value, so that Owl can properly reconcile each element.

8. Use dynamic attributes
=========================

For now, the `TodoItem` component does not visually show if the `todo` is completed. Let us do that by
using a `dynamic attributes <{OWL_PATH}/doc/reference/templates.md#dynamic-attributes>`_.

#. Add the Bootstrap classes `text-muted` and `text-decoration-line-through` on the `TodoItem` root element
   if it is completed.
#. Change the hardcoded `this.todos` value to check that it is properly displayed.

Even though the directive is named `t-att` (for attribute), it can be used to set a `class` value (and
html properties such as the `value` of an input).

.. image:: 01_owl_components/muted_todo.png
   :align: center

.. tip::

   Owl let you combine static class values with dynamic values. The following example will work as expected:

   .. code-block:: xml

      <div class="a" t-att-class="someExpression"/>

   See also: `Owl: Dynamic class attributes <{OWL_PATH}/doc/reference/templates.md#dynamic-class-attribute>`_

9. Adding a todo
================

So far, the todos in our list are hard-coded. Let us make it more useful by allowing the user to add
a todo to the list.

#. Remove the hardcoded values in the `TodoList` component:

   .. code-block:: javascript

      this.todos = useState([]);

#. Add an input above the task list with placeholder *Enter a new task*.
#. Add an `event handler <{OWL_PATH}/doc/reference/event_handling.md>`_ on the `keyup` event
   named `addTodo`.
#. Implement `addTodo` to check if enter was pressed (:code:`ev.keyCode === 13`), and in that
   case, create a new todo with the current content of the input as the description and clear the
   input of all content.
#. Make sure the todo has a unique id. It can be just a counter that increments at each todo.
#. Bonus point: don't do anything if the input is empty.


.. image:: 01_owl_components/create_todo.png
   :align: center

.. seealso::
   `Owl: Reactivity <{OWL_PATH}/doc/reference/reactivity.md>`_

Theory: Component lifecycle and hooks
=====================================

So far, we have seen one example of a hook function: `useState`. A `hook <{OWL_PATH}/doc/reference/hooks.md>`_
is a special function that *hook into* the internals of the component. In the case of
`useState`, it generates a proxy object linked to the current component. This is why
hook functions have to be called in the `setup` method, and no later!


.. flowchart LR

..     classDef hook fill:#ccf

..     subgraph "creation"
..     direction TB
..     A:::hook
..     B:::hook
..     M:::hook
..     A[setup]-->B
..     B[onWillStart] --> C(render)
..     C --> D("mount (in DOM)")
..     D --> M[onMounted]
..     end

..     subgraph updates
..     direction TB
..     E:::hook
..     F:::hook
..     H:::hook
..     E["(onWillUpdateProps)"] --> L(render)
..     L --> F[onWillPatch]
..     F --> G(patch DOM)
..     G --> H[onPatched]
..     end

..     subgraph destruction
..     direction TB
..     I:::hook
..     J:::hook
..     I[onWillUnmount] --> J[onWillDestroy]
..     J --> N(removed from DOM)

..     end

..     creation --> updates
..     updates --> destruction


.. figure:: 01_owl_components/component_lifecycle.svg
   :align: center
   :width: 50%


An Owl component goes through a lot of phases: it can be instantiated, rendered,
mounted, updated, detached, destroyed... This is the `component lifecycle <{OWL_PATH}/doc/reference/component.md#lifecycle>`_.
The figure above show the most important events in the life of a component (hooks are shown in purple).
Roughly speaking, a component is created, then updated (potentially many times), then is destroyed.

Owl provides a variety of built-in `hooks functions <{OWL_PATH}/doc/reference/hooks.md>`_. All of them have to be called in
the `setup` function. For example, if you want to execute some code when your component is mounted, you can use the `onMounted`
hook:

.. code-block:: javascript

   setup() {
     onMounted(() => {
       // do something here
     });
   }

.. tip::

   All hook functions start with `use` or `on`. For example: `useState` or `onMounted`.


10. Focusing the input
======================

Let's see how we can access the DOM with `t-ref <{OWL_PATH}/doc/reference/refs.md>`_ and `useRef
<{OWL_PATH}/doc/reference/hooks.md#useref>`_. The main idea is that you need to mark
the target element in the component template with a `t-ref`:

.. code-block:: xml

   <div t-ref="some_name">hello</div>

Then you can access it in the JS with the `useRef hook <{OWL_PATH}/doc/reference/hooks.md#useref>`_.
However, there is a problem if you think about it: the actual html element for a
component does not exist when the component is created. It only exists when the
component is mounted. But hooks have to be called in the `setup` method. So, `useRef`
return an object that contains a `el` (for element) key that is only defined when the
component is mounted.

.. code-block:: js

   setup() {
      this.myRef = useRef('some_name');
      onMounted(() => {
         console.log(this.myRef.el);
      });
   }


#. Focus the `input` from the previous exercise. This this should be done from the
   `TodoList` component (note that there is a `focus` method on the input html element).
#. Bonus point: extract the code into a specialized `hook <{OWL_PATH}/doc/reference/hooks.md>`_
   `useAutofocus` in a new :file:`awesome_owl/utils.js` file.

.. image:: 01_owl_components/autofocus.png
   :align: center

.. tip::

   Refs are usually suffixed by `Ref` to make it obvious that they are special objects:

   .. code-block:: js

      this.inputRef = useRef('input');

11. Toggling todos
==================

Now, let's add a new feature: mark a todo as completed. This is actually trickier than one might
think. The owner of the state is not the same as the component that displays it. So, the `TodoItem`
component needs to communicate to its parent that the todo state needs to be toggled. One classic
way to do this is by adding a `callback prop
<{OWL_PATH}/doc/reference/props.md#binding-function-props>`_ `toggleState`.

#. Add an input with the attribute :code:`type="checkbox"` before the id of the task, which must
   be checked if the state `isCompleted` is true.

   .. tip::
      Owl does not create attributes computed with the `t-att` directive if it evaluates to a
      falsy value.

#. Add a callback props `toggleState` to `TodoItem`.
#. Add a `change` event handler on the input in the `TodoItem` component and make sure it calls the
   `toggleState` function with the todo id.
#. Make it work!

.. image:: 01_owl_components/toggle_todo.png
   :align: center

12. Deleting todos
==================

The final touch is to let the user delete a todo.

#. Add a new callback prop `removeTodo` in `TodoItem`.
#. Insert :code:`<span class="fa fa-remove"/>` in the template of the `TodoItem` component.
#. Whenever the user clicks on it, it should call the `removeTodo` method.
#. Make it work!

   .. tip::
      If you're using an array to store your todo list, you can use the JavaScript `splice`
      function to remove a todo from it.

.. code-block::

   // find the index of the element to delete
   const index = list.findIndex((elem) => elem.id === elemId);
   if (index >= 0) {
         // remove the element at index from list
         list.splice(index, 1);
   }

.. image:: 01_owl_components/delete_todo.png
   :align: center

.. _tutorials/discover_js_framework/generic_card:

13. Generic `Card` with slots
=============================

In a :ref:`previous exercise <tutorials/discover_js_framework/simple_card>`, we built
a simple `Card` component. But it is honestly quite limited. What if we want
to display some arbitrary content inside a card, such as a sub-component? Well,
it does not work, since the content of the card is described by a string. It would
however be very convenient if we could describe the content as a piece of template.

This is exactly what Owl's `slot <{OWL_PATH}/doc/reference/slots.md>`_ system is designed
for: allowing to write generic components.

Let us modify the `Card` component to use slots:

#. Remove the `content` prop.
#. Use the default slot to define the body.
#. Insert a few cards with arbitrary content, such as a `Counter` component.
#. (bonus) Add prop validation.

.. image:: 01_owl_components/generic_card.png
   :align: center

.. seealso::
   `Bootstrap: documentation on cards <https://getbootstrap.com/docs/5.2/components/card/>`_

14. Minimizing card content
===========================

.. TODO: This exercise shows no new concept; it should probably be removed.

Finally, let's add a feature to the `Card` component, to make it more interesting: we
want a button to toggle its content (show it or hide it)

#. Add a state to the `Card` component to track if it is open (the default) or not
#. Add a `t-if` in the template to conditionally render the content
#. Add a button in the header, and modify the code to flip the state when the button is clicked

.. image:: 01_owl_components/toggle_card.png
   :scale: 90%
   :align: center


==================================================
SECTION: 02_build_a_dashboard.rst
PATH: developer/tutorials/discover_js_framework/02_build_a_dashboard.rst
==================================================

============================
Chapter 2: Build a dashboard
============================

The first part of this tutorial introduced you to most of Owl ideas. It is now time to learn
about the Odoo JavaScript framework in its entirety, as used by the web client.

.. graph TD
..     subgraph "Owl"
..         C[Component]
..         T[Template]
..         H[Hook]
..         S[Slot]
..         E[Event]
..     end

..     odoo[Odoo JavaScript framework] --> Owl

.. figure:: 02_build_a_dashboard/previously_learned.svg
   :align: center
   :width: 50%

To get started, you need a running Odoo server and a development environment setup. Before getting
into the exercises, make sure you have followed all the steps described in this
:ref:`tutorial introduction <tutorials/discover_js_framework/setup>`. For this chapter, we will start
from the empty dashboard provided by the `awesome_dashboard` addon. We will progressively add
features to it, using the Odoo JavaScript framework.

.. admonition:: Goal

   .. image:: 02_build_a_dashboard/overview_02.png
      :align: center

.. spoiler:: Solutions

   The solutions for each exercise of the chapter are hosted on the
   `official Odoo tutorials repository
   <https://github.com/odoo/tutorials/commits/{CURRENT_MAJOR_BRANCH}-discover-js-framework-solutions/awesome_dashboard>`_.

1. A new Layout
===============

Most screens in the Odoo web client uses a common layout: a control panel on top, with some buttons,
and a main content zone just below. This is done using the `Layout component
<{GITHUB_PATH}/addons/web/static/src/search/layout.js>`_, available in `@web/search/layout`.

#. Update the `AwesomeDashboard` component located in :file:`awesome_dashboard/static/src/` to use the
   `Layout` component. You can use
   :code:`{controlPanel: {} }` for the `display` props of
   the `Layout` component.
#. Add a `className` prop to `Layout`: `className="'o_dashboard h-100'"`
#. Add a `dashboard.scss` file in which you set the background-color of `.o_dashboard` to gray (or your
   favorite color)

Open http://localhost:8069/web, then open the :guilabel:`Awesome Dashboard` app, and see the
result.

.. image:: 02_build_a_dashboard/new_layout.png
   :align: center

.. seealso::

   - `Example: use of Layout in client action
     <{GITHUB_PATH}/addons/web/static/src/webclient/actions/reports/report_action.js>`_ and
     `template <{GITHUB_PATH}/addons/web/static/src/webclient/actions/reports/report_action.xml>`_
   - `Example: use of Layout in kanban view
     <{GITHUB_PATH}/addons/web/static/src/views/kanban/kanban_controller.xml>`_

.. _tutorials/discover_js_framework/services:

Theory: Services
================

In practice, every component (except the root component) may be destroyed at any time and replaced
(or not) with another component. This means that each component internal state is not persistent.
This is fine in many cases, but there certainly are situations where we want to keep some data around.
For example, all Discuss messages should not be reloaded every time we display a channel.

Also, it may happen that we need to write some code that is not a component. Maybe something that
process all barcodes, or that manages the user configuration (context, etc.).

The Odoo framework defines the idea of a :ref:`service <frontend/services>`, which is a persistent
piece of code that exports state and/or functions. Each service can depend on other services, and
components can import a service.

The following example registers a simple service that displays a notification every 5 seconds:

.. code-block:: js

   import { registry } from "@web/core/registry";

   const myService = {
       dependencies: ["notification"],
       start(env, { notification }) {
           let counter = 1;
           setInterval(() => {
               notification.add(`Tick Tock ${counter++}`);
           }, 5000);
       },
   };

   registry.category("services").add("myService", myService);

Services can be accessed by any component. Imagine that we have a service to maintain some shared
state:


.. code-block:: js

   import { registry } from "@web/core/registry";

   const sharedStateService = {
       start(env) {
           let state = {};
           return {
               getValue(key) {
                   return state[key];
               },
               setValue(key, value) {
                   state[key] = value;
               },
           };
       },
   };

   registry.category("services").add("shared_state", sharedStateService);

Then, any component can do this:

.. code-block:: js

   import { useService } from "@web/core/utils/hooks";

   setup() {
      this.sharedState = useService("shared_state");
      const value = this.sharedState.getValue("somekey");
      // do something with value
   }

2. Add some buttons for quick navigation
========================================

.. TODO: Add ref to the action service when it's documented.

One important service provided by Odoo is the `action` service: it can execute
all kind of standard actions defined by Odoo. For example, here is how one
component could execute an action by its xml id:

.. code-block:: js

   import { useService } from "@web/core/utils/hooks";
   ...
   setup() {
         this.action = useService("action");
   }
   openSettings() {
         this.action.doAction("base_setup.action_general_configuration");
   }
   ...

Let us now add two buttons to our control panel:

#. A button `Customers`, which opens a kanban view with all customers (this action already
   exists, so you should use `its xml id
   <https://github.com/odoo/odoo/blob/1f4e583ba20a01f4c44b0a4ada42c4d3bb074273/odoo/addons/base/views/res_partner_views.xml#L510>`_).

#. A button `Leads`, which opens a dynamic action on the `crm.lead` model with a list and a form
   view. Follow the example of `this use of the action service
   <https://github.com/odoo/odoo/blob/ef424a9dc22a5abbe7b0a6eff61cf113826f04c0/addons/account
   /static/src/components/journal_dashboard_activity/journal_dashboard_activity.js#L28-L35>`_.

.. image:: 02_build_a_dashboard/navigation_buttons.png
   :align: center

.. seealso::
   `Code: action service
   <{GITHUB_PATH}/addons/web/static/src/webclient/actions/action_service.js>`_

3. Add a dashboard item
=======================

Let us now improve our content.

#. Create a generic `DashboardItem` component that display its default slot in a nice card layout.
   It should take an optional `size` number props, that default to `1`. The width should be
   hardcoded to `(18*size)rem`.
#. Add two cards to the dashboard. One with no size, and the other with a size of 2.

.. image:: 02_build_a_dashboard/dashboard_item.png
   :align: center

.. seealso::
   `Owl's slot system <{OWL_PATH}/doc/reference/slots.md>`_

4. Call the server, add some statistics
=======================================

Let's improve the dashboard by adding a few dashboard items to display *real* business data.
The `awesome_dashboard` addon provides a `/awesome_dashboard/statistics` route that is meant
to return some interesting information.

To call a specific controller, we need to use the :ref:`rpc <frontend/services/rpc>` function.
It only exports a single function that perform the request: :code:`rpc(route, params, settings)`.
A basic request could look like this:

.. code-block:: js

   import { rpc } from "@web/core/network/rpc";
   // ...

   setup() {
      onWillStart(async () => {
         const result = await rpc("/my/controller", {a: 1, b: 2});
      })
      // ...
   }

#. Update `Dashboard` so that it uses the `rpc` function and call the statistics route `/awesome_dashboard/statistics`.
#. Display a few cards in the dashboard containing:

   - Number of new orders this month
   - Total amount of new orders this month
   - Average amount of t-shirt by order this month
   - Number of cancelled orders this month
   - Average time for an order to go from 'new' to 'sent' or 'cancelled'

.. image:: 02_build_a_dashboard/statistics.png
   :align: center

.. seealso::
   `Code: rpc <{GITHUB_PATH}/addons/web/static/src/core/network/rpc.js>`_

5. Cache network calls, create a service
========================================

If you open the :guilabel:`Network` tab of your browser's dev tools, you will see that the call to
`/awesome_dashboard/statistics` is done every time the client action is displayed. This is because the
`onWillStart` hook is called each time the `Dashboard` component is mounted. But in this case, we
would prefer to do it only the first time, so we actually need to maintain some state outside of the
`Dashboard` component. This is a nice use case for a service!

#. Register and import a new `awesome_dashboard.statistics` service.
#. It should provide a function `loadStatistics` that, once called, performs the actual rpc, and
   always return the same information.
#. Use the `memoize <https://github.com/odoo/odoo/blob/1f4e583ba20a01f4c44b0a4ada42c4d3bb074273/
   addons/web/static/src/core/utils/functions.js#L11>`_ utility function from
   `@web/core/utils/functions` that allows caching the statistics.
#. Use this service in the `Dashboard` component.
#. Check that it works as expected.

.. seealso::
   - `Example: simple service <{GITHUB_PATH}/addons/web/static/src/core/network/http_service.js>`_
   - `Example: service with a dependency
     <{GITHUB_PATH}/addons/web/static/src/core/user_service.js>`_

6. Display a pie chart
======================

Everyone likes charts (!), so let us add a pie chart in our dashboard. It will display the
proportions of t-shirts sold for each size: S/M/L/XL/XXL.

For this exercise, we will use `Chart.js <https://www.chartjs.org/>`_. It is the chart library used
by the graph view. However, it is not loaded by default, so we will need to either add it to our
assets bundle, or lazy load it. Lazy loading is usually better since our users will not have to load
the chartjs code every time if they don't need it.

#. Create a `PieChart` component.
#. In its `onWillStart` method, load chartjs, you can use the `loadJs
   <https://github.com/odoo/odoo/blob/1f4e583ba20a01f4c44b0a4ada42c4d3bb074273/
   addons/web/static/src/core/assets.js#L23>`_ function to load
   :file:`/web/static/lib/Chart/Chart.js`.
#. Use the `PieChart` component in a `DashboardItem` to display a `pie chart
   <https://www.chartjs.org/docs/2.8.0/charts/doughnut.html>`_ that shows the
   quantity for each sold t-shirts in each size (that information is available in the
   `/statistics` route). Note that you can use the `size` property to make it look larger.
#. The `PieChart` component will need to render a canvas, and draw on it using `chart.js`.
#. Make it work!

.. image:: 02_build_a_dashboard/pie_chart.png
   :align: center
   :scale: 80%

.. seealso::
   - `Example: lazy loading a js file
     <https://github.com/odoo/odoo/blob/1f4e583ba20a01f4c44b0a4ada42c4d3bb074273/
     addons/web/static/src/views/graph/graph_renderer.js#L57>`_
   - `Example: rendering a chart in a component
     <https://github.com/odoo/odoo/blob/1f4e583ba20a01f4c44b0a4ada42c4d3bb074273/
     addons/web/static/src/views/graph/graph_renderer.js#L618>`_

7. Real life update
===================

Since we moved the data loading in a cache, it never updates. But let us say that we
are looking at fast moving data, so we want to periodically (for example, every 10min) reload
fresh data.

This is quite simple to implement, with a `setTimeout` or `setInterval` in the statistics service.
However, here is the tricky part: if the dashboard is currently being displayed, it should be
updated immediately.

To do that, one can use a `reactive` object: it is just like the proxy returned by `useState`,
but not linked to any component. A component can then do a `useState` on it to subscribe to its
changes.


#. Update the statistics service to reload data every 10 minutes (to test it, use 10s instead!)
#. Modify it to return a `reactive <{OWL_PATH}/doc/reference/reactivity.md#reactive>`_ object.
   Reloading data should update the reactive object in place.
#. The `Dashboard` component can now use it with a `useState`

.. seealso::
  - `Documentation on reactivity <{OWL_PATH}/doc/reference/reactivity.md>`_
  - `Example: Use of reactive in a service
    <https://github.com/odoo/odoo/blob/bb1b5aed9b6d96ae1b0d044341812b51ed72a05d/
    addons/mail/static/src/discuss/call/common/rtc_service.js#L124>`_

8. Lazy loading the dashboard
=============================

Let us imagine that our dashboard is getting quite big, and is only of interest to some
of our users. In that case, it could make sense to lazy load our dashboard, and all
related assets, so we only pay the cost of loading the code when we actually want to
look at it.

One way to do this is to use `LazyComponent` (from `@web/core/assets`) as an intermediate
that will load an asset bundle before displaying our component.

.. example::

   :file:`example_action.js`:

   .. code-block:: javascript

      export class ExampleComponentLoader extends Component {
          static components = { LazyComponent };
          static template = xml`
              <LazyComponent bundle="'example_module.example_assets'" Component="'ExampleComponent'" />
          `;
      }

      registry.category("actions").add("example_module.example_action", ExampleComponentLoader);

#. Move all dashboard assets into a sub folder :file:`/dashboard` to make it easier to
   add to a bundle.
#. Create a `awesome_dashboard.dashboard` assets bundle containing all content of
   the :file:`/dashboard` folder.
#. Modify :file:`dashboard.js` to register itself to the `lazy_components` registry instead of `actions`.
#. In :file:`src/dashboard_action.js`, create an intermediate component that uses `LazyComponent` and
   register it to the `actions` registry.

9. Making our dashboard generic
===============================

So far, we have a nice working dashboard. But it is currently hardcoded in the dashboard
template. What if we want to customize our dashboard? Maybe some users have different
needs and want to see other data.

So, the next step is to make our dashboard generic: instead of hard-coding its content
in the template, it can just iterate over a list of dashboard items. But then, many
questions come up: how to represent a dashboard item, how to register it, what data
should it receive, and so on. There are many different ways to design such a system,
with different trade-offs.

For this tutorial, we will say that a dashboard item is an object with the following structure:

.. code-block:: js

   const item = {
      id: "average_quantity",
      description: "Average amount of t-shirt",
      Component: StandardItem,
      // size and props are optionals
      size: 3,
      props: (data) => ({
         title: "Average amount of t-shirt by order this month",
         value: data.average_quantity
      }),
   };

The `description` value will be useful in a later exercise to show the name of items that the
user can add to their dashboard. The `size` number is optional, and simply describes
the size of the dashboard item that will be displayed. Finally, the `props` function is optional.
If not given, we will simply give the `statistics` object as data. But if it is defined, it will
be used to compute specific props for the component.

The goal is to replace the content of the dashboard with the following snippet:

.. code-block:: xml

   <t t-foreach="items" t-as="item" t-key="item.id">
      <DashboardItem size="item.size || 1">
         <t t-set="itemProp" t-value="item.props ? item.props(statistics) : {'data': statistics}"/>
         <t t-component="item.Component" t-props="itemProp" />
      </DashboardItem>
   </t>

Note that the above example features two advanced features of Owl: dynamic components and dynamic props.

We currently have two kinds of item components: number cards with a title and a number, and pie cards with
some label and a pie chart.

#. Create and implement two components: `NumberCard` and `PieChartCard`, with the corresponding props.
#. Create a file :file:`dashboard_items.js` in which you define and export a list of items, using `NumberCard`
   and `PieChartCard` to recreate our current dashboard.
#. Import that list of items in our `Dashboard` component, add it to the component, and update the template
   to use a `t-foreach` like shown above.

   .. code-block:: js

         setup() {
            this.items = items;
         }

And now, our dashboard template is generic!

10. Making our dashboard extensible
===================================

However, the content of our item list is still hardcoded. Let us fix that by using a registry:

#. Instead of exporting a list, register all dashboard items in a `awesome_dashboard` registry
#. Import all the items of the `awesome_dashboard` registry in the `Dashboard` component

The dashboard is now easily extensible. Any other Odoo addon that wants to register a new item to the
dashboard can just add it to the registry.

11. Add and remove dashboard items
==================================

Let us see how we can make our dashboard customizable. To make it simple, we will save the user
dashboard configuration in the local storage so that it is persistent, but we don't have to deal
with the server for now.

The dashboard configuration will be saved as a list of removed item ids.

#. Add a button in the control panel with a gear icon to indicate that it is a settings button.
#. Clicking on that button should open a dialog.
#. In that dialog, we want to see a list of all existing dashboard items, each with a checkbox.
#. There should be a `Apply` button in the footer. Clicking on it will build a list of all item ids
   that are unchecked.
#. We want to store that value in the local storage.
#. And modify the `Dashboard` component to filter the current items by removing the ids of items
   from the configuration.

.. image:: 02_build_a_dashboard/items_configuration.png
   :width: 80%
   :align: center

12. Going further
=================

Here is a list of some small improvements you could try to do if you have the time:

#. Make sure your application can be :ref:`translated <reference/translations>` (with
   `env._t`).
#. Clicking on a section of the pie chart should open a list view of all orders that have the
   corresponding size.
#. Save the content of the dashboard in a user setting on the server!
#. Make it responsive: in mobile mode, each card should take 100% of the width.

.. seealso::
   - `Example: use of env._t function
     <https://github.com/odoo/odoo/blob/457836d19b865fc2f6b9dc3216c1de715e0d7c31/
     addons/account/static/src/components/bills_upload/bills_upload.js#L116>`_
   - `Code: translation code in web/
     <https://github.com/odoo/odoo/blob/457836d19b865fc2f6b9dc3216c1de715e0d7c31/
     addons/web/static/src/core/l10n/translation.js#L22>`_


==================================================
SECTION: discover_js_framework.rst
PATH: developer/tutorials/discover_js_framework.rst
==================================================

:show-content:

==========================
Discover the web framework
==========================

.. toctree::
    :titlesonly:
    :glob:

    discover_js_framework/*

This two parts tutorial is designed to introduce you to the basics of the web framework. Whether
you are new to the framework or have some prior experience, this tutorial will provide you with a
solid foundation for using the web framework in your projects.

The first part covers the basics of Owl components, which
are a key part of the web framework. Owl components are reusable UI components that can be used
to build complex web interfaces quickly and efficiently. We will explore how to create and use Owl
components in Odoo. Then, in the second part of this tutorial, we focus on creating a dashboard using various
features of Odoo. Dashboards are an essential part of any web application, and provide a nice starting
point to use and interact with the Odoo codebase.

This tutorial assumes that you have some basic knowledge of development with Odoo in general
(models, controllers, QWeb, ...). If you are new to Odoo, we recommend that you start with the
:doc:`/developer/tutorials/server_framework_101` tutorial before proceeding with this one.

.. note::

    Each chapter of this tutorial is an independant project.  If you feel comfortable with Owl, you can
    start directly with chapter 2.

.. _tutorials/discover_js_framework/setup:

Setup
=====

#. Clone the `official Odoo tutorials repository <https://github.com/odoo/tutorials>`_ and switch to
   the branch `{CURRENT_MAJOR_BRANCH}`.
#. Add the cloned repository to your :option:`--addons-path <odoo-bin --addons-path>`.
#. Start a new Odoo database and install the modules `awesome_owl` (for chapter 1) and `awesome_dashboard`
   (for chapter 2).

Content
=======

- :doc:`discover_js_framework/01_owl_components`
- :doc:`discover_js_framework/02_build_a_dashboard`
