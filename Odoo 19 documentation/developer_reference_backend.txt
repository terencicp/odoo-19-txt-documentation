

==================================================
SECTION: backend.rst
PATH: developer/reference/backend.rst
==================================================

:nosearch:
:hide-page-toc:

================
Server framework
================

.. toctree::
   :titlesonly:

   backend/orm
   backend/data
   backend/actions
   backend/reports
   backend/module
   backend/security
   backend/performance
   backend/testing
   backend/http
   backend/mixins


==================================================
SECTION: actions.rst
PATH: developer/reference/backend/actions.rst
==================================================

=======
Actions
=======

Actions define the behavior of the system in response to user actions: login,
action button, selection of an invoice, ...

Actions can be stored in the database or returned directly as dictionaries in
e.g. button methods. All actions share two mandatory attributes:

``type``
    the category of the current action, determines which fields may be
    used and how the action is interpreted
``name``
    short user-readable description of the action, may be displayed in the
    client's interface

A client can get actions in 4 forms:

*  ``False``
      if any action dialog is currently open, close it
*  A string
      if a :ref:`client action <reference/actions/client>` matches, interpret as
      a client action's tag, otherwise treat as a number
*  A number
      read the corresponding action record from the database, may be a database
      identifier or an :term:`external id`
*  A dictionary
      treat as a client action descriptor and execute

.. _reference/bindings:

Bindings
========

Aside from their two mandatory attributes, all actions also share *optional*
attributes used to present an action in an arbitrary model's contextual menu:

``binding_model_id``
    specifies which model the action is bound to

    .. note:: For Server Actions, use ``model_id``.

``binding_type``
    specifies the type of binding, which is mostly which contextual menu the
    action will appear under

    ``action`` (default)
        Specifies that the action will appear in the :menuselection:`Action`
        contextual menu of the bound model.
    ``report``
        Specifies that the action will appear in the :menuselection:`Print`
        contextual menu of the bound model.
``binding_view_types``
    a comma-separated list of view types for which the action appears in the
    contextual menu, mostly "list" and / or "form". Defaults to ``list,form``
    (both list and form )

.. _reference/actions/window:

Window Actions (``ir.actions.act_window``)
==========================================

The most common action type, used to present visualisations of a model through
:doc:`views <../user_interface/view_records>`: a window action defines a set of view types
(and possibly specific views) for a model (and possibly specific record of the
model).

Its fields are:

``res_model``
    model to present views for
``views``
    a list of ``(view_id, view_type)`` pairs. The second element of each pair
    is the category of the view (list, form, graph, ...) and the first is
    an optional database id (or ``False``). If no id is provided, the client
    should fetch the default view of the specified type for the requested
    model (this is automatically done by
    :meth:`~odoo.models.Model.fields_view_get`). The first type of the
    list is the default view type and will be open by default when the action
    is executed. Each view type should be present at most once in the list
``res_id`` (optional)
    if the default view is ``form``, specifies the record to load (otherwise
    a new record should be created)
``search_view_id`` (optional)
    ``(id, name)`` pair, ``id`` is the database identifier of a specific
    search view to load for the action. Defaults to fetching the default
    search view for the model
``target`` (optional)
    whether the views should be open in the main content area (``current``),
    in full screen mode (``fullscreen``) or in a dialog/popup (``new``). Use
    ``main`` instead of ``current`` to clear the breadcrumbs. Defaults to
    ``current``.
``context`` (optional)
    additional context data to pass to the views
``domain`` (optional)
    filtering domain to implicitly add to all view search queries
``limit`` (optional)
    number of records to display in lists by default. Defaults to 80 in the
    web client

For instance, to open customers (partner with the ``customer`` flag set) with
list and form views::

    {
        "type": "ir.actions.act_window",
        "res_model": "res.partner",
        "views": [[False, "list"], [False, "form"]],
        "domain": [["customer", "=", true]],
    }

Or to open the form view of a specific product (obtained separately) in a new
dialog::

    {
        "type": "ir.actions.act_window",
        "res_model": "product.product",
        "views": [[False, "form"]],
        "res_id": a_product_id,
        "target": "new",
    }

In-database window actions have a few different fields which should be ignored
by clients, mostly to use in composing the ``views`` list:

``view_mode`` (default= ``list,form`` )
    comma-separated list of view types as a string (/!\\ No spaces /!\\). All of these types will be
    present in the generated ``views`` list (with at least a ``False`` view_id)
``view_ids``
    M2M\ [#notquitem2m]_ to view objects, defines the initial content of
    ``views``

    .. note:: Act_window views can also be defined cleanly through ``ir.actions.act_window.view``.

        If you plan to allow multiple views for your model, prefer using
        ir.actions.act_window.view instead of the action ``view_ids``

        .. code-block:: xml

            <record model="ir.actions.act_window.view" id="test_action_tree">
               <field name="sequence" eval="1"/>
               <field name="view_mode">list</field>
               <field name="view_id" ref="view_test_tree"/>
               <field name="act_window_id" ref="test_action"/>
            </record>

``view_id``
    specific view added to the ``views`` list in case its type is part of the
    ``view_mode`` list and not already filled by one of the views in
    ``view_ids``

These are mostly used when defining actions from :ref:`reference/data`:

.. code-block:: xml

    <record model="ir.actions.act_window" id="test_action">
        <field name="name">A Test Action</field>
        <field name="res_model">some.model</field>
        <field name="view_mode">graph</field>
        <field name="view_id" ref="my_specific_view"/>
    </record>

will use the "my_specific_view" view even if that's not the default view for
the model.

The server-side composition of the ``views`` sequence is the following:

* get each ``(id, type)`` from ``view_ids`` (ordered by ``sequence``)
* if ``view_id`` is defined and its type isn't already filled, append its
  ``(id, type)``
* for each unfilled type in ``view_mode``, append ``(False, type)``

.. todo::

    * ``usage``?
    * ``groups_id``?
    * ``filter``?

.. [#notquitem2m] technically not an M2M: adds a sequence field and may be
                  composed of just a view type, without a view id.

.. _reference/actions/url:

URL Actions (``ir.actions.act_url``)
====================================

Allow opening a URL (website/web page) via an Odoo action. Can be customized
via two fields:

``url``
    the address to open when activating the action
``target`` (default= ``new``)
    the available values are :

    * ``new``: opens the URL in a new window/page
    * ``self``: opens the URL in the current window/page (replaces the actual content)
    * ``download``: redirects to a download URL


    example:

::

    {
        "type": "ir.actions.act_url",
        "url": "https://odoo.com",
        "target": "self",
    }

This will replace the current content section by the Odoo home page.

.. _reference/actions/server:

Server Actions (``ir.actions.server``)
======================================

.. autoclass:: odoo.addons.base.models.ir_actions.IrActionsServer

Allow triggering complex server code from any valid action location. Only
two fields are relevant to clients:

``id``
    the in-database identifier of the server action to run
``context`` (optional)
    context data to use when running the server action

In-database records are significantly richer and can perform a number of
specific or generic actions based on their ``state``. Some fields (and
corresponding behaviors) are shared between states:

``model_id``
    Odoo model linked to the action.

``state``

* ``code``: Executes python code given through the ``code`` argument.

* ``object_create``: Creates a new record of model ``crud_model_id`` following ``fields_lines`` specifications.

* ``object_write``: Updates the current record(s) following ``fields_lines`` specifications

* ``multi``: Executes several actions given through the ``child_ids`` argument.

State fields
------------

Depending on its state, the behavior is defined through different fields.
The concerned state is given after each field.

``code`` (code)
  Specify a piece of Python code to execute when the action is called

  .. code-block:: xml

      <record model="ir.actions.server" id="print_instance">
          <field name="name">Res Partner Server Action</field>
          <field name="model_id" ref="model_res_partner"/>
          <field name="state">code</field>
          <field name="code">
              raise Warning(record.name)
          </field>
      </record>

  .. note::

      The code segment can define a variable called ``action``, which will be
      returned to the client as the next action to execute:

      .. code-block:: xml

          <record model="ir.actions.server" id="print_instance">
              <field name="name">Res Partner Server Action</field>
              <field name="model_id" ref="model_res_partner"/>
              <field name="state">code</field>
              <field name="code">
                  if record.some_condition():
                      action = {
                          "type": "ir.actions.act_window",
                          "view_mode": "form",
                          "res_model": record._name,
                          "res_id": record.id,
                      }
              </field>
          </record>

      will ask the client to open a form for the record if it fulfills some
      condition

  ..  This tends to be the only action type created from :ref:`data files
      <reference/data>`, other types aside from
      :ref:`reference/actions/server/multi` are simpler than Python code to define
      from the UI, but not from :ref:`data files <reference/data>`.

``crud_model_id`` (create)(required)
    model in which to create a new record
``link_field_id`` (create)
    many2one to ``ir.model.fields``, specifies the current record's m2o field
    on which the newly created record should be set (models should match)

``fields_lines`` (create/write)
    fields to override when creating or copying the record.
    :class:`~odoo.fields.One2many` with the fields:

    ``col1``
        ``ir.model.fields`` to set in the concerned model
        (``crud_model_id`` for creates, ``model_id`` for updates)
    ``value``
        value for the field, interpreted via ``type``
    ``type`` (value|reference|equation)
        If ``value``, the ``value`` field is interpreted as a literal value
        (possibly converted), if ``equation`` the ``value`` field is
        interpreted as a Python expression and evaluated

``child_ids`` (multi)
    Specify the multiple sub-actions (``ir.actions.server``) to enact in state multi.
    If sub-actions themselves return actions, the last
    one will be returned to the client as the multi's own next action

.. _reference/actions/server/context:

Evaluation context
------------------

A number of keys are available in the evaluation context of or surrounding
server actions:

* ``model`` model object linked to the action via ``model_id``
* ``record``/``records`` record/recorset on which the action is triggered, can be void.
* ``env`` Odoo Environment
* ``datetime``, ``dateutil``, ``time``, ``timezone`` corresponding Python modules
* ``log: log(message, level='info')`` logging function to record debug information in ir.logging table
* ``Warning`` constructor for the ``Warning`` exception

.. _reference/actions/report:

Report Actions (``ir.actions.report``)
======================================

Triggers the printing of a report.

If you define your report through a `<record>` instead of a `<report>` tag and
want the action to show up in the Print menu of the model's views, you will
also need to specify ``binding_model_id`` from :ref:`reference/bindings`. It's
not necessary to set ``binding_type`` to ``report``, since
``ir.actions.report`` will implicitly default to that.


``name`` (mandatory)
    used as the file name if ``print_report_name`` is not specified.
    Otherwise, only useful as a mnemonic/description of the report
    when looking for one in a list of some sort
``model`` (mandatory)
    the model your report will be about
``report_type`` (default=qweb-pdf)
    either ``qweb-pdf`` for PDF reports or ``qweb-html`` for HTML
``report_name`` (mandatory)
    the name (:term:`external id`) of the qweb template used to render the report
``print_report_name``
    python expression defining the name of the report.
``groups_id``
    :class:`~odoo.fields.Many2many` field to the groups allowed to view/use
    the current report
``multi``
    if set to ``True``, the action will not be displayed on a form view.
``paperformat_id``
    :class:`~odoo.fields.Many2one` field to the paper format you wish to
    use for this report (if not specified, the company format will be used)
``attachment_use``
    if set to ``True``, the report is only generated once the first time it is
    requested, and re-printed from the stored report afterwards instead of
    being re-generated every time.

    Can be used for reports which must only be generated once (e.g. for legal
    reasons)
``attachment``
    python expression that defines the name of the report; the record is
    accessible as the variable ``object``

.. _reference/actions/client:

Client Actions (``ir.actions.client``)
======================================

Triggers an action implemented entirely in the client.

``tag``
    the client-side identifier of the action, an arbitrary string which
    the client should know how to react to
``params`` (optional)
    a Python dictionary of additional data to send to the client, alongside
    the client action tag
``target`` (optional)
    whether the client action should be open in the main content area
    (``current``), in full screen mode (``fullscreen``) or in a dialog/popup
    (``new``). Use ``main`` instead of ``current`` to clear the breadcrumbs.
    Defaults to ``current``.

::

    {
        "type": "ir.actions.client",
        "tag": "pos.ui"
    }

tells the client to start the Point of Sale interface, the server has no idea
how the POS interface works.

.. seealso::
   - :ref:`Tutorial: Client Actions <howtos/web/client_actions>`

.. _reference/actions/cron:

Scheduled Actions (``ir.cron``)
===============================

.. automodule:: odoo.addons.base.models.ir_cron

Actions triggered automatically on a predefined frequency.

``name``
    Name of the scheduled action (Mainly used in log display)

``interval_number``
    Number of *interval_type* uom between two executions of the action

``interval_type``
    Unit of measure of frequency interval (``minutes``, ``hours``, ``days``, ``weeks``, ``months``)

``model_id``
    Model on which this action will be called

``code``
    Code content of the action.
    Can be a simple call to the model's method :

    .. code-block:: python

        model.<method_name>()

``nextcall``
    Next planned execution date of this action (date/time format)

``priority``
    Priority of the action when executing multiple actions at the same time


Writing cron functions
----------------------

When running a scheduled action, it's recommended that you try to batch the
progress in order to avoid blocking a worker for a long period of time and
possibly run into timeout exceptions. Therefore, you should split the processing
so that each call makes progress on some of the work to be done.

When writing such a function, you should focus on processing a single batch.
A batch should process one or many records and should generally take no more
than *a few seconds*.

Work is committed by the framework after each batch. The framework will
call the function as many times as necessary to process the remaining work.
Do not reschedule yourself the job.

.. automethod:: IrCron._commit_progress

.. code-block:: python

    def _cron_do_something(self, *, limit=300):  # limit: allows for tweaking
        domain = [('state', '=', 'ready')]
        records = self.search(domain, limit=limit)
        records.do_something()
        # notify progression
        remaining = 0 if len(records) == limit else self.search_count(domain)
        self.env['ir.cron']._commit_progress(len(records), remaining=remaining)

In some cases, you may want to share resources between multiple batches or
manage the loop yourself to handle exceptions.
In this case, you should inform the scheduler of the progress of your work
by calling :func:`IrCron._commit_progress` and checking the result. The progress
function returns the number of seconds remaining for the call; if it is 0, you
must return as soon as possible.

The following is an example of how to commit after each record that is
processed, while keeping the connection open.

.. code-block:: python

    def _cron_do_something(self):
        assert self.env.context.get('cron_id'), "Run only inside cron jobs"
        domain = [('state', '=', 'ready')]
        records = self.search(domain)
        self.env['ir.cron']._commit_progress(remaining=len(records))

        with open_some_connection() as conn:
            for record in records:
                # You may have other needs; we do some common stuff here:
                # - lock record (also checks existence)
                # - prefetch: break prefetch in this case, we process one record
                # - filtered_domain: record may have changed
                record = record.try_lock_for_update().filtered_domain(domain)
                if not record:
                    continue
                # Processing the batch here...
                try
                    record.do_something(conn)
                    if not self.env['ir.cron']._commit_progress(1):
                        break
                except Exception:
                    # if you handle exceptions, the default stategy is to
                    # rollback first the error
                    self.env.cr.rollback()
                    _logger.warning(...)
                    # you may commit some status using _commit_progress

Running cron functions
----------------------

You should not call cron functions directly.
There are two ways to run functions:

.. automethod:: IrCron.method_direct_trigger
.. automethod:: IrCron._trigger

Testing of a cron function should be done by calling
:func:`IrCron.method_direct_trigger` in the registry test mode.

Security
--------

To avoid a fair usage of resources among scheduled actions, some security measures ensure the
correct functioning of your scheduled actions.

- If a scheduled action encounters an error or a timeout three consecutive times,
  it will skip its current execution and be considered as failed.
- If a scheduled action fails its execution five consecutive times over a period of at least
  seven days, it will be deactivated and will notify the DB admin.
- A hard-limit exists for the cron execution at the database level after which
  the process executing cron jobs is killed.


==================================================
SECTION: changelog.rst
PATH: developer/reference/backend/orm/changelog.rst
==================================================

.. _reference/orm/changelog:

=========
Changelog
=========

Odoo version 19.0
=================

- Add support for ``GROUPING SETS`` for pivot views.
  See `#194413 <https://github.com/odoo/odoo/pull/194413>`_.
- Adding support for dynamic dates in domains.
  See `#216665 <https://github.com/odoo/odoo/pull/216665>`_.
- Deprecated `odoo.osv` in `#217708 <https://github.com/odoo/odoo/pull/217708>`_.
- Deprecated `record._cr`, `record._context`, `record._uid` in `#193636 <https://github.com/odoo/odoo/pull/193636>`_.


Odoo Online version 18.4
========================

- The `reinit` option is added to the CLI to reinitialize modules.
  See `#206408 <https://github.com/odoo/odoo/pull/206408>`_.
- Possibility to write and combine custom domains for injecting arbitrary SQL.
  See `#205208 <https://github.com/odoo/odoo/pull/205208>`_.

Odoo Online version 18.3
========================

- Domain optimization is applied before executing `Fields.search` methods.
  All equalities are handled consistently: `=` is equivalent to `in`.
  See `#191549 <https://github.com/odoo/odoo/pull/191549>`_.
- New cron API for notifying progress with batch commits.
  See `#197781 <https://github.com/odoo/odoo/pull/197781>`_.
- Demo data no longer loaded by default.
  See `#194585 <https://github.com/odoo/odoo/pull/194585>`_.

Odoo Online version 18.2
========================

- `read_group` has been deprecated in favor of `_read_group` for backend usage and of
  `formatted_read_group` as formatted public API. See `#163300 <https://github.com/odoo/odoo/pull/163300>`_.
- `@api.private` is added to distinguish public Python methods from methods exposed for RPC calls.
  See `#195402 <https://github.com/odoo/odoo/pull/195402>`_.
- Native namespaces for ``odoo`` module `PEP-420 <https://peps.python.org/pep-0420/>`_.
  See `#195664 <https://github.com/odoo/odoo/pull/195664>`_.

Odoo Online version 18.1
========================

- New `odoo.domain` and `odoo.Domain` API for domain manipulation.
  See `#170009 <https://github.com/odoo/odoo/pull/170009>`_.
- Declare constraints and indexes as model attributes with `#175783 <https://github.com/odoo/odoo/pull/175783>`_.
- The `json` controllers have been renamed to `jsonrpc`. They are called the same, only the
  `type` in the python files changed. See `#183636 <https://github.com/odoo/odoo/pull/183636>`_.

Odoo version 18.0
=================

- Searching by name is now implemented as `_search_display_name` like all other fields.
  See `#174967 <https://github.com/odoo/odoo/pull/174967>`_.
- New methods to check access rights and rules now combine both access rights
  and rules: `check_access`, `has_access` and `_filtered_access`.
  See `#179148 <https://github.com/odoo/odoo/pull/179148>`_.
- Translations are made available from the `Environment` with `#174844 <https://github.com/odoo/odoo/pull/174844>`_.

Odoo Online version 17.4
========================

- The internal operator `inselect` is removed. The alternative is to use `in`
  with a Query or SQL object. `#171371 <https://github.com/odoo/odoo/pull/171371>`_.


Odoo Online version 17.3
========================

- We can now group by date parts numbers in `read_group`, `_read_group` and domains with `#159528 <https://github.com/odoo/odoo/pull/159528>`_.


Odoo Online version 17.2
========================

- The :attr:`group_operator` attribute of :class:`~odoo.fields.Field` is renamed into
  :attr:`aggregator` with `#127353 <https://github.com/odoo/odoo/pull/127353>`_.
- We can now group/aggregate/order by related no-store field with
  `#127353 <https://github.com/odoo/odoo/pull/127353>`_.

Odoo Online version 17.1
========================

- Method :meth:`~odoo.models.Model._flush_search` has been deprecated with
  `#144747 <https://github.com/odoo/odoo/pull/144747>`_.
  The flushing of fields is now done by :meth:`~odoo.api.Environment.execute_query`,
  and is based on metadata put in the :class:`~odoo.tools.SQL` object by
  :meth:`~odoo.models.BaseModel._search` and other low-level ORM methods that
  build such objects.  Those methods are also responsible for checking the access
  rights on the fields that are used in the SQL object.

Odoo version 17.0
=================

- Introduce an :class:`~odoo.tools.SQL` wrapper object to make SQL composition
  easier and safer with respect to SQL injections. Methods of the ORM now use it
  internally. Introduced by `#134677 <https://github.com/odoo/odoo/pull/134677>`_.

Odoo Online version 16.4
========================

- Method :meth:`~odoo.models.Model.name_get` has been deprecated with
  `#122085 <https://github.com/odoo/odoo/pull/122085>`_.
  Read field `display_name` instead.

Odoo Online version 16.3
========================

- Method :meth:`~odoo.models.Model._read_group` has a new signature with
  `#110737 <https://github.com/odoo/odoo/pull/110737>`_

Odoo Online version 16.2
========================

- Refactor the implementation of searching and reading methods to be able to
  combine both in a minimal number of SQL queries. We introduce two new methods
  :meth:`~odoo.models.Model.search_fetch` and :meth:`~odoo.models.Model.fetch`
  that take advantage of the combination. More details can be found on the pull
  request `#112126 <https://github.com/odoo/odoo/pull/112126>`_.

Odoo version 16.0
=================

- Translations for translated fields are stored as JSONB values with
  `#97692 <https://github.com/odoo/odoo/pull/97692>`_
  and `#101115 <https://github.com/odoo/odoo/pull/101115>`_.
  Code translations are no longer stored into the database.
  They become static and are extracted from the PO files when needed.
- :meth:`~odoo.models.Model.search_count` takes the :attr:`limit` argument into account with `#95589 <https://github.com/odoo/odoo/pull/95589>`_.
  It limits the number of records to count, improving performance when a partial result is acceptable.

Odoo Online version 15.4
========================

- New API for flushing to the database and invalidating the cache with
  `#87527 <https://github.com/odoo/odoo/pull/87527>`_.
  New methods have been added to `odoo.models.Model` and `odoo.api.Environment`,
  and are less confusing about what is actually done in each case.
  See the section :ref:`SQL Execution <reference/orm/sql>`.

Odoo Online version 15.3
========================

- The argument `args` is renamed to `domain` for :meth:`~odoo.models.Model.search`, :meth:`~odoo.models.Model.search_count`
  and :meth:`~odoo.models.Model._search`. `#83687 <https://github.com/odoo/odoo/pull/83687>`_
- :meth:`~odoo.models.Model.filtered_domain` conserves the order of the current recordset. `#83687 <https://github.com/odoo/odoo/pull/83687>`_
- :meth:`~odoo.models.Model.browse` does not accept :class:`str` as `ids`. `#83687 <https://github.com/odoo/odoo/pull/83687>`_
- The methods :meth:`~odoo.models.Model.fields_get_keys` and :meth:`~odoo.models.Model.get_xml_id` on :class:`~odoo.models.Model` are deprecated. `#83687 <https://github.com/odoo/odoo/pull/83687>`_
- The method :meth:`~odoo.models.Model._mapped_cache` is removed. `#83687 <https://github.com/odoo/odoo/pull/83687>`_
- Remove the :attr:`limit` attribute of :class:`~odoo.fields.One2many` and :class:`~odoo.fields.Many2many`. `#83687 <https://github.com/odoo/odoo/pull/83687>`_

Odoo Online version 15.2
========================

- Specific index types on fields:  With `#83274 <https://github.com/odoo/odoo/pull/83274>`_ and
  `#83015 <https://github.com/odoo/odoo/pull/83015>`_, developers can now define what type of
  indexes can be used on fields by PostgreSQL. See the :ref:`index property <reference/fields>` of
  `odoo.fields.Field`.
- The :attr:`_sequence` attribute of :class:`~odoo.models.Model` is removed. Odoo lets PostgreSQL use the default sequence of the primary key. `#82727 <https://github.com/odoo/odoo/pull/82727>`_
- The method :meth:`~odoo.models.Model._write` does not raise an error for non-existing records. `#82727 <https://github.com/odoo/odoo/pull/82727>`_
- The :attr:`column_format` and :attr:`deprecated` attributes of :class:`~odoo.fields.Field` are removed. `#82727 <https://github.com/odoo/odoo/pull/82727>`_


==================================================
SECTION: data.rst
PATH: developer/reference/backend/data.rst
==================================================


.. _reference/data:

==========
Data Files
==========

Odoo is greatly data-driven, and a big part of modules definition is thus
the definition of the various records it manages: UI (menus and views),
security (access rights and record rules), reports and plain data are all
defined via records.

Structure
=========

The main way to define data in Odoo is via XML data files: The broad structure
of an XML data file is the following:

* Any number of operation elements within the root element ``odoo``

.. code-block:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <!-- the root elements of the data file -->
    <odoo>
        <operation/>
        ...
    </odoo>

Data files are executed sequentially, operations can only refer to the result
of operations defined previously

.. note::

    If the content of the data file is expected to be applied only once, you
    can specify the odoo flag ``noupdate`` set to 1.  If part of
    the data in the file is expected to be applied once, you can place this part
    of the file in a <data noupdate="1"> domain.

    .. code-block:: xml

        <odoo>
            <data noupdate="1">
                <!-- Only loaded when installing the module (odoo-bin -i module) -->
                <operation/>
            </data>

            <!-- (Re)Loaded at install and update (odoo-bin -i/-u) -->
            <operation/>
        </odoo>

Core operations
===============

.. _reference/data/record:

``record``
----------

``record`` appropriately defines or updates a database record, it has the
following attributes:

``model`` (required)
    name of the model to create (or update)
``id``
    the :term:`external identifier` for this record. It is strongly
    recommended to provide one

    * for record creation, allows subsequent definitions to either modify or
      refer to this record
    * for record modification, the record to modify
``context``
    context to use when creating the record
``forcecreate``
    in update mode whether the record should be created if it doesn't exist

    Requires an :term:`external id`, defaults to ``True``.

``field``
---------

Each record can be composed of ``field`` tags, defining values to set when
creating the record. A ``record`` with no ``field`` will use all default
values (creation) or do nothing (update).

A ``field`` has a mandatory ``name`` attribute, the name of the field to set,
and various methods to define the value itself:

Nothing
    if no value is provided for the field, an implicit ``False`` will be set
    on the field. Can be used to clear a field, or avoid using a default value
    for the field.
``search``
    for :ref:`relational fields <reference/fields/relational>`, should be
    a :ref:`domain <reference/orm/domains>` on the field's model.

    Will evaluate the domain, search the field's model using it and set the
    search's result as the field's value. Will only use the first result if
    the field is a :class:`~odoo.fields.Many2one`
``ref``
    if a ``ref`` attribute is provided, its value must be a valid
    :term:`external id`, which will be looked up and set as the field's value.

    Mostly for :class:`~odoo.fields.Many2one` and
    :class:`~odoo.fields.Reference` fields
``type``
    if a ``type`` attribute is provided, it is used to interpret and convert
    the field's content. The field's content can be provided through an
    external file using the ``file`` attribute, or through the node's body.

    Available types are:

    ``xml``, ``html``
        extracts the ``field``'s children as a single document, evaluates
        any :term:`external id` specified with the form ``%(external_id)s``.
        ``%%`` can be used to output actual *%* signs.
    ``file``
        ensures that the field content is a valid file path in the current
        model, saves the pair :samp:`{module},{path}` as the field value
    ``char``
        sets the field content directly as the field's value without
        alterations
    ``base64``
        base64_-encodes the field's content, useful combined with the ``file``
        *attribute* to load e.g. image data into attachments
    ``int``
        converts the field's content to an integer and sets it as the field's
        value
    ``float``
        converts the field's content to a float and sets it as the field's
        value
    ``list``, ``tuple``
        should contain any number of ``value`` elements with the same
        properties as ``field``, each element resolves to an item of a
        generated tuple or list, and the generated collection is set as the
        field's value
``eval``
    for cases where the previous methods are unsuitable, the ``eval``
    attributes simply evaluates whatever Python expression it is provided and
    sets the result as the field's value.

    The evaluation context contains various modules (``time``, ``datetime``,
    ``timedelta``, ``relativedelta``), a function to resolve :term:`external
    identifiers` (``ref``) and the model object for the current field if
    applicable (``obj``)

``delete``
----------

The ``delete`` tag can remove any number of records previously defined. It
has the following attributes:

``model`` (required)
    the model in which a specified record should be deleted
``id``
    the :term:`external id` of a record to remove
``search``
    a :ref:`domain <reference/orm/domains>` to find records of the model to
    remove

``id`` and ``search`` are exclusive

``function``
------------

The ``function`` tag calls a method on a model, with provided parameters.
It has two mandatory parameters ``model`` and ``name`` specifying respectively
the model and the name of the method to call.

Parameters can be provided using ``eval`` (should evaluate to a sequence of
parameters to call the method with) or ``value`` elements (see ``list``
values).

.. code-block:: xml

    <odoo>
        <data noupdate="1">
            <record id="partner_1" model="res.partner">
                <field name="name">Odude</field>
            </record>

            <function model="res.partner" name="send_inscription_notice"
                eval="[[ref('partner_1'), ref('partner_2')]]"/>

            <function model="res.users" name="send_vip_inscription_notice">
                <function eval="[[('vip','=',True)]]" model="res.partner" name="search"/>
            </function>
        </data>

        <record id="model_form_view" model="ir.ui.view">
            ...
        </record>
    </odoo>

.. ignored assert

.. _reference/data/shortcuts:

Shortcuts
=========

Because some important structural models of Odoo are complex and involved,
data files provide shorter alternatives to defining them using
:ref:`record tags <reference/data/record>`:

``menuitem``
------------

Defines an ``ir.ui.menu`` record with a number of defaults and fallbacks:

.. rst-class:: o-definition-list

``parent``
    * If a ``parent`` attribute is set, it should be the :term:`external id`
      of an other menu item, used as the new item's parent
    * If no ``parent`` is provided, tries to interpret the ``name`` attribute
      as a ``/``-separated sequence of menu names and find a place in the menu
      hierarchy. In that interpretation, intermediate menus are automatically
      created
    * Otherwise the menu is defined as a "top-level" menu item (*not* a menu
      with no parent)
``name``
    If no ``name`` attribute is specified, tries to get the menu name from
    a linked action if any. Otherwise uses the record's ``id``
``groups``
    A ``groups`` attribute is interpreted as a comma-separated sequence of
    :term:`external identifiers` for ``res.groups`` models. If an
    :term:`external identifier` is prefixed with a minus (``-``), the group
    is *removed* from the menu's groups
``action``
    if specified, the ``action`` attribute should be the :term:`external id`
    of an action to execute when the menu is open
``id``
    the menu item's :term:`external id`

.. _reference/data/template:

``template``
------------

Creates a :ref:`QWeb view <reference/view_architectures/qweb>` requiring only the ``arch``
section of the view, and allowing a few *optional* attributes:

.. rst-class:: o-definition-list

``id``
    the view's :term:`external identifier`
``name``, ``inherit_id``, ``priority``
    same as the corresponding field on ``ir.ui.view`` (nb: ``inherit_id``
    should be an :term:`external identifier`)
``primary``
    if set to ``True`` and combined with a ``inherit_id``, defines the view
    as a primary
``groups``
    comma-separated list of group :term:`external identifiers`
``active``
    indicates whether the view is active. If inactive, its XPath rules wonâ€™t be
    applied, which is thus mainly relevant for views with ``inherit_id``

    .. note::

        Defining the ``active`` value on the ``<template>`` node itself comes
        with a subtlety: it is only considered when creating the record. On
        subsequent updates, the view will be updated but not its ``active``
        status.

.. _reference/data/asset:

``asset``
---------

Creates an :ref:`asset <frontend/assets/ir_asset>`.

.. example::
    .. code-block:: xml

        <asset id="website_something.some_style_asset" name="Some style asset" active="False">
            <bundle>web.assets_frontend</bundle>
            <path>website_something/static/src/some_style.scss</path>
        </asset>

**Attributes**

.. rst-class:: o-definition-list

``id``
    the asset's :term:`external identifier`
``name``
    same as the corresponding field on ``ir.asset``
``active`` (optional)
    indicates whether the asset is active

    .. note::

        Same as ``<template>``, defining the ``active`` value on the ``<asset>``
        node itself comes with a subtlety: it is only considered when creating
        the record. On subsequent updates, the asset will be updated but not its
        ``active`` status.

**Child elements**

.. rst-class:: o-definition-list

``<bundle>`` and ``<path>``
    required to define the corresponding fields on ``ir.asset`` (the
    ``directive`` field can be controlled using the ``directive`` attribute on
    the ``<bundle>`` child)

``<field>`` (optional)
    just like in a normal ``<record>``, to define more field values as needed

.. _reference/data/csvdatafiles:

CSV data files
==============

XML data files are flexible and self-descriptive, but very verbose when
creating a number of simple records of the same model in bulk.

For this case, data files can also use csv_, this is often the case for
:ref:`access rights <reference/security/acl>`:

* the file name is :file:`{model_name}.csv`
* the first row lists the fields to write, with the special field ``id``
  for :term:`external identifiers` (used for creation or update)
* each row thereafter creates a new record

Here's the first lines of the data file defining country states
``res.country.state.csv``

.. literalinclude:: data/res.country.state.csv
    :language: text

rendered in a more readable format:

.. csv-table::
    :file: data/res.country.state.csv
    :header-rows: 1
    :class: table-striped table-hover table-sm

For each row (record):

* the first column is the :term:`external id` of the record to create or
  update
* the second column is the :term:`external id` of the country object to link
  to (country objects must have been defined beforehand)
* the third column is the ``name`` field for ``res.country.state``
* the fourth column is the ``code`` field for ``res.country.state``

.. _base64: https://tools.ietf.org/html/rfc3548.html#section-3
.. _csv: https://en.wikipedia.org/wiki/Comma-separated_values


==================================================
SECTION: http.rst
PATH: developer/reference/backend/http.rst
==================================================


.. _reference/controllers:

===============
Web Controllers
===============

Controllers
===========

Controllers need to provide extensibility, much like
:class:`~odoo.models.Model`, but can't use the same mechanism as the
pre-requisites (a database with loaded modules) may not be available yet (e.g.
no database created, or no database selected).

Controllers thus provide their own extension mechanism, separate from that of
models:

Controllers are created by :ref:`inheriting <python:tut-inheritance>` from :class:`~odoo.http.Controller`.
Routes are defined through methods decorated with :func:`~odoo.http.route`::

    class MyController(odoo.http.Controller):
        @route('/some_url', auth='public')
        def handler(self):
            return stuff()

To *override* a controller, :ref:`inherit <python:tut-inheritance>` from its
class and override relevant methods, re-exposing them if necessary::

    class Extension(MyController):
        @route()
        def handler(self):
            do_before()
            return super(Extension, self).handler()

* decorating with :func:`~odoo.http.route` is necessary to keep the method
  (and route) visible: if the method is redefined without decorating, it
  will be "unpublished"
* the decorators of all methods are combined, if the overriding method's
  decorator has no argument all previous ones will be kept, any provided
  argument will override previously defined ones e.g.::

    class Restrict(MyController):
        @route(auth='user')
        def handler(self):
            return super(Restrict, self).handler()

  will change ``/some_url`` from public authentication to user (requiring a
  log-in)

API
===

.. _reference/http/routing:

Routing
-------

.. autodecorator:: odoo.http.route

.. _reference/http/request:

Request
-------

The request object is automatically set on :data:`odoo.http.request` at
the start of the request.

.. autoclass:: odoo.http.Request
    :members:
    :member-order: bysource

.. autoclass:: odoo.http.JsonRPCDispatcher
    :members:
    :member-order: bysource
.. autoclass:: odoo.http.HttpDispatcher
    :members:
    :member-order: bysource

Response
--------

.. autoclass:: odoo.http.Response
    :members:
    :member-order: bysource

    .. maybe set this to document all the fine methods on Werkzeug's Response
       object? (it works)
       :inherited-members:


==================================================
SECTION: mixins.rst
PATH: developer/reference/backend/mixins.rst
==================================================


.. _reference/mixins:

=========================
Mixins and Useful Classes
=========================

Odoo implements some useful classes and mixins that make it easy for you to add
often-used behaviours on your objects. This guide will details most of them, with
examples and use cases.

.. _reference/mixins/mail:

Messaging features
==================

.. _reference/mixins/mail/chatter:

Messaging integration
---------------------

Basic messaging system
~~~~~~~~~~~~~~~~~~~~~~

Integrating messaging features to your model is extremely easy. Simply inheriting
the ``mail.thread`` mixin and adding the chatter ``<chatter/>`` element to your form
view will get you up and running in no time. The chatter element supports some
options to control form behavior:

* ``open_attachments``: Shows attachment section expanded by default
* ``reload_on_attachment``: Reloads form view when attachments are added/removed
* ``reload_on_follower``: Reloads form view when followers are updated
* ``reload_on_post``: Reloads form view when new messages are posted

.. example::

    Let's create a simplistic model representing a business trip. Since organizing
    this kind of trip usually involves a lot of people and a lot of discussion, let's
    add support for message exchange on the model.

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread']
            _description = 'Business Trip'

            name = fields.Char()
            partner_id = fields.Many2one('res.partner', 'Responsible')
            guest_ids = fields.Many2many('res.partner', 'Participants')

    In the form view:

    .. code-block:: xml

        <record id="business_trip_form" model="ir.ui.view">
            <field name="name">business.trip.form</field>
            <field name="model">business.trip</field>
            <field name="arch" type="xml">
                <form string="Business Trip">
                    <!-- Your usual form view goes here
                    ...
                    Then comes chatter integration with options you might want to set -->
                    <chatter open_attachments="True"/>
                </form>
            </field>
        </record>

Once you've added chatter support on your model, users can easily add messages
or internal notes on any record of your model; every one of those will send a
notification (to all followers for messages, to employee (*base.group_user*)
users for internal notes). If your mail gateway and catchall address are correctly
configured, these notifications will be sent by e-mail and can be replied-to directly
from your mail client; the automatic routing system will route the answer to the
correct thread.

Server-side, some helper functions are there to help you easily send messages and
to manage followers on your record:

.. rubric:: Posting messages

.. method:: message_post(self, body='', subject=None, message_type='notification', subtype=None, parent_id=False, attachments=None, **kwargs)

    Post a new message in an existing thread, returning the new
    mail.message ID.

    :param str | Markup body: body of the message. Will be escaped if `str`. Use
        a :class:`~markupsafe.Markup` object for HTML content.
    :param str message_type: see mail_message.message_type field
    :param int parent_id: handle reply to a previous message by adding the
        parent partners to the message in case of private discussion
    :param list(tuple(str,str)) attachments: list of attachment tuples in the form
        ``(name,content)``, where content is NOT base64 encoded
    :param bool body_is_html: indicates whether `body` should be treated as HTML, even if `str`.
    :param `\**kwargs`: extra keyword arguments will be used as default column values for the
          new mail.message record
    :return: ID of newly created mail.message
    :rtype: int

.. method:: message_post_with_view(views_or_xmlid, **kwargs):

    Helper method to send a mail / post a message using a view_id to
    render using the ir.qweb engine. This method is stand alone, because
    there is nothing in template and composer that allows to handle
    views in batch. This method will probably disappear when templates
    handle ir ui views.

    :param str or ``ir.ui.view`` record: external id or record of the view that
        should be sent

.. method:: message_post_with_template(template_id, **kwargs)

    Helper method to send a mail with a template

    :param template_id: the id of the template to render to create the body of the message
    :param `\**kwargs`: parameter to create a mail.compose.message wizard (which inherit from mail.message)

.. rubric:: Receiving messages

These methods are called when a new e-mail is processed by the mail gateway. These
e-mails can either be new thread (if they arrive via an :ref:`alias <reference/mixins/mail/alias>`)
or simply replies from an existing thread. Overriding them allows you to set values
on the thread's record depending on some values from the email itself (i.e. update
a date or an e-mail address, add CC's addresses as followers, etc.).

.. method:: message_new(msg_dict, custom_values=None)

    Called by ``message_process`` when a new message is received
    for a given thread model, if the message did not belong to
    an existing thread.

    The default behavior is to create a new record of the corresponding
    model (based on some very basic info extracted from the message).
    Additional behavior may be implemented by overriding this method.

    :param dict msg_dict: a map containing the email details and
        attachments. See ``message_process`` and ``mail.message.parse`` for details
    :param dict custom_values: optional dictionary of additional
        field values to pass to create() when creating the new thread record;
        be careful, these values may override any other values coming from
        the message
    :rtype: int
    :return: the id of the newly created thread object

.. method:: message_update(msg_dict, update_vals=None)

    Called by ``message_process`` when a new message is received
    for an existing thread. The default behavior is to update the record
    with ``update_vals`` taken from the incoming email.

    Additional behavior may be implemented by overriding this
    method.

    :param dict msg_dict: a map containing the email details and attachments;
        see ``message_process`` and ``mail.message.parse()`` for details.
    :param dict update_vals: a dict containing values to update records given
        their ids; if the dict is None or is void, no write operation is performed.
    :return: True

.. rubric:: Followers management

.. method:: message_subscribe(partner_ids=None, channel_ids=None, subtype_ids=None, force=True)

    Add partners to the records followers.

    :param list(int) partner_ids: IDs of the partners that will be subscribed
        to the record
    :param list(int) channel_ids: IDs of the channels that will be subscribed
        to the record
    :param list(int) subtype_ids: IDs of the subtypes that the channels/partners
        will be subscribed to (defaults to the default subtypes if ``None``)
    :param force: if True, delete existing followers before creating new one
        using the subtypes given in the parameters
    :return: Success/Failure
    :rtype: bool


.. method:: message_unsubscribe(partner_ids=None, channel_ids=None)

    Remove partners from the record's followers.

    :param list(int) partner_ids: IDs of the partners that will be subscribed
        to the record
    :param list(int) channel_ids: IDs of the channels that will be subscribed
        to the record
    :return: True
    :rtype: bool


.. method:: message_unsubscribe_users(user_ids=None)

    Wrapper on message_subscribe, using users.

    :param list(int) user_ids: IDs of the users that will be unsubscribed
        to the record; if None, unsubscribe the current user instead.
    :return: True
    :rtype: bool

Logging changes
~~~~~~~~~~~~~~~

The ``mail`` module adds a powerful tracking system on fields, allowing you
to log changes to specific fields in the record's chatter. To add tracking
to a field, simple set the tracking attribute to True.

.. example::

    Let's track changes on the name and responsible of our business trips:

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread']
            _description = 'Business Trip'

            name = fields.Char(tracking=True)
            partner_id = fields.Many2one('res.partner', 'Responsible',
                                         tracking=True)
            guest_ids = fields.Many2many('res.partner', 'Participants')

    From now on, every change to a trip's name or responsible will log a note
    on the record. The ``name`` field will be displayed in the notification as
    well to give more context about the notification (even if the name did not
    change).

Subtypes
~~~~~~~~

Subtypes give you more granular control over messages. Subtypes act as a classification
system for notifications, allowing subscribers to a document to customize the
subtype of notifications they wish to receive.

Subtypes are created as data in your module; the model has the following fields:

``name`` (mandatory) - :class:`~odoo.fields.Char`
    name of the subtype, will be displayed in the notification customization
    popup
``description`` - :class:`~odoo.fields.Char`
    description that will be added in the message posted for this
    subtype. If void, the name will be added instead
``internal`` - :class:`~odoo.fields.Boolean`
    messages with internal subtypes will be visible only by employees,
    aka members of the ``base.group_user`` group
``parent_id`` - :class:`~odoo.fields.Many2one`
    link subtypes for automatic subscription; for example project subtypes are
    linked to task subtypes through this link. When someone is subscribed to
    a project, he will be subscribed to all tasks of this project with
    subtypes found using the parent subtype
``relation_field`` - :class:`~odoo.fields.Char`
    as an example, when linking project and tasks subtypes, the relation
    field is the project_id field of tasks
``res_model`` - :class:`~odoo.fields.Char`
    model the subtype applies to; if False, this subtype applies to all models
``default`` - :class:`~odoo.fields.Boolean`
    whether the subtype is activated by default when subscribing
``sequence`` - :class:`~odoo.fields.Integer`
    used to order subtypes in the notification customization popup
``hidden`` - :class:`~odoo.fields.Boolean`
    whether the subtype is hidden in the notification customization popup


Interfacing subtypes with field tracking allows to subscribe to different kind
of notifications depending on what might interest users. To do this, you
can override the ``_track_subtype()`` function:

.. method:: _track_subtype(init_values)

    Give the subtype triggered by the changes on the record according
    to values that have been updated.

    :param dict init_values: the original values of the record; only modified fields
                        are present in the dict
    :returns: a subtype's full external id or False if no subtype is triggered


.. example::

    Let's add a ``state`` field on our example class and trigger a notification
    with a specific subtype when this field change values.

    First, let's define our subtype:

    .. code-block:: xml

        <record id="mt_state_change" model="mail.message.subtype">
            <field name="name">Trip confirmed</field>
            <field name="res_model">business.trip</field>
            <field name="default" eval="True"/>
            <field name="description">Business Trip confirmed!</field>
        </record>


    Then, we need to override the ``track_subtype()`` function. This function
    is called by the tracking system to know which subtype should be used depending
    on the change currently being applied. In our case, we want to use our shiny new
    subtype when the ``state`` field changes from *draft* to *confirmed*:

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread']
            _description = 'Business Trip'

            name = fields.Char(tracking=True)
            partner_id = fields.Many2one('res.partner', 'Responsible',
                                         tracking=True)
            guest_ids = fields.Many2many('res.partner', 'Participants')
            state = fields.Selection([('draft', 'New'), ('confirmed', 'Confirmed')],
                                     tracking=True)

            def _track_subtype(self, init_values):
                # init_values contains the modified fields' values before the changes
                #
                # the applied values can be accessed on the record as they are already
                # in cache
                self.ensure_one()
                if 'state' in init_values and self.state == 'confirmed':
                    return self.env.ref('my_module.mt_state_change')
                return super(BusinessTrip, self)._track_subtype(init_values)

Customizing notifications
~~~~~~~~~~~~~~~~~~~~~~~~~

When sending notifications to followers, it can be quite useful to add buttons in
the template to allow quick actions directly from the e-mail. Even a simple button
to link directly to the record's form view can be useful; however in most cases
you don't want to display these buttons to portal users.

The notification system allows customizing notification templates in the following
ways:

- Display *Access Buttons*: these buttons are visible at the top of the notification
  e-mail and allow the recipient to directly access the form view of the record
- Display *Follow Buttons*: these buttons allow the recipient to
  directly quickly subscribe from the record
- Display *Unfollow Buttons*: these buttons allow the recipient to
  directly quickly unsubscribe from the record
- Display *Custom Action Buttons*: these buttons are calls to specific routes
  and allow you to make some useful actions directly available from the e-mail (i.e.
  converting a lead to an opportunity, validating an expense sheet for an
  Expense Manager, etc.)

These buttons settings can be applied to different groups that you can define
yourself by overriding the function ``_notify_get_groups``.

.. method:: _notify_get_groups(message, groups)

    Give the subtype triggered by the changes on the record according
    to values that have been updated.

    :param ``record`` message: ``mail.message`` record currently being sent
    :param list(tuple) groups: list of tuple of the form (group_name, group_func,group_data) where:

        group_name
          is an identifier used only to be able to override and manipulate
          groups. Default groups are ``user`` (recipients linked to an employee user),
          ``portal`` (recipients linked to a portal user) and ``customer`` (recipients not
          linked to any user). An example of override use would be to add a group
          linked to a res.groups like Hr Officers to set specific action buttons to
          them.
        group_func
          is a function pointer taking a partner record as parameter. This
          method will be applied on recipients to know whether they belong to a given
          group or not. Only first matching group is kept. Evaluation order is the
          list order.
        group_data
          is a dict containing parameters for the notification email with the following
          possible keys - values:

          - has_button_access
              whether to display Access <Document> in email. True by default for
              new groups, False for portal / customer.
          - button_access
              dict with url and title of the button
          - has_button_follow
              whether to display Follow in email (if recipient is not currently
              following the thread). True by default for new groups, False for
              portal / customer.
          - button_follow
              dict with url and title of the button
          - has_button_unfollow
              whether to display Unfollow in email (if recipient is currently following the thread).
              True by default for new groups, False for portal / customer.
          - button_unfollow
              dict with url and title of the button
          - actions
              list of action buttons to display in the notification email.
              Each action is a dict containing url and title of the button.

    :returns: a subtype's full external id or False if no subtype is triggered


The urls in the actions list can be generated automatically by calling the
``_notify_get_action_link()`` function:


.. method:: _notify_get_action_link(self, link_type, **kwargs)

    Generate a link for the given type on the current record (or on a specific
    record if the kwargs ``model`` and ``res_id`` are set).

    :param str link_type: link type to be generated; can be any of these values:

        ``view``
          link to form view of the record
        ``assign``
          assign the logged user to the ``user_id`` field of
          the record (if it exists)
        ``follow``
          self-explanatory
        ``unfollow``
          self-explanatory
        ``method``
          call a method on the record; the method's name should be
          provided as the kwarg ``method``
        ``new``
          open an empty form view for a new record; you can specify
          a specific action by providing its id (database id or fully resolved
          external id) in the kwarg ``action_id``

    :returns: link of the type selected for the record
    :rtype: str

.. example::

    Let's add a custom button to the Business Trip state change notification;
    this button will reset the state to Draft and will be only visible to a member
    of the (imaginary) group Travel Manager (``business.group_trip_manager``)

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread', 'mail.alias.mixin']
            _description = 'Business Trip'

            # Pevious code goes here

            def action_cancel(self):
                self.write({'state': 'draft'})

            def _notify_get_groups(self, message, groups):
                """ Handle Trip Manager recipients that can cancel the trip at the last
                minute and kill all the fun. """
                groups = super(BusinessTrip, self)._notify_get_groups(message, groups)

                self.ensure_one()
                if self.state == 'confirmed':
                    app_action = self._notify_get_action_link('method',
                                        method='action_cancel')
                    trip_actions = [{'url': app_action, 'title': _('Cancel')}]

                new_group = (
                    'group_trip_manager',
                    lambda partner: any(
                        user.sudo().has_group('business.group_trip_manager')
                        for user in partner.user_ids
                    ),
                    {'actions': trip_actions},
                )

                return [new_group] + groups


    Note that that I could have defined my evaluation function outside of this
    method and define a global function to do it instead of a lambda, but for
    the sake of being more brief and less verbose in these documentation files
    that can sometimes be boring, I choose the former instead of the latter.

Overriding defaults
~~~~~~~~~~~~~~~~~~~

There are several ways you can customize the behaviour of ``mail.thread`` models,
including (but not limited to):

``_mail_post_access`` - :class:`~odoo.models.Model`  attribute
    the required access rights to be able to post a message on the model; by
    default a ``write`` access is needed, can be set to ``read`` as well

Context keys:
    These context keys can be used to somewhat control ``mail.thread`` features
    like auto-subscription or field tracking during calls to ``create()`` or
    ``write()`` (or any other method where it may be useful).

    - ``mail_create_nosubscribe``: at create or message_post, do not subscribe
      the current user to the record thread
    - ``mail_create_nolog``: at create, do not log the automatic '<Document>
      created' message
    - ``mail_notrack``: at create and write, do not perform the value tracking
      creating messages
    - ``tracking_disable``: at create and write, perform no MailThread features
      (auto subscription, tracking, post, ...)
    - ``mail_auto_delete``: auto delete mail notifications; True by default
    - ``mail_notify_force_send``: if less than 50 email notifications to send,
      send them directly instead of using the queue; True by default
    - ``mail_notify_user_signature``: add the current user signature in
      email notifications; True by default


.. _reference/mixins/mail/alias:

Mail alias
----------

Aliases are configurable email addresses that are linked to a specific record
(which usually inherits the ``mail.alias.mixin`` model) that will create new records when
contacted via e-mail. They are an easy way to make your system accessible from
the outside, allowing users or customers to quickly create records in your
database without needing to connect to Odoo directly.

Aliases vs. Incoming Mail Gateway
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Some people use the Incoming Mail Gateway for this same purpose. You still need
a correctly configured mail gateway to use aliases, however a single
catchall domain will be sufficient since all routing will be done inside Odoo.
Aliases have several advantages over Mail Gateways:

* Easier to configure
    * A single incoming gateway can be used by many aliases; this avoids having
      to configure multiple emails on your domain name (all configuration is done
      inside Odoo)
    * No need for System access rights to configure aliases
* More coherent
    * Configurable on the related record, not in a Settings submenu
* Easier to override server-side
    * Mixin model is built to be extended from the start, allowing you to
      extract useful data from incoming e-mails more easily than with a mail
      gateway.


Alias support integration
~~~~~~~~~~~~~~~~~~~~~~~~~

Aliases are usually configured on a parent model which will then create specific
record when contacted by e-mail. For example, Project have aliases to create tasks
or issues, Sales Team have aliases to generate Leads.

.. note:: The model that will be created by the alias **must** inherit the
          ``mail_thread`` model.

Alias support is added by inheriting ``mail.alias.mixin``; this mixin will
generate a new ``mail.alias`` record for each record of the parent class that
gets created (for example, every ``project.project`` record having its ``mail.alias``
record initialized on creation).

.. note:: Aliases can also be created manually and supported by a simple
    :class:`~odoo.fields.Many2one` field. This guide assumes you wish a
    more complete integration with automatic creation of the alias, record-specific
    default values, etc.

Unlike ``mail.thread`` inheritance, the ``mail.alias.mixin`` **requires** some
specific overrides to work correctly. These overrides will specify the values
of the created alias, like the kind of record it must create and possibly
some default values these records may have depending on the parent object:

.. method:: _get_alias_model_name(vals)

    Return the model name for the alias. Incoming emails that are not
    replies to existing records will cause the creation of a new record
    of this alias model. The value may depend on ``vals``, the dict of
    values passed to ``create`` when a record of this model is created.

    :param vals dict: values of the newly created record that will holding
                      the alias
    :return: model name
    :rtype: str

.. method:: _get_alias_values()

    Return values to create an alias, or to write on the alias after its
    creation. While not completely mandatory, it is usually required to make
    sure that newly created records will be linked to the alias' parent (i.e.
    tasks getting created in the right project) by setting a dictionary of
    default values in the alias' ``alias_defaults`` field.

    :return: dictionary of values that will be written to the new alias
    :rtype: dict

The ``_get_alias_values()`` override is particularly interesting as it allows you
to modify the behaviour of your aliases easily. Among the fields that can be set
on the alias, the following are of particular interest:

``alias_name`` - :class:`~odoo.fields.Char`
    name of the email alias, e.g. 'jobs' if you want to catch emails for
    <jobs@example.odoo.com>
``alias_user_id`` - :class:`~odoo.fields.Many2one` (``res.users``)
    owner of records created upon receiving emails on this alias;
    if this field is not set the system will attempt to find the right owner
    based on the sender (From) address, or will use the Administrator account
    if no system user is found for that address
``alias_defaults`` - :class:`~odoo.fields.Text`
    Python dictionary that will be evaluated to provide
    default values when creating new records for this alias
``alias_force_thread_id`` - :class:`~odoo.fields.Integer`
    optional ID of a thread (record) to which all incoming messages will be
    attached, even if they did not reply to it; if set, this will disable the
    creation of new records completely
``alias_contact`` - :class:`~odoo.fields.Selection`
    Policy to post a message on the document using the mailgateway

    - *everyone*: everyone can post
    - *partners*: only authenticated partners
    - *followers*: only followers of the related document or members of following channels

Note that aliases make use of :ref:`delegation inheritance <reference/orm/inheritance>`,
which means that while the alias is stored in another table, you have
access to all these fields directly from your parent object. This allows
you to make your alias easily configurable from the record's form view.

.. example::

    Let's add aliases on our business trip class to create expenses on the fly via
    e-mail.

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread', 'mail.alias.mixin']
            _description = 'Business Trip'

            name = fields.Char(tracking=True)
            partner_id = fields.Many2one('res.partner', 'Responsible',
                                         tracking=True)
            guest_ids = fields.Many2many('res.partner', 'Participants')
            state = fields.Selection([('draft', 'New'), ('confirmed', 'Confirmed')],
                                     tracking=True)
            expense_ids = fields.One2many('business.expense', 'trip_id', 'Expenses')
            alias_id = fields.Many2one('mail.alias', string='Alias', ondelete="restrict",
                                       required=True)

            def _get_alias_model_name(self, vals):
            """ Specify the model that will get created when the alias receives a message """
                return 'business.expense'

            def _get_alias_values(self):
            """ Specify some default values that will be set in the alias at its creation """
                values = super(BusinessTrip, self)._get_alias_values()
                # alias_defaults holds a dictionary that will be written
                # to all records created by this alias
                #
                # in this case, we want all expense records sent to a trip alias
                # to be linked to the corresponding business trip
                values['alias_defaults'] = {'trip_id': self.id}
                # we only want followers of the trip to be able to post expenses
                # by default
                values['alias_contact'] = 'followers'
                return values

        class BusinessExpense(models.Model):
            _name = 'business.expense'
            _inherit = ['mail.thread']
            _description = 'Business Expense'

            name = fields.Char()
            amount = fields.Float('Amount')
            trip_id = fields.Many2one('business.trip', 'Business Trip')
            partner_id = fields.Many2one('res.partner', 'Created by')

    We would like our alias to be easily configurable from the form view of our
    business trips, so let's add the following to our form view:

    .. code-block:: xml

        <page string="Emails">
            <group name="group_alias">
                <label for="alias_name" string="Email Alias"/>
                <div name="alias_def">
                    <!-- display a link while in view mode and a configurable field
                    while in edit mode -->
                    <field name="alias_id" class="oe_read_only oe_inline"
                            string="Email Alias" required="0"/>
                    <div class="oe_edit_only oe_inline" name="edit_alias"
                         style="display: inline;" >
                        <field name="alias_name" class="oe_inline"/>
                        @
                        <field name="alias_domain" class="oe_inline" readonly="1"/>
                    </div>
                </div>
                <field name="alias_contact" class="oe_inline"
                        string="Accept Emails From"/>
            </group>
        </page>

    Now we can change the alias address directly from the form view and change
    who can send e-mails to the alias.

    We can then override ``message_new()`` on our expense model to fetch the values
    from our email when the expense will be created:

    .. code-block:: python

        class BusinessExpense(models.Model):
            # Previous code goes here
            # ...

            def message_new(self, msg, custom_values=None):
                """ Override to set values according to the email.

                In this simple example, we simply use the email title as the name
                of the expense, try to find a partner with this email address and
                do a regex match to find the amount of the expense."""
                name = msg_dict.get('subject', 'New Expense')
                # Match the last occurrence of a float in the string
                # Example: '50.3 bar 34.5' becomes '34.5'. This is potentially the price
                # to encode on the expense. If not, take 1.0 instead
                amount_pattern = '(\d+(\.\d*)?|\.\d+)'
                expense_price = re.findall(amount_pattern, name)
                price = expense_price and float(expense_price[-1][0]) or 1.0
                # find the partner by looking for it's email
                partner = self.env['res.partner'].search([('email', 'ilike', email_address)],
                                                         limit=1)
                defaults = {
                    'name': name,
                    'amount': price,
                    'partner_id': partner.id
                }
                defaults.update(custom_values or {})
                res = super(BusinessExpense, self).message_new(msg, custom_values=defaults)
                return res

.. _reference/mixins/mail/activities:

Activities tracking
-------------------

Activities are actions users have to take on a document like making a phone call
or organizing a meeting. Activities come with the mail module as they are
integrated in the Chatter but are *not bundled with mail.thread*. Activities
are records of the ``mail.activity`` class, which have a type (``mail.activity.type``),
name, description, scheduled time (among others). Pending activities are visible
above the message history in the chatter widget.

You can integrate activities using the ``mail.activity.mixin`` class on your object
and the specific widgets to display them (via the field ``activity_ids``) in the form
view and kanban view of your records (``mail_activity`` and ``kanban_activity``
widgets, respectively).

.. example::

    Organizing a business trip is a tedious process and tracking needed activities
    like ordering plane tickets or a cab for the airport could be useful. To do so,
    we will add the activities mixin on our model and display the next planned activities
    in the message history of our trip.

    .. code-block:: python

        class BusinessTrip(models.Model):
            _name = 'business.trip'
            _inherit = ['mail.thread', 'mail.activity.mixin']
            _description = 'Business Trip'

            name = fields.Char()
            # [...]

    We modify the form view of our trips to display their next activities:

    .. code-block:: xml

        <record id="business_trip_form" model="ir.ui.view">
            <field name="name">business.trip.form</field>
            <field name="model">business.trip</field>
            <field name="arch" type="xml">
                <form string="Business Trip">
                    <!-- Your usual form view goes here -->
                    <chatter>
                        <field name="message_follower_ids" widget="mail_followers"/>
                        <field name="activity_ids" widget="mail_activity"/>
                        <field name="message_ids" widget="mail_thread"/>
                    </chatter>
                </form>
            </field>
        </record>

You can find concrete examples of integration in the following models:

* ``crm.lead`` in the CRM (*crm*) Application
* ``sale.order`` in the Sales (*sale*) Application
* ``project.task`` in the Project (*project*) Application


.. _reference/mixins/website:

Website features
================

.. _reference/mixins/website/utm:

Visitor tracking
----------------

The ``utm.mixin`` class can be used to track online marketing/communication
campaigns through arguments in links to specified resources. The mixin adds
3 fields to your model:

* ``campaign_id``: :class:`~odoo.fields.Many2one` field to a ``utm.campaign``
  object (i.e. Christmas_Special, Fall_Collection, etc.)
* ``source_id``: :class:`~odoo.fields.Many2one` field to a ``utm.source``
  object (i.e. Search Engine, mailing list, etc.)
* ``medium_id``: :class:`~odoo.fields.Many2one` field to a ``utm.medium``
  object (i.e. Snail Mail, e-Mail, social network update, etc.)

These models have a single field ``name`` (i.e. they are simply there to
distinguish campaigns but don't have any specific behaviour).

Once a customer visits your website with these parameters set in the url
(i.e. https://www.odoo.com/?campaign_id=mixin_talk&source_id=www.odoo.com&medium_id=website),
three cookies are set in the visitor's website for these parameters.
Once a object that inherits the utm.mixin is created from the website (i.e. lead
form, job application, etc.), the utm.mixin code kicks in and fetches the values
from the cookies to set them in the new record. Once this is done, you can then
use the campaign/source/medium fields as any other field when defining reports
and views (group by, etc.).

To extend this behaviour, simply add a relational field to a simple model (the
model should support the *quick create* (i.e. call to ``create()`` with a single
``name`` value) and extend the function ``tracking_fields()``:

.. code-block:: python

    class UtmMyTrack(models.Model):
        _name = 'my_module.my_track'
        _description = 'My Tracking Object'

        name = fields.Char(string='Name', required=True)


    class MyModel(models.Models):
        _name = 'my_module.my_model'
        _inherit = ['utm.mixin']
        _description = 'My Tracked Object'

        my_field = fields.Many2one('my_module.my_track', 'My Field')

        @api.model
        def tracking_fields(self):
            result = super(MyModel, self).tracking_fields()
            result.append([
            # ("URL_PARAMETER", "FIELD_NAME_MIXIN", "NAME_IN_COOKIES")
                ('my_field', 'my_field', 'odoo_utm_my_field')
            ])
            return result

This will tell the system to create a cookie named *odoo_utm_my_field* with the
value found in the url parameter ``my_field``; once a new record of this model is
created by a call from a website form, the generic override of the ``create()``
method of ``utm.mixin`` will fetch the default values for this field from the
cookie (and the ``my_module.my_track`` record will be creatwed on the fly if it
does not exist yet).

You can find concrete examples of integration in the following models:

* ``crm.lead`` in the CRM (*crm*) Application
* ``hr.applicant`` in the Recruitment Process (*hr_recruitment*) Application
* ``helpdesk.ticket`` in the Helpdesk (*helpdesk* - Odoo Enterprise only) Application

.. _reference/mixins/website/published:

Website visibility
------------------

You can quite easily add a website visibility toggle on any of your record. While
this mixin is quite easy to implement manually, it is the most often-used after
the ``mail.thread`` inheritance; a testament to its usefulness. The typical use
case for this mixin is any object that has a frontend-page; being able to control
the visibility of the page allows you to take your time while editing the page
and only publish it when you're satisfied.

To include the functionality, you only need to inherit ``website.published.mixin``:

.. code-block:: python

    class BlogPost(models.Model):
        _name = "blog.post"
        _description = "Blog Post"
        _inherit = ['website.published.mixin']

This mixin adds 2 fields on your model:

* ``website_published``: :class:`~odoo.fields.Boolean` field which represents
  the status of the publication
* ``website_url``: :class:`~odoo.fields.Char` field which represents
  the URL through which the object is accessed

Note that this last field is a computed field and must be implemented for your class:

.. code-block:: python

    def _compute_website_url(self):
        for blog_post in self:
            blog_post.website_url = "/blog/%s" % (log_post.blog_id)

Once the mechanism is in place, you just have to adapt your frontend and backend
views to make it accessible. In the backend, adding a button in the button box is
usually the way to go:

.. code-block:: xml

    <button class="oe_stat_button" name="website_publish_button"
        type="object" icon="fa-globe">
        <field name="website_published" widget="website_button"/>
    </button>

In the frontend, some security checks are needed to avoid showing 'Editing'
buttons to website visitors:

.. code-block:: xml

    <div id="website_published_button" class="float-right"
         groups="base.group_website_publisher"> <!-- or any other meaningful group -->
        <t t-call="website.publish_management">
          <t t-set="object" t-value="blog_post"/>
          <t t-set="publish_edit" t-value="True"/>
          <t t-set="action" t-value="'blog.blog_post_action'"/>
        </t>
    </div>

Note that you must pass your object as the variable ``object`` to the template;
in this example, the ``blog.post`` record was passed as the ``blog_post`` variable
to the ``qweb`` rendering engine, it is necessary to specify this to the publish
management template. The ``publish_edit`` variable allow the frontend
button to link to the backend (allowing you to switch from frontend to backend
and vice-versa easily); if set, you must specify the full external id of the action
you want to call in the backend in the ``action`` variable (note that a Form View
must exist for the model).

The action ``website_publish_button`` is defined in the mixin and adapts its
behaviour to your object: if the class has a valid ``website_url`` compute function,
the user is redirected to the frontend when he clicks on the button; the user
can then publish the page directly from the frontend. This ensures
that no online publication can happen by accident. If there is not compute function,
the boolean ``website_published`` is simply triggered.

.. _reference/mixins/website/seo:

Website metadata
----------------

This simple mixin simply allows you to easily inject metadata in your frontend
pages.

.. code-block:: python

    class BlogPost(models.Model):
        _name = "blog.post"
        _description = "Blog Post"
        _inherit = ['website.seo.metadata', 'website.published.mixin']

This mixin adds 3 fields on your model:

* ``website_meta_title``: :class:`~odoo.fields.Char` field that allow you to set
  an additional title to your page
* ``website_meta_description``: :class:`~odoo.fields.Char` field that contains a
  short description of the page (sometimes used in search engines results)
* ``website_meta_keywords``: :class:`~odoo.fields.Char` field that contains some
  keywords to help your page to be classified more precisely by search engines; the
  "Promote" tool will help you select lexically-related keywords easily

These fields are editable in the frontend using the "Promote" tool from the Editor
toolbar. Setting these fields can help search engines to better index your pages.
Note that search engines do not base their results only on these metadata; the
best SEO practice should still be to get referenced by reliable sources.

.. _reference/mixins/misc:

Others
======

.. _reference/mixins/misc/rating:

Customer Rating
---------------

The rating mixin allows sending email to ask for customer rating, automatic
transitioning in a kanban processes and aggregating statistics on your ratings.

Adding rating on your model
~~~~~~~~~~~~~~~~~~~~~~~~~~~

To add rating support, simply inherit the ``rating.mixin`` model:

.. code-block:: python

    class MyModel(models.Models):
        _name = 'my_module.my_model'
        _inherit = ['rating.mixin', 'mail.thread']

        user_id = fields.Many2one('res.users', 'Responsible')
        partner_id = fields.Many2one('res.partner', 'Customer')

The behaviour of the mixin adapts to your model:

* The ``rating.rating`` record will be linked to the ``partner_id`` field of your
  model (if the field is present).

  - this behaviour can be overridden with the function ``rating_get_partner_id()``
    if you use another field than ``partner_id``

* The ``rating.rating`` record will be linked to the partner of the ``user_id``
  field of your model (if the field is present) (i.e. the partner who is rated)

  - this behaviour can be overridden with the function ``rating_get_rated_partner_id()``
    if you use another field than ``user_id`` (note that the function must return a
    ``res.partner``, for ``user_id`` the system automatically fetches the partner
    of the user)

* The chatter history will display the rating event (if your model inherits from
  ``mail.thread``)

Send rating requests by e-mail
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you wish to send emails to request a rating, simply generate an e-mail with
links to the rating object. A very basic email template could look like this:

.. code-block:: xml

    <record id="rating_my_model_email_template" model="mail.template">
                <field name="name">My Model: Rating Request</field>
                <field name="email_from">${object.rating_get_rated_partner_id().email or '' | safe}</field>
                <field name="subject">Service Rating Request</field>
                <field name="model_id" ref="my_module.model_my_model"/>
                <field name="partner_to" >${object.rating_get_partner_id().id}</field>
                <field name="auto_delete" eval="True"/>
                <field name="body_html"><![CDATA[
    % set access_token = object.rating_get_access_token()
    <p>Hi,</p>
    <p>How satsified are you?</p>
    <ul>
        <li><a href="/rate/${access_token}/5">Satisfied</a></li>
        <li><a href="/rate/${access_token}/3">Okay</a></li>
        <li><a href="/rate/${access_token}/1">Dissatisfied</a></li>
    </ul>
    ]]></field>
    </record>

Your customer will then receive an e-mail with links to a simple webpage allowing
them to provide a feedback on their interaction with your users (including a free-text
feedback message).

You can then quite easily integrate your ratings with your form view by defining
an action for the ratings:

.. code-block:: xml

    <record id="rating_rating_action_my_model" model="ir.actions.act_window">
        <field name="name">Customer Ratings</field>
        <field name="res_model">rating.rating</field>
        <field name="view_mode">kanban,pivot,graph</field>
        <field name="domain">[('res_model', '=', 'my_module.my_model'), ('res_id', '=', active_id), ('consumed', '=', True)]</field>
    </record>

    <record id="my_module_my_model_view_form_inherit_rating" model="ir.ui.view">
        <field name="name">my_module.my_model.view.form.inherit.rating</field>
        <field name="model">my_module.my_model</field>
        <field name="inherit_id" ref="my_module.my_model_view_form"/>
        <field name="arch" type="xml">
            <xpath expr="//div[@name='button_box']" position="inside">
                <button name="%(rating_rating_action_my_model)d" type="action"
                        class="oe_stat_button" icon="fa-smile-o">
                    <field name="rating_count" string="Rating" widget="statinfo"/>
                </button>
            </xpath>
        </field>
    </record>

Note that there are default views (kanban,pivot,graph) for ratings which allow
you a quick bird's eye view of your customer ratings.

You can find concrete examples of integration in the following models:

* ``project.task`` in the Project (*rating_project*) Application
* ``helpdesk.ticket`` in the Helpdesk (*helpdesk* - Odoo Enterprise only) Application


==================================================
SECTION: module.rst
PATH: developer/reference/backend/module.rst
==================================================


================
Module Manifests
================



.. _reference/module/manifest:

Manifest
========

The manifest file serves to declare a python package as an Odoo module
and to specify module metadata.

It is a file called ``__manifest__.py`` and contains a single Python
dictionary, where each key specifies module metadatum.

::

    {
        'name': "A Module",
        'version': '1.0',
        'depends': ['base'],
        'author': "Author Name",
        'category': 'Category',
        'description': """
        Description text
        """,
        # data files always loaded at installation
        'data': [
            'views/mymodule_view.xml',
        ],
        # data files containing optionally loaded demonstration data
        'demo': [
            'demo/demo_data.xml',
        ],
    }

Available manifest fields are:

``name`` (``str``, required)
    the human-readable name of the module
``version`` (``str``)
    this module's version, should follow `semantic versioning`_ rules
``description`` (``str``)
    extended description for the module, in reStructuredText
``author`` (``str``)
    name of the module author
``website`` (``str``)
    website URL for the module author
``license`` (``str``, defaults: ``LGPL-3``)
    distribution license for the module.
    Possible values:

    * `GPL-2`
    * `GPL-2 or any later version`
    * `GPL-3`
    * `GPL-3 or any later version`
    * `AGPL-3`
    * `LGPL-3`
    * `Other OSI approved licence`
    * `OEEL-1` (Odoo Enterprise Edition License v1.0)
    * `OPL-1` (Odoo Proprietary License v1.0)
    * `Other proprietary`

``category`` (``str``, default: ``Uncategorized``)
    classification category within Odoo, rough business domain for the module.

    Although using `existing categories`_ is recommended, the field is
    freeform and unknown categories are created on-the-fly. Category
    hierarchies can be created using the separator ``/`` e.g. ``Foo / Bar``
    will create a category ``Foo``, a category ``Bar`` as child category of
    ``Foo``, and will set ``Bar`` as the module's category.
``depends`` (``list(str)``)
    Odoo modules which must be loaded before this one, either because this
    module uses features they create or because it alters resources they
    define.

    When a module is installed, all of its dependencies are installed before
    it. Likewise dependencies are loaded before a module is loaded.

.. note::
    Module `base` is always installed in any Odoo instance.
    But you still need to specify it as dependency to make sure your module is updated when `base` is updated.

``data`` (``list(str)``)
    List of data files which must always be installed or updated with the
    module. A list of paths from the module root directory
``demo`` (``list(str)``)
    List of data files which are only installed or updated in *demonstration
    mode*
``auto_install`` (``bool`` or ``list(str)``, default: ``False``)
    If ``True``, this module will automatically be installed if all of its
    dependencies are installed.

    It is generally used for "link modules" implementing synergetic integration
    between two otherwise independent modules.

    For instance ``sale_crm`` depends on both ``sale`` and ``crm`` and is set
    to ``auto_install``. When both ``sale`` and ``crm`` are installed, it
    automatically adds CRM campaigns tracking to sale orders without either
    ``sale`` or ``crm`` being aware of one another.

    If it is a list, it must contain a subset of the dependencies. This module will automatically be
    installed as soon as all the dependencies in the subset are installed. The remaining
    dependencies will be automatically installed as well. If the list is empty, this module will
    always be automatically installed regardless of its dependencies and these will be installed as
    well.

``external_dependencies`` (``dict(key=list(str))``)
    A dictionary containing python and/or binary dependencies.

    For python dependencies, the ``python`` key must be defined for this
    dictionary and a list of python modules to be imported should be assigned
    to it.

    For binary dependencies, the ``bin`` key must be defined for this
    dictionary and a list of binary executable names should be assigned to it.

    The module won't be installed if either the python module is not installed
    in the host machine or the binary executable is not found within the
    host machine's PATH environment variable.
``application`` (``bool``, default: ``False``)
    Whether the module should be considered as a fully-fledged application
    (``True``) or is just a technical module (``False``) that provides some
    extra functionality to an existing application module.
``assets`` (``dict``)
    A definition of how all static files are loaded in various assets bundles.
    See the :ref:`assets <reference/assets>` page for more details on how to
    describe bundles.
``installable`` (``bool`` default: ``True``)
    Whether a user should be able to install the module from the Web UI or not.
``maintainer`` (``str``)
    Person or entity in charge of the maintenance of this module, by default
    it is assumed that the author is the maintainer.
``{pre_init, post_init, uninstall}_hook`` (``str``)
    Hooks for module installation/uninstallation, their value should be a
    string representing the name of a function defined inside the module's
    ``__init__.py``.

    ``pre_init_hook`` takes an env as its only argument, this function is
    executed prior to the module's installation.

    ``post_init_hook`` takes an env as its only argument, this
    function is executed right after the module's installation.

    ``uninstall_hook`` takes an env as its only argument, this
    function is executed after the module's uninstallation.

    These hooks should only be used when setup/cleanup required for this module
    is either extremely difficult or impossible through the api.
``active`` (``bool``)
    Deprecated. Replaced by ``auto_install``.

.. _semantic versioning: https://semver.org
.. _existing categories: {GITHUB_PATH}/odoo/addons/base/data/ir_module_category_data.xml


==================================================
SECTION: orm.rst
PATH: developer/reference/backend/orm.rst
==================================================

:show-content:

.. _reference/orm:

=======
ORM API
=======

.. toctree::
   :titlesonly:

   orm/changelog

.. automodule:: odoo.models

.. _reference/orm/models:
.. _reference/orm/model:

Models
======

Model fields are defined as attributes on the model itself::

    from odoo import models, fields
    class AModel(models.Model):
        _name = 'a.model.name'

        field1 = fields.Char()

.. warning:: this means you cannot define a field and a method with the same
             name, the last one will silently overwrite the former ones.

By default, the field's label (user-visible name) is a capitalized version of
the field name, this can be overridden with the ``string`` parameter. ::

        field2 = fields.Integer(string="Field Label")

For the list of field types and parameters, see :ref:`the fields reference
<reference/fields>`.

Default values are defined as parameters on fields, either as a value::

    name = fields.Char(default="a value")

or as a function called to compute the default value, which should return that
value::

    def _default_name(self):
        return self.get_value()

    name = fields.Char(default=lambda self: self._default_name())

.. rubric:: API

.. autoclass:: odoo.models.BaseModel()

    .. autoattribute:: _auto
    .. attribute:: _log_access

        Whether the ORM should automatically generate and update the
        :ref:`reference/fields/automatic/log_access`.

        Defaults to whatever value was set for :attr:`~._auto`.

    .. autoattribute:: _table

    .. autoattribute:: _register
    .. autoattribute:: _abstract
    .. autoattribute:: _transient

    .. autoattribute:: _name
    .. autoattribute:: _description

    .. autoattribute:: _inherit
    .. autoattribute:: _inherits

    .. autoattribute:: _rec_name
    .. autoattribute:: _order

    .. autoattribute:: _check_company_auto

    .. autoattribute:: _parent_name
    .. autoattribute:: _parent_store

    .. autoattribute:: _fold_name

AbstractModel
-------------

.. autoclass:: odoo.models.AbstractModel

Model
-----

.. autoclass:: odoo.models.Model

   .. autoattribute:: _auto
   .. autoattribute:: _abstract

TransientModel
--------------

.. autoclass:: odoo.models.TransientModel
   :members: _transient_vacuum

   .. autoattribute:: _transient_max_count
   .. autoattribute:: _transient_max_hours

.. _reference/fields:
.. _reference/orm/fields:

Fields
======

.. currentmodule:: odoo.fields

.. autoclass:: Field()

.. _reference/fields/basic:

Basic Fields
------------

.. autoclass:: Boolean()

.. autoclass:: Char()

.. autoclass:: Float()

.. autoclass:: Integer()

.. _reference/fields/advanced:

Advanced Fields
---------------

.. autoclass:: Binary()

.. autoclass:: Html()

.. autoclass:: Image()

.. autoclass:: Monetary()

.. autoclass:: Selection()

.. autoclass:: Text()

.. _reference/fields/date:

Date(time) Fields
~~~~~~~~~~~~~~~~~

:class:`Dates <odoo.fields.Date>` and :class:`Datetimes <odoo.fields.Datetime>`
are very important fields in any kind of business application.
Their misuse can create invisible yet painful bugs, this section
aims to provide Odoo developers with the knowledge required
to avoid misusing these fields.

When assigning a value to a Date/Datetime field, the following options are valid:

* A `date` or `datetime` object.
* A string in the proper server format:

  * ``YYYY-MM-DD`` for :class:`~odoo.fields.Date` fields,
  * ``YYYY-MM-DD HH:MM:SS`` for :class:`~odoo.fields.Datetime` fields.

* `False` or `None`.

The Date and Datetime fields class have helper methods to attempt conversion
into a compatible type:

* :func:`~odoo.fields.Date.to_date` will convert to a :class:`datetime.date`
* :func:`~odoo.fields.Datetime.to_datetime` will convert to a :class:`datetime.datetime`.

.. example::

    To parse date/datetimes coming from external sources::

        fields.Date.to_date(self._context.get('date_from'))

Date / Datetime comparison best practices:

* Date fields can **only** be compared to date objects.
* Datetime fields can **only** be compared to datetime objects.

.. warning:: Strings representing dates and datetimes can be compared
             between each other, however the result may not be the expected
             result, as a datetime string will always be greater than a
             date string, therefore this practice is **heavily**
             discouraged.

Common operations with dates and datetimes such as addition, subtraction or
fetching the start/end of a period are exposed through both
:class:`~odoo.fields.Date` and :class:`~odoo.fields.Datetime`.
These helpers are also available by importing `odoo.tools.date_utils`.

.. note:: Timezones

    Datetime fields are stored as `timestamp without timezone` columns in the database and are stored
    in the UTC timezone. This is by design, as it makes the Odoo database independent from the timezone
    of the hosting server system. Timezone conversion is managed entirely by the client side.

.. autoclass:: Date()
    :members: today, context_today, to_date, to_string, start_of, end_of, add, subtract

.. autoclass:: Datetime()
    :members: now, today, context_timestamp, to_datetime, to_string, start_of, end_of, add, subtract

.. _reference/fields/relational:

Relational Fields
~~~~~~~~~~~~~~~~~

.. autoclass:: Many2one()

.. autoclass:: One2many()

.. autoclass:: Many2many()

.. autoclass:: Command()
   :members:
   :undoc-members:
   :member-order: bysource

Pseudo-relational fields
~~~~~~~~~~~~~~~~~~~~~~~~

.. autoclass:: Reference()

.. autoclass:: Many2oneReference()

.. _reference/fields/compute:

Computed Fields
~~~~~~~~~~~~~~~

Fields can be computed (instead of read straight from the database) using the
``compute`` parameter. **It must assign the computed value to the field**. If
it uses the values of other *fields*, it should specify those fields using
:func:`~odoo.api.depends`. ::

    from odoo import api
    total = fields.Float(compute='_compute_total')

    @api.depends('value', 'tax')
    def _compute_total(self):
        for record in self:
            record.total = record.value + record.value * record.tax

* dependencies can be dotted paths when using sub-fields::

    @api.depends('line_ids.value')
    def _compute_total(self):
        for record in self:
            record.total = sum(line.value for line in record.line_ids)

* computed fields are not stored by default, they are computed and
  returned when requested. Setting ``store=True`` will store them in the
  database and automatically enable searching and grouping.
  Note that by default, ``compute_sudo=True`` is set on the field.
* searching on a computed field can also be enabled by setting the ``search``
  parameter. The value is a method name returning a
  :ref:`reference/orm/domains`. ::

    upper_name = field.Char(compute='_compute_upper', search='_search_upper')

    def _search_upper(self, operator, value):
        if operator == 'like':
            operator = 'ilike'
        return Domain('name', operator, value)

* computed fields are readonly by default. To allow *setting* values on a
  computed field, use the ``inverse`` parameter.
  It is the name of a function reversing the computation and
  setting the relevant fields::

    document = fields.Char(compute='_get_document', inverse='_set_document')

    def _get_document(self):
        for record in self:
            with open(record.get_document_path) as f:
                record.document = f.read()
    def _set_document(self):
        for record in self:
            if not record.document: continue
            with open(record.get_document_path()) as f:
                f.write(record.document)

* multiple fields can be computed at the same time by the same method, just
  use the same method on all fields and set all of them::

    discount_value = fields.Float(compute='_apply_discount')
    total = fields.Float(compute='_apply_discount')

    @api.depends('value', 'discount')
    def _apply_discount(self):
        for record in self:
            # compute actual discount from discount percentage
            discount = record.value * record.discount
            record.discount_value = discount
            record.total = record.value - discount

.. warning::

    While it is possible to use the same compute method for multiple
    fields, it is not recommended to do the same for the inverse
    method.

    During the computation of the inverse, **all** fields that use
    said inverse are protected, meaning that they can't be computed,
    even if their value is not in the cache.

    If any of those fields is accessed and its value is not in cache,
    the ORM will simply return a default value of `False` for these fields.
    This means that the value of the inverse fields (other than the one
    triggering the inverse method) may not give their correct value and
    this will probably break the expected behavior of the inverse method.

.. _reference/fields/related:

Related fields
~~~~~~~~~~~~~~

A special case of computed fields are *related* (proxy) fields, which provide
the value of a sub-field on the current record. They are defined by setting
the ``related`` parameter and like regular computed fields they can be
stored::

    nickname = fields.Char(related='user_id.partner_id.name', store=True)

The value of a related field is given by following a sequence of
relational fields and reading a field on the reached model. The complete
sequence of fields to traverse is specified by the ``related`` attribute.

Some field attributes are automatically copied from the source field if
they are not redefined: ``string``, ``help``, ``required`` (only
if all fields in the sequence are required), ``groups``, ``digits``, ``size``,
``translate``, ``sanitize``, ``selection``, ``comodel_name``, ``domain``,
``context``. All semantic-free attributes are copied from the source
field.

By default, related fields are:

* not stored
* not copied
* readonly
* computed in superuser mode

Add the attribute ``store=True`` to make it stored, just like computed
fields. Related fields are automatically recomputed when their
dependencies are modified.

.. tip::

    You can specify precise field dependencies if you don't want
    the related field to be recomputed on any dependency change::

        nickname = fields.Char(
            related='partner_id.name', store=True,
            depends=['partner_id'])
        # The nickname will only be recomputed when the partner_id
        # is modified, not when the name is modified on the partner.

.. warning::

    You cannot chain :class:`~odoo.fields.Many2many` or :class:`~odoo.fields.One2many` fields in ``related`` fields dependencies.

    ``related`` can be used to refer to a :class:`~odoo.fields.One2many` or
    :class:`~odoo.fields.Many2many` field on another model on the
    condition that it's done through a ``Many2one`` relation on the current model.
    ``One2many`` and ``Many2many`` are not supported and the results will not be
    aggregated correctly::

      m2o_id = fields.Many2one()
      m2m_ids = fields.Many2many()
      o2m_ids = fields.One2many()

      # Supported
      d_ids = fields.Many2many(related="m2o_id.m2m_ids")
      e_ids = fields.One2many(related="m2o_id.o2m_ids")

      # Won't work: use a custom Many2many computed field instead
      f_ids = fields.Many2many(related="m2m_ids.m2m_ids")
      g_ids = fields.One2many(related="o2m_ids.o2m_ids")

.. currentmodule:: odoo.models

.. _reference/fields/automatic:

Automatic fields
----------------

.. attribute:: Model.id

    Identifier :class:`field <odoo.fields.Field>`

    If length of current recordset is 1, return id of unique record in it.

    Raise an Error otherwise.

.. attribute:: Model.display_name

    Name :class:`field <odoo.fields.Char>` displayed by default in the web client

    By default, it equals to :attr:`~odoo.models.BaseModel._rec_name` value field
    but the behavior can be customized by overriding :attr:`~odoo.models.BaseModel._compute_display_name`

.. _reference/fields/automatic/log_access:

Access Log fields
~~~~~~~~~~~~~~~~~

These fields are automatically set and updated if
:attr:`~odoo.models.BaseModel._log_access` is enabled. It can be
disabled to avoid creating or updating those fields on tables for which they are
not useful.

By default, :attr:`~odoo.models.BaseModel._log_access` is set to the same value
as :attr:`~odoo.models.BaseModel._auto`

.. attribute:: Model.create_date

    Stores when the record was created, :class:`~odoo.fields.Datetime`

.. attribute:: Model.create_uid

    Stores *who* created the record, :class:`~odoo.fields.Many2one` to a
    ``res.users``.

.. attribute:: Model.write_date

    Stores when the record was last updated, :class:`~odoo.fields.Datetime`

.. attribute:: Model.write_uid

    Stores who last updated the record, :class:`~odoo.fields.Many2one` to a
    ``res.users``.

.. warning:: :attr:`~odoo.models.BaseModel._log_access` *must* be enabled on
             :class:`~odoo.models.TransientModel`.

.. _reference/orm/fields/reserved:

Reserved Field names
--------------------

A few field names are reserved for pre-defined behaviors beyond that of
automated fields. They should be defined on a model when the related
behavior is desired:

.. attribute:: Model.name

   default value for :attr:`~odoo.models.BaseModel._rec_name`, used to
   display records in context where a representative "naming" is
   necessary.

   :class:`~odoo.fields.Char`

.. attribute:: Model.active

  toggles the global visibility of the record, if ``active`` is set to
  ``False`` the record is invisible in most searches and listing.

  :class:`~odoo.fields.Boolean`

  Special methods:

  .. automethod:: Model.action_archive
  .. automethod:: Model.action_unarchive

.. attribute:: Model.state

  lifecycle stages of the object, used by the ``states`` attribute on
  :class:`fields <odoo.fields.Field>`.

  :class:`~odoo.fields.Selection`

.. attribute:: Model.parent_id

  default_value of :attr:`~._parent_name`, used to organize
  records in a tree structure and enables the ``child_of``
  and ``parent_of`` operators in domains.

  :class:`~odoo.fields.Many2one`

.. attribute:: Model.parent_path

  When :attr:`~._parent_store` is set to True, used to store a value reflecting
  the tree structure of :attr:`~._parent_name`, and to optimize the operators
  ``child_of`` and ``parent_of`` in :ref:`reference/orm/domains`.
  It must be declared with ``index=True`` for proper operation.

  :class:`~odoo.fields.Char`

.. attribute:: Model.company_id

  Main field name used for Odoo multi-company behavior.

  Used by `:meth:~odoo.models._check_company` to check multi company consistency.
  Defines whether a record is shared between companies (no value) or only
  accessible by the users of a given company.

  :class:`~odoo.fields.Many2one`
  :type: :class:`~odoo.addons.base.models.res_company`

Constraints and indexes
=======================

Similarly to fields, you can declare
:attr:`~odoo.models.Constraint`,
:attr:`~odoo.models.Index` and :attr:`~odoo.models.UniqueIndex`.
The name of the attribute must begin with `_` to avoid name clashes with field
names.

You can customize error messages.
They can either be strings and their translation will be provided in the internal
reflected constraint table.
Otherwise, they can be functions that take `(env, diag)` as parameters
which respectively denote the environment and psycopg diagnostics.

.. example::

   .. code-block:: python

          class AModel(models.Model):
              _name = 'a.model'
              _my_check = models.Constraint("CHECK (x > y)", "x > y is not true")
              _name_idx = models.Index("(last_name, first_name)")

Recordsets
==========

Interactions with models and records are performed through recordsets, an ordered
collection of records of the same model.

.. warning:: Contrary to what the name implies, it is currently possible for
             recordsets to contain duplicates. This may change in the future.

Methods defined on a model are executed on a recordset, and their ``self`` is
a recordset::

    class AModel(models.Model):
        _name = 'a.model'
        def a_method(self):
            # self can be anything between 0 records and all records in the
            # database
            self.do_operation()

Iterating on a recordset will yield new sets of *a single record*
("singletons"), much like iterating on a Python string yields strings of a
single characters::

        def do_operation(self):
            print(self) # => a.model(1, 2, 3, 4, 5)
            for record in self:
                print(record) # => a.model(1), then a.model(2), then a.model(3), ...

Field access
------------

Recordsets provide an "Active Record" interface: model fields can be read and
written directly from the record as attributes.

.. note::

    When accessing non-relational fields on a recordset of potentially multiple
    records, use :meth:`~odoo.models.BaseModel.mapped`::

        total_qty = sum(self.mapped('qty'))

Field values can also be accessed like dict items, which is more elegant and
safer than ``getattr()`` for dynamic field names.
Setting a field's value triggers an update to the database::

    >>> record.name
    Example Name
    >>> record.company_id.name
    Company Name
    >>> record.name = "Bob"
    >>> field = "name"
    >>> record[field]
    Bob

.. warning::

    Trying to read a field on multiple records will raise an error for non relational
    fields.

Accessing a relational field (:class:`~odoo.fields.Many2one`,
:class:`~odoo.fields.One2many`, :class:`~odoo.fields.Many2many`)
*always* returns a recordset, empty if the field is not set.

Record cache and prefetching
----------------------------

Odoo maintains a cache for the fields of the records, so that not every field
access issues a database request, which would be terrible for performance. The
following example queries the database only for the first statement::

    record.name             # first access reads value from database
    record.name             # second access gets value from cache

To avoid reading one field on one record at a time, Odoo *prefetches* records
and fields following some heuristics to get good performance. Once a field must
be read on a given record, the ORM actually reads that field on a larger
recordset, and stores the returned values in cache for later use. The prefetched
recordset is usually the recordset from which the record comes by iteration.
Moreover, all simple stored fields (boolean, integer, float, char, text, date,
datetime, selection, many2one) are fetched altogether; they correspond to the
columns of the model's table, and are fetched efficiently in the same query.

Consider the following example, where ``partners`` is a recordset of 1000
records. Without prefetching, the loop would make 2000 queries to the database.
With prefetching, only one query is made::

    for partner in partners:
        print partner.name          # first pass prefetches 'name' and 'lang'
                                    # (and other fields) on all 'partners'
        print partner.lang

The prefetching also works on *secondary records*: when relational fields are
read, their values (which are records) are  subscribed for future prefetching.
Accessing one of those secondary records prefetches all secondary records from
the same model. This makes the following example generate only two queries, one
for partners and one for countries::

    countries = set()
    for partner in partners:
        country = partner.country_id        # first pass prefetches all partners
        countries.add(country.name)         # first pass prefetches all countries

.. seealso::
    The methods :meth:`~odoo.models.Model.search_fetch` and
    :meth:`~odoo.models.Model.fetch` can be used to populate the cache of
    records, typically in cases where the prefetching mechanism does not work
    well.


.. _reference/api/decorators:

Method decorators
=================

.. automodule:: odoo.api
    :members: depends, depends_context, constrains, onchange, autovacuum, model, model_create_multi, private, ondelete

.. .. currentmodule:: odoo.api

.. .. autodata:: model
.. .. autodata:: private
.. .. autodata:: depends
.. .. autodata:: constrains
.. .. autodata:: onchange
.. .. autodata:: autovacuum

.. todo:: With sphinx 2.0 : autodecorator

.. todo:: Add in Views reference
  * It is possible to suppress the trigger from a specific field by adding
  ``on_change="0"`` in a view::

    <field name="name" on_change="0"/>

  will not trigger any interface update when the field is edited by the user,
  even if there are function fields or explicit onchange depending on that
  field.

.. _reference/orm/environment:

Environment
===========

.. currentmodule:: odoo.api

.. autoclass:: Environment

.. code-block:: bash

    >>> records.env
    <Environment object ...>
    >>> records.env.uid
    3
    >>> records.env.user
    res.user(3)
    >>> records.env.cr
    <Cursor object ...>

When creating a recordset from an other recordset, the environment is
inherited. The environment can be used to get an empty recordset in an
other model, and query that model:

.. code-block:: bash

    >>> self.env['res.partner']
    res.partner()
    >>> self.env['res.partner'].search([('is_company', '=', True), ('customer', '=', True)])
    res.partner(7, 18, 12, 14, 17, 19, 8, 31, 26, 16, 13, 20, 30, 22, 29, 15, 23, 28, 74)

Some lazy properties are available to access the environment (contextual) data:

.. autoattribute:: Environment.lang
.. autoattribute:: Environment.user
.. autoattribute:: Environment.company
.. autoattribute:: Environment.companies

Useful environment methods
--------------------------

.. automethod:: Environment.ref
.. automethod:: Environment.is_superuser
.. automethod:: Environment.is_admin
.. automethod:: Environment.is_system
.. automethod:: Environment.execute_query

Altering the environment
------------------------

.. currentmodule:: odoo.models

.. automethod:: Model.with_context

.. automethod:: Model.with_user

.. automethod:: Model.with_company

.. automethod:: Model.with_env

.. automethod:: Model.sudo

.. _reference/orm/sql:

SQL Execution
-------------

The :attr:`~odoo.api.Environment.cr` attribute on environments is the
cursor for the current database transaction and allows executing SQL directly,
either for queries which are difficult to express using the ORM (e.g. complex
joins) or for performance reasons::

    self.env.cr.execute("some_sql", params)

.. warning::
    Executing raw SQL bypasses the ORM and, by consequent, Odoo security rules.
    Please make sure your queries are sanitized when using user input and prefer using
    ORM utilities if you don't really need to use SQL queries.

The recommended way to build SQL queries is to use the wrapper object

.. autoclass:: odoo.tools.SQL

    .. automethod:: SQL.join
    .. automethod:: SQL.identifier

One important thing to know about models is that they don't necessarily perform
database updates right away. Indeed, for performance reasons, the framework
delays the recomputation of fields after modifying records. And some database
updates are delayed, too. Therefore, before querying the database, one has to
make sure that it contains the relevant data for the query. This operation is
called *flushing* and performs the expected database updates.

.. example::

    .. code-block:: python

        # make sure that 'partner_id' is up-to-date in database
        self.env['model'].flush_model(['partner_id'])

        self.env.cr.execute(SQL("SELECT id FROM model WHERE partner_id IN %s", ids))
        ids = [row[0] for row in self.env.cr.fetchall()]

Before every SQL query, one has to flush the data needed for that query. There
are three levels for flushing, each with its own API. One can flush either
everything, all the records of a model, or some specific records. Because
delaying updates improves performance in general, we recommend to be *specific*
when flushing.

.. automethod:: odoo.api.Environment.flush_all

.. automethod:: Model.flush_model

.. automethod:: Model.flush_recordset

Because models use the same cursor and the :class:`~odoo.api.Environment`
holds various caches, these caches must be invalidated when *altering* the
database in raw SQL, or further uses of models may become incoherent. It is
necessary to clear caches when using ``CREATE``, ``UPDATE`` or ``DELETE`` in
SQL, but not ``SELECT`` (which simply reads the database).

.. example::

    .. code-block:: python

        # make sure 'state' is up-to-date in database
        self.env['model'].flush_model(['state'])

        self.env.cr.execute("UPDATE model SET state=%s WHERE state=%s", ['new', 'old'])

        # invalidate 'state' from the cache
        self.env['model'].invalidate_model(['state'])

Just like flushing, one can invalidate either the whole cache, the cache of all
the records of a model, or the cache of specific records. One can even
invalidate specific fields on some records or all records of a model. As the
cache improves performance in general, we recommend to be *specific* when
invalidating.

.. automethod:: odoo.api.Environment.invalidate_all

.. automethod:: Model.invalidate_model

.. automethod:: Model.invalidate_recordset

The methods above keep the caches and the database consistent with each other.
However, if computed field dependencies have been modified in the database, one
has to inform the models for the computed fields to be recomputed. The only
thing the framework needs to know is *what* fields have changed on *which*
records.

.. example::

    .. code-block:: python

        # make sure 'state' is up-to-date in database
        self.env['model'].flush_model(['state'])

        # use the RETURNING clause to retrieve which rows have changed
        self.env.cr.execute("UPDATE model SET state=%s WHERE state=%s RETURNING id", ['new', 'old'])
        ids = [row[0] for row in self.env.cr.fetchall()]

        # invalidate the cache, and notify the update to the framework
        records = self.env['model'].browse(ids)
        records.invalidate_recordset(['state'])
        records.modified(['state'])

One has to figure out which records have been modified. There are many ways to
do this, possibly involving extra SQL queries. In the example above, we take
advantage of the ``RETURNING`` clause of PostgreSQL to retrieve the information
without an extra query. After making the cache consistent by invalidation,
invoke the method ``modified`` on the modified records with the fields that
have been updated.

.. automethod:: Model.modified


.. _reference/orm/models/crud:

Common ORM methods
==================

.. currentmodule:: odoo.models

Create/Update
-------------

.. todo:: api.model_create_multi information

.. automethod:: Model.create

.. automethod:: Model.copy

.. automethod:: Model.default_get

.. automethod:: Model.name_create

.. automethod:: Model.write

Search/Read
-----------

.. automethod:: Model.browse

.. automethod:: Model.search

.. automethod:: Model.search_count

.. automethod:: Model.search_fetch

.. automethod:: Model.name_search

.. automethod:: Model.fetch

.. automethod:: Model.read

.. automethod:: Model._read_group

Fields
~~~~~~

.. automethod:: Model.fields_get

.. _reference/orm/domains:

Search domains
~~~~~~~~~~~~~~

A search domain is a first-order logical predicate used for
filtering and searching recordsets.
You combine simple conditions on a field expression with logical operators.

:class:`~odoo.fields.Domain` can be used as a builder for domains.

.. code-block:: python

    # simple condition domains
    d1 = Domain('name', '=', 'abc')
    d2 = Domain('phone', 'like', '7620')

    # combine domains
    d3 = d1 & d2  # and
    d4 = d1 | d2  # or
    d5 = ~d1      # not

    # combine and parse multiple domains (any iterable of domains)
    Domain.AND([d1, d2, d3, ...])
    Domain.OR([d4, d5, ...])

    # constants
    Domain.TRUE   # true domain
    Domain.FALSE  # false domain

A domain can be a simple condition ``(field_expr, operator, value)`` where:

* ``field_expr`` (``str``)
    a field name of the current model, or a relationship traversal through
    a :class:`~odoo.fields.Many2one` using dot-notation e.g. ``'street'``
    or ``'partner_id.country'``. If the field is a date(time) field, you can also
    specify a part of the date using ``'field_name.granularity'``. The supported
    granularities are ``'year_number'``, ``'quarter_number'``, ``'month_number'``, ``'iso_week_number'``,
    ``'day_of_week'``, ``'day_of_month'``, ``'day_of_year'``, ``'hour_number'``, ``'minute_number'``,
    ``'second_number'``.
    They all use an integer as value.

* ``operator`` (``str``)
    an operator used to compare the ``field_expr`` with the ``value``. Valid
    operators are:

    ``=``
        equals to
    ``!=``
        not equals to
    ``>``
        greater than
    ``>=``
        greater than or equal to
    ``<``
        less than
    ``<=``
        less than or equal to
    ``=?``
        unset or equals to (returns true if ``value`` is either ``None`` or
        ``False``, otherwise behaves like ``=``)
    ``=like`` (and ``not =like``)
        matches ``field_expr`` against the ``value`` pattern. An underscore
        ``_`` in the pattern stands for (matches) any single character; a
        percent sign ``%`` matches any string of zero or more characters.
    ``like`` (and ``not like``)
        matches ``field_expr`` against the ``%value%`` pattern. Similar to
        ``=like`` but wraps ``value`` with '%' before matching
    ``ilike`` (and ``not ilike``)
        case insensitive ``like``
    ``=ilike`` (and ``not =ilike``)
        case insensitive ``=like``
    ``in`` (and ``not in``)
        is equal to any of the items from ``value``, ``value`` should be a
        collection of items
    ``child_of``
        is a child (descendant) of a ``value`` record (value can be either
        one item or a list of items).

        Takes the semantics of the model into account (i.e following the
        relationship field named by
        :attr:`~odoo.models.Model._parent_name`).
    ``parent_of``
        is a parent (ascendant) of a ``value`` record (value can be either
        one item or a list of items).

        Takes the semantics of the model into account (i.e following the
        relationship field named by
        :attr:`~odoo.models.Model._parent_name`).
    ``any`` (and ``not any``)
        matches if any record in the relationship traversal through
        ``field_expr`` (:class:`~odoo.fields.Many2one`,
        :class:`~odoo.fields.One2many`, or :class:`~odoo.fields.Many2many`)
        satisfies the provided domain ``value``.
        The ``field_expr`` should be a field name.
    ``any!`` (and ``not any!``)
        like ``any``, but bypasses access checks.

* ``value``
    variable type, must be comparable (through ``operator``) to the named
    field.

.. example::

    To search for partners named *ABC*, with a phone or mobile number containing *7620*::

        Domain('name', '=', 'ABC') & (
          Domain('phone', 'ilike', '7620') | Domain('mobile', 'ilike', '7620')
        )

    To search sales orders to invoice that have at least one line with
    a product that is out of stock::

        Domain('invoice_status', '=', 'to invoice') \
          & Domain('order_line', 'any', Domain('product_id.qty_available', '<=', 0))

    To search for all partners born in the month of February::

        Domain('birthday.month_number', '=', 2)

:class:`~odoo.fields.Domain` can be used to serialize the domain as a ``list``
of simple conditions represented by 3-item ``tuple`` (or a ``list``).
Such a serialized form may be sometimes faster to read or write.
Domain conditions can be combined using logical operators in a *prefix* notation.
You can combine 2 domains using ``'&'`` (AND), ``'|'`` (OR)
and you can negate 1 using ``'!'`` (NOT).

.. code-block:: python

    # parse a domain (from list to Domain)
    domain = Domain([('name', '=', 'abc'), ('phone', 'like', '7620')])

    # serialize domain as a list (from Domain to list)
    domain_list = list(domain)
    # will output:
    # ['&', ('name', '=', 'abc'), ('phone', 'like', '7620')]

.. automethod:: odoo.fields.Domain.iter_conditions

.. automethod:: odoo.fields.Domain.map_conditions

.. automethod:: odoo.fields.Domain.optimize

.. automethod:: odoo.fields.Domain.validate

.. _reference/orm/dynamic_values:

Dynamic time values
~~~~~~~~~~~~~~~~~~~

In the context of search domains, for
:ref:`date and datetime fields <reference/fields/date>`, the value can be a
moment relative to *now* in the timezone of the user. A simple language is
provided to specify these dates. It is a space-separated string of terms.
The first term is optional and is "today" (at midnight) or "now".
Then, each term starts with "+" (add), "-" (subtract) or "=" (set), followed by
an integer and date unit or a lower-case weekday.

The date units are: "d" (days), "w" (weeks), "m" (months), "y" (years),
"H" (hours), "M" (minutes), "S" (seconds).
For weekdays, "+" and "-" mean next and previous weekday (unless we are already
in that weekday) and "=" means in current week starting on Monday.
When setting a date, the lower-units (hours, minutes and seconds) are set to 0.

.. example::

    .. code-block:: python

        Domain('some_date', '<', 'now')  # now
        Domain('some_date', '<', 'today')  # today at midnight
        Domain('some_date', '<', '-3d +1H')  # now - 3 days + 1 hour
        Domain('some_date', '<', '=3H')  # today at 3:00:00
        Domain('some_date', '<', '=5d')  # 5th day of current month at midnight
        Domain('some_date', '<', '=1m')  # January, same day of month at midnight
        Domain('some_date', '>=', '=monday -1w')  # Monday of the previous week

Unlink
------

.. automethod:: Model.unlink

.. _reference/orm/records/info:

Record(set) information
-----------------------

.. autoattribute:: Model.ids

.. attribute:: env

    Returns the environment of the given recordset.

    :type: :class:`~odoo.api.Environment`

.. todo:: Environment documentation

.. automethod:: Model.exists

.. automethod:: Model.ensure_one

.. automethod:: Model.get_metadata

.. _reference/orm/records/operations:

Operations
----------

Recordsets are immutable, but sets of the same model can be combined using
various set operations, returning new recordsets.

.. addition preserves order but can introduce duplicates

* ``record in set`` returns whether ``record`` (which must be a 1-element
  recordset) is present in ``set``. ``record not in set`` is the inverse
  operation
* ``set1 <= set2`` and ``set1 < set2`` return whether ``set1`` is a subset
  of ``set2`` (resp. strict)
* ``set1 >= set2`` and ``set1 > set2`` return whether ``set1`` is a superset
  of ``set2`` (resp. strict)
* ``set1 | set2`` returns the union of the two recordsets, a new recordset
  containing all records present in either source
* ``set1 & set2`` returns the intersection of two recordsets, a new recordset
  containing only records present in both sources
* ``set1 - set2`` returns a new recordset containing only records of ``set1``
  which are *not* in ``set2``

Recordsets are iterable so the usual Python tools are available for
transformation (:func:`python:map`, :func:`python:sorted`,
:func:`~python:itertools.ifilter`, ...) however these return either a
:class:`python:list` or an :term:`python:iterator`, removing the ability to
call methods on their result, or to use set operations.

Recordsets therefore provide the following operations returning recordsets themselves
(when possible):

Filter
~~~~~~

.. automethod:: Model.filtered

.. automethod:: Model.filtered_domain

Map
~~~

.. automethod:: Model.mapped

.. note::

    Since V13, multi-relational field access is supported and works like a mapped call:

    .. code-block:: python3

        records.partner_id  # == records.mapped('partner_id')
        records.partner_id.bank_ids  # == records.mapped('partner_id.bank_ids')
        records.partner_id.mapped('name')  # == records.mapped('partner_id.name')

Sort
~~~~

.. automethod:: Model.sorted

Grouping
~~~~~~~~

.. automethod:: Model.grouped

.. _reference/orm/inheritance:

Inheritance and extension
=========================

Odoo provides three different mechanisms to extend models in a modular way:

* creating a new model from an existing one, adding new information to the
  copy but leaving the original module as-is
* extending models defined in other modules in-place, replacing the previous
  version
* delegating some of the model's fields to records it contains

.. image:: orm/inheritance_methods.png
    :align: center

Classical inheritance
---------------------

When using the :attr:`~odoo.models.Model._inherit` and
:attr:`~odoo.models.Model._name` attributes together, Odoo creates a new
model using the existing one (provided via
:attr:`~odoo.models.Model._inherit`) as a base. The new model gets all the
fields, methods and meta-information (defaults & al) from its base.

.. code-block:: python

    class Inheritance0(models.Model):
        _name = 'inheritance.0'
        _description = 'Inheritance Zero'

        name = fields.Char()

        def call(self):
            return self.check("model 0")

        def check(self, s):
            return "This is {} record {}".format(s, self.name)

    class Inheritance1(models.Model):
        _name = 'inheritance.1'
        _inherit = ['inheritance.0']
        _description = 'Inheritance One'

        def call(self):
            return self.check("model 1")

and using them::

    a = env['inheritance.0'].create({'name': 'A'})
    b = env['inheritance.1'].create({'name': 'B'})

    a.call()
    b.call()

will yield:

    "This is model 0 record A"
    "This is model 1 record B"

the second model has inherited from the first model's ``check`` method and its
``name`` field, but overridden the ``call`` method, as when using standard
:ref:`Python inheritance <python:tut-inheritance>`.

Extension
---------

When using :attr:`~odoo.models.Model._inherit` but leaving out
:attr:`~odoo.models.Model._name`, the new model replaces the existing one,
essentially extending it in-place. This is useful to add new fields or methods
to existing models (created in other modules), or to customize or reconfigure
them (e.g. to change their default sort order)

.. code-block:: python

    class Extension0(models.Model):
        _name = 'extension.0'
        _description = 'Extension zero'

        name = fields.Char(default="A")

    class Extension0(models.Model):
        _inherit = 'extension.0'

        description = fields.Char(default="Extended")

.. code-block:: python3

    record = env['extension.0'].create({})
    record.read()[0]

will yield::

    {'name': "A", 'description': "Extended"}

.. warning:: When :attr:`~odoo.models.Model._inherit` is set to a string,
    then :attr:`~odoo.models.Model._name` is set to the same value,
    unless `_name` is explicitly set.

.. note::

    It will also yield the various :ref:`automatic fields
    <reference/fields/automatic>` unless they've been disabled

Delegation
----------

The third inheritance mechanism provides more flexibility (it can be altered
at runtime) but less power: using the :attr:`~odoo.models.Model._inherits`
a model *delegates* the lookup of any field not found on the current model
to "children" models. The delegation is performed via
:class:`~odoo.fields.Reference` fields automatically set up on the parent
model.

The main difference is in the meaning. When using Delegation, the model
**has one** instead of **is one**, turning the relationship in a composition
instead of inheritance

.. code-block:: python

    class Screen(models.Model):
        _name = 'delegation.screen'
        _description = 'Screen'

        size = fields.Float(string='Screen Size in inches')

    class Keyboard(models.Model):
        _name = 'delegation.keyboard'
        _description = 'Keyboard'

        layout = fields.Char(string='Layout')

    class Laptop(models.Model):
        _name = 'delegation.laptop'
        _description = 'Laptop'

        _inherits = {
            'delegation.screen': 'screen_id',
            'delegation.keyboard': 'keyboard_id',
        }

        name = fields.Char(string='Name')
        maker = fields.Char(string='Maker')

        # a Laptop has a screen
        screen_id = fields.Many2one('delegation.screen', required=True, ondelete="cascade")
        # a Laptop has a keyboard
        keyboard_id = fields.Many2one('delegation.keyboard', required=True, ondelete="cascade")

.. code-block:: python3

    record = env['delegation.laptop'].create({
        'screen_id': env['delegation.screen'].create({'size': 13.0}).id,
        'keyboard_id': env['delegation.keyboard'].create({'layout': 'QWERTY'}).id,
    })
    record.size
    record.layout

will result in::

    13.0
    'QWERTY'

and it's possible to write directly on the delegated field::

    record.write({'size': 14.0})

.. warning:: when using delegation inheritance, methods are *not* inherited,
             only fields

.. warning::

    * `_inherits` is more or less implemented, avoid it if you can;
    * chained `_inherits` is essentially not implemented, we cannot guarantee anything on the final behavior.


Fields Incremental Definition
-----------------------------

A field is defined as class attribute on a model class. If the model
is extended, one can also extend the field definition by redefining
a field with the same name and same type on the subclass.
In that case, the attributes of the field are taken from the parent class
and overridden by the ones given in subclasses.

For instance, the second class below only adds a tooltip on the field
``state``

.. code-block:: python

    class FirstFoo(models.Model):
        state = fields.Selection([...], required=True)

    class FirstFoo(models.Model):
        _inherit = ['first.foo']
        state = fields.Selection(help="Blah blah blah")

    class WrongFirstFooClassName(models.Model):
        _name = 'first.foo'  # force the model name
        _inherit = ['first.foo']
        state = fields.Selection(help="Blah blah blah")

.. _reference/exceptions:

Error management
================

.. automodule:: odoo.exceptions
    :members: AccessDenied, AccessError, CacheMiss, MissingError, RedirectWarning, UserError, ValidationError


==================================================
SECTION: performance.rst
PATH: developer/reference/backend/performance.rst
==================================================

:custom-css: performance.css

===========
Performance
===========

.. _performance/profiling:

Profiling
=========

.. currentmodule:: odoo.tools.profiler

Profiling is about analysing the execution of a program and measure aggregated data. These data can
be the elapsed time for each function, the executed SQL queries...

While profiling does not improve the performance of a program by itself, it can prove very helpful
in finding performance issues and identifying which part of the program is responsible for them.

Odoo provides an integrated profiling tool that allows recording all executed queries and stack
traces during execution. It can be used to profile either a set of requests of a user session, or a
specific portion of code. Profiling results can be either inspected with the integrated `speedscope
<https://github.com/jlfwong/speedscope>`_ :dfn:`open source app allowing to visualize a flamegraph`
view or analyzed with custom tools by first saving them in a JSON file or in the database.

.. _performance/profiling/enable:

Enable the profiler
-------------------

The profiler can either be enabled from the user interface, which is the easiest way to do so but
allows profiling only web requests, or from Python code, which allows profiling any piece of code
including tests.

.. tabs::

   .. tab:: Enable from the user interface

      #. :ref:`Enable the developer mode <developer-mode>`.
      #. Before starting a profiling session, the profiler must be enabled globally on the database.
         This can be done in two ways:

         - Open the :ref:`developer mode tools <developer-mode/tools>`, then toggle the
           :guilabel:`Enable profiling` button. A wizard suggests a set of expiry times for the
           profiling. Click on :guilabel:`ENABLE PROFILING` to enable the profiler globally.

           .. image:: performance/enable_profiling_wizard.png

         - Go to :guilabel:`Settings --> General Settings --> Performance` and set the desired time to
           the field :guilabel:`Enable profiling until`.

      #. After the profiler is enabled on the database, users can enable it on their session. To do
         so, toggle the :guilabel:`Enable profiling` button in the :ref:`developer mode tools
         <developer-mode/tools>` again. By default, the recommended options :guilabel:`Record
         sql` and :guilabel:`Record traces` are enabled. To learn more about the different options,
         head over to :ref:`performance/profiling/collectors`.

         .. image:: performance/profiling_debug_menu.png

      When the profiler is enabled, all the requests made to the server are profiled and saved into
      an `ir.profile` record. Such records are grouped into the current profiling session which
      spans from when the profiler was enabled until it is disabled.

      .. note::
         Odoo Online databases cannot be profiled.

   .. tab:: Enable from Python code

      Starting the profiler manually can be convenient to profile a specific method or a part of the
      code. This code can be a test, a compute method, the entire loading, etc.

      To start the profiler from Python code, call it as a context manager. You may specify *what*
      you want to record through the parameters. A shortcut is available for profiling test classes:
      :code:`self.profile()`. See :ref:`performance/profiling/collectors` for more information on
      the `collectors` parameter.

      .. example::

         .. code-block:: python

            with Profiler():
                do_stuff()

      .. example::

         .. code-block:: python

            with Profiler(collectors=['sql', PeriodicCollector(interval=0.1)]):
                do_stuff()

      .. example::

         .. code-block:: python

            with self.profile():
                with self.assertQueryCount(__system__=1211):
                    do_stuff()

         .. note::
            The profiler is called outside of the `assertQueryCount` in order to catch queries made
            when exiting the context manager (e.g., flush).

      .. autoclass:: Profiler()
         :special-members: __init__

      When the profiler is enabled, all executions of a test method are profiled and saved into an
      `ir.profile` record. Such records are grouped into a single profiling session. This is
      especially useful when using the :code:`@warmup` and :code:`@users` decorators.

      .. tip::
         It can be complicated to analyze profiling results of a method that is called several times
         because all the calls are grouped together in the stack trace. Add an **execution context**
         as a context manager to break down the results into multiple frames.

         .. example::

            .. code-block:: python

               for index in range(max_index):
                   with ExecutionContext(current_index=index):  # Identify each call in speedscope results.
                       do_stuff()

.. _performance/profiling/analyse:

Analyse the results
-------------------

To browse the profiling results, make sure that the :ref:`profiler is enabled globally on the
database <performance/profiling/enable>`, then open the :ref:`developer mode tools
<developer-mode/tools>` and click on the button in the top-right corner of the profiling
section. A list view of the `ir.profile` records grouped by profiling session opens.

.. image:: performance/profiling_web.png
   :align: center

Each record has a clickable link that opens the speedscope results in a new tab.

.. image:: performance/flamegraph_example.png
   :align: center

Speedscope falls out of the scope of this documentation but there are a lot of tools to try: search,
highlight of similar frames, zoom on frame, timeline, left heavy, sandwich view...

Depending on the profiling options that were activated, Odoo generates different view modes that you
can access from the top menu.

.. image:: performance/speedscope_modes.png
   :align: center

- The :guilabel:`Combined` view shows all the SQL queries and traces merged togethers.
- The :guilabel:`Combined no context` view shows the same result but ignores the saved execution
  context <performance/profiling/enable>`.
- The :guilabel:`sql (no gap)` view shows all the SQL queries as if they were executed one after
  another, without any Python logic. This is useful for optimizing SQL only.
- The :guilabel:`sql (density)` view shows only all the SQL queries, leaving gap between them. This
  can be useful to spot if eiter SQL or Python code is the problem, and to identify zones in where
  many small queries could be batched.
- The :guilabel:`frames` view shows the results of only the :ref:`periodic collector
  <performance/profiling/collectors/periodic>`.

.. important::
   Even though the profiler has been designed to be as light as possible, it can still impact
   performance, especially when using the :ref:`Sync collector
   <performance/profiling/collectors/sync>`. Keep that in mind when analyzing speedscope results.

.. _performance/profiling/collectors:

Collectors
----------

Whereas the profiler is about the *when* of profiling, the collectors take care of the *what*.

Each collector specializes in collecting profiling data in its own format and manner. They can be
individually enabled from the user interface through their dedicated toggle button in the
:ref:`developer mode tools <developer-mode/tools>`, or from Python code through their key or
class.

There are currently four collectors available in Odoo:

.. list-table::
   :header-rows: 1

   * - Name
     - Toggle button
     - Python key
     - Python class
   * - :ref:`SQL collector <performance/profiling/collectors/sql>`
     - :guilabel:`Record sql`
     - `sql`
     - `SqlCollector`
   * - :ref:`Periodic collector <performance/profiling/collectors/periodic>`
     - :guilabel:`Record traces`
     - `traces_async`
     - `PeriodicCollector`
   * - :ref:`QWeb collector <performance/profiling/collectors/qweb>`
     - :guilabel:`Record qweb`
     - `qweb`
     - `QwebCollector`
   * - :ref:`Sync collector <performance/profiling/collectors/sync>`
     - No
     - `traces_sync`
     - `SyncCollector`

By default, the profiler enables the SQL and the Periodic collectors. Both when it is enabled from
the user interface or Python code.

.. _performance/profiling/collectors/sql:

SQL collector
~~~~~~~~~~~~~

The SQL collector saves all the SQL queries made to the database in the current thread (for all
cursors), as well as the stack trace. The overhead of the collector is added to the analysed thread
for each query, which means that using it on a lot of small queries may impact execution time and
other profilers.

It is especially useful to debug query counts, or to add information to the :ref:`Periodic collector
<performance/profiling/collectors/periodic>` in the combined speedscope view.

.. autoclass:: SQLCollector

.. _performance/profiling/collectors/periodic:

Periodic collector
~~~~~~~~~~~~~~~~~~

This collector runs in a separate thread and saves the stack trace of the analysed thread at every
interval. The interval (by default 10 ms) can be defined through the :guilabel:`Interval` option in
the user interface, or the `interval` parameter in Python code.

.. warning::
   If the interval is set at a very low value, profiling long requests will generate memory issues.
   If the interval is set at a very high value, information on short function executions will be
   lost.

It is one of the best way to analyse performance as it should have a very low impact on the
execution time thanks to its separate thread.

.. autoclass:: PeriodicCollector

.. _performance/profiling/collectors/qweb:

QWeb collector
~~~~~~~~~~~~~~

This collector saves the Python execution time and queries of all directives. As for the :ref:`SQL
collector <performance/profiling/collectors/sql>`, the overhead can be important when executing a
lot of small directives. The results are different from other collectors in terms of collected data,
and can be analysed from the `ir.profile` form view using a custom widget.

It is mainly useful for optimizing views.

.. autoclass:: QwebCollector

.. _performance/profiling/collectors/sync:

Sync collector
~~~~~~~~~~~~~~

This collector saves the stack for every function's call and return and runs on the same thread,
which greatly impacts performance.

It can be useful to debug and understand complex flows, and follow their execution in the code. It
is however not recommended for performance analysis because the overhead is high.

.. autoclass:: SyncCollector

.. _performance/profiling/pitfalls:

Performance pitfalls
--------------------

- Be careful with randomness. Multiple executions may lead to different results. E.g., a garbage
  collector being triggered during execution.
- Be careful with blocking calls. In some cases, external `c_call` may take some time before
  releasing the GIL, thus leading to unexpected long frames with the :ref:`Periodic collector
  <performance/profiling/collectors/periodic>`. This should be detected by the profiler and give a
  warning. It is possible to trigger the profiler manually before such calls if needed.
- Pay attention to the cache. Profiling before that the `view`/`assets`/... are in cache can lead to
  different results.
- Be aware of the profiler's overhead. The :ref:`SQL collector
  <performance/profiling/collectors/sql>`'s overhead can be important when a lot of small queries
  are executed. Profiling is practical to spot a problem but you may want to disable the profiler in
  order to measure the real impact of a code change.
- Profiling results can be memory intensive. In some cases (e.g., profiling an install or a long
  request), it is possible that you reach memory limit, especially when rendering the speedscope
  results, which can lead to an HTTP 500 error. In this case, you may need to start the server with
  a higher memory limit: `--limit-memory-hard $((8*1024**3))`.

.. _performance/good_practices:

Good practices
==============

.. _performance/good_practices/batch:

Batch operations
----------------

When working with recordsets, it is almost always better to batch operations.

.. example::
   Don't call a method that runs SQL queries while looping over a recordset because it will do so
   for each record of the set.

   .. rst-class:: bad-example
   .. code-block:: python

      def _compute_count(self):
          for record in self:
              domain = [('related_id', '=', record.id)]
              record.count = other_model.search_count(domain)

   Instead, replace the `search_count` with a `_read_group` to execute one SQL query for the entire
   batch of records.

   .. rst-class:: good-example
   .. code-block:: python

      def _compute_count(self):
          domain = [('related_id', 'in', self.ids)]
          counts_data = other_model._read_group(domain, ['related_id'], ['__count'])
          mapped_data = dict(counts_data)
          for record in self:
              record.count = mapped_data.get(record, 0)

   .. note::
      This example is not optimal nor correct in all cases. It is only a substitute for a
      `search_count`. Another solution could be to prefetch and count the inverse `One2many` field.

.. example::
   Don't create records one after another.

   .. rst-class:: bad-example
   .. code-block:: python

      for name in ['foo', 'bar']:
          model.create({'name': name})

   Instead, accumulate the create values and call the `create` method on the batch. Doing so has
   mostly no impact and helps the framework optimize fields computation.

   .. rst-class:: good-example
   .. code-block:: python

      create_values = []
      for name in ['foo', 'bar']:
          create_values.append({'name': name})
      records = model.create(create_values)

.. example::
   Fail to prefetch the fields of a recordset while browsing a single record inside a loop.

   .. rst-class:: bad-example
   .. code-block:: python

      for record_id in record_ids:
          model.browse(record_id)
          record.foo  # One query is executed per record.

   Instead, browse the entire recordset first.

   .. rst-class:: good-example
   .. code-block:: python

      records = model.browse(record_ids)
      for record in records:
          record.foo  # One query is executed for the entire recordset.

   We can verify that the records are prefetched in batch by reading the field `prefetch_ids` which
   includes each of the record ids.browsing all records together is unpractical,

   If needed, the `with_prefetch` method can be used to disable batch prefetching:

   .. code-block:: python

      for values in values_list:
          message = self.browse(values['id']).with_prefetch(self.ids)

.. _performance/good_practices/algorithmic_complexity:

Reduce the algorithmic complexity
---------------------------------

Algorithmic complexity is a measure of how long an algorithm would take to complete in regard to the
size `n` of the input. When the complexity is high, the execution time can grow quickly as the input
becomes larger. In some cases, the algorithmic complexity can be reduced by preparing the input's
data correctly.

.. example::
   For a given problem, let's consider a naive algorithm crafted with two nested loops for which the
   complexity in in O(nÂ²).

   .. rst-class:: bad-example
   .. code-block:: python

      for record in self:
          for result in results:
              if results['id'] == record.id:
                  record.foo = results['foo']
                  break

   Assuming that all results have a different id, we can prepare the data to reduce the complexity.

   .. rst-class:: good-example
   .. code-block:: python

      mapped_result = {result['id']: result['foo'] for result in results}
      for record in self:
          record.foo = mapped_result.get(record.id)

.. example::
   Choosing the bad data structure to hold the input can lead to quadratic complexity.

   .. rst-class:: bad-example
   .. code-block:: python

      invalid_ids = self.search(domain).ids
      for record in self:
          if record.id in invalid_ids:
              ...

   If `invalid_ids` is a list-like data structure, the complexity of the algorithm may be quadratic.

   Instead, prefer using set operations like casting `invalid_ids` to a set.

   .. rst-class:: good-example
   .. code-block:: python

      invalid_ids = set(invalid_ids)
      for record in self:
          if record.id in invalid_ids:
              ...

   Depending on the input, recordset operations can also be used.

   .. rst-class:: good-example
   .. code-block:: python

      invalid_ids = self.search(domain)
      for record in self - invalid_ids:
          ...

.. _performance/good_practices/index:

Use indexes
-----------

Database indexes can help fasten search operations, be it from a search in the or through the user
interface.

.. code-block:: python

   name = fields.Char(string="Name", index=True)

.. warning::
   Be careful not to index every field as indexes consume space and impact on performance when
   executing one of `INSERT`, `UPDATE`, and `DELETE`.


==================================================
SECTION: reports.rst
PATH: developer/reference/backend/reports.rst
==================================================


.. highlight:: xml

.. _reference/reports:

.. _reference/reports/report:

============
QWeb Reports
============

Reports are written in HTML/QWeb, like website views in Odoo. You can use
the usual :ref:`QWeb control flow tools <reference/qweb>`. The PDF rendering
itself is performed by wkhtmltopdf_.

Reports are declared using a :ref:`report action <reference/actions/report>`,
and a :ref:`reference/reports/templates` for the action to use.

If useful or necessary, it is possible to specify a
:ref:`reference/reports/paper_formats` for the report report.

.. _reference/reports/templates:

Report template
===============

Report templates will always provide the following variables:

``time``
    a reference to :mod:`python:time` from the Python standard library
``user``
    ``res.user`` record for the user printing the report
``res_company``
    record for the current ``user``'s company
``website``
    the current website object, if any (this item can be present but ``None``)
``web_base_url``
    the base url for the webserver
``context_timestamp``
    a function taking :class:`python:datetime.datetime` in UTC\ [#unzoned]_ and
    converting it to the timezone of the user printing the report

Minimal viable template
-----------------------

A minimal template would look like::

    <template id="report_invoice">
        <t t-call="web.html_container">
            <t t-foreach="docs" t-as="o">
                <t t-call="web.external_layout">
                    <div class="page">
                        <h2>Report title</h2>
                        <p>This object's name is <span t-field="o.name"/></p>
                    </div>
                </t>
            </t>
        </t>
    </template>

Calling ``external_layout`` will add the default header and footer on your
report. The PDF body will be the content inside the ``<div
class="page">``. The template's ``id`` must be the name specified in the
report declaration; for example ``account.report_invoice`` for the above
report. Since this is a QWeb template, you can access all the fields of the
``docs`` objects received by the template.

By default, the rendering context will also expose the following items:

``docs``
    records for the current report
``doc_ids``
    list of ids for the ``docs`` records
``doc_model``
    model for the ``docs`` records

If you wish to access other records/models in the template, you will need
:ref:`a custom report <reference/reports/custom_reports>`, however in that case
you will have to provide the items above if you need them.

Translatable Templates
----------------------

If you wish to translate reports (to the language of a partner, for example),
you need to define two templates:

* The main report template
* The translatable document

You can then call the translatable document from your main template with the attribute
``t-lang`` set to a language code (for example ``fr`` or ``en_US``) or to a record field.
You will also need to re-browse the related records with the proper context if you use
fields that are translatable (like country names, sales conditions, etc.)

.. warning::

    If your report template does not use translatable record fields, re-browsing the record
    in another language is *not* necessary and will impact performances.

For example, let's look at the Sale Order report from the Sale module::

    <!-- Main template -->
    <template id="report_saleorder">
        <t t-call="web.html_container">
            <t t-foreach="docs" t-as="doc">
                <t t-call="sale.report_saleorder_document" t-lang="doc.partner_id.lang"/>
            </t>
        </t>
    </template>

    <!-- Translatable template -->
    <template id="report_saleorder_document">
        <!-- Re-browse of the record with the partner lang -->
        <t t-set="doc" t-value="doc.with_context(lang=doc.partner_id.lang)" />
        <t t-call="web.external_layout">
            <div class="page">
                <div class="oe_structure"/>
                <div class="row">
                    <div class="col-6">
                        <strong t-if="doc.partner_shipping_id == doc.partner_invoice_id">Invoice and shipping address:</strong>
                        <strong t-if="doc.partner_shipping_id != doc.partner_invoice_id">Invoice address:</strong>
                        <div t-field="doc.partner_invoice_id" t-options="{&quot;no_marker&quot;: True}"/>
                    <...>
                <div class="oe_structure"/>
            </div>
        </t>
    </template>


The main template calls the translatable template with ``doc.partner_id.lang`` as a
``t-lang`` parameter, so it will be rendered in the language of the partner. This way,
each Sale Order will be printed in the language of the corresponding customer. If you wish
to translate only the body of the document, but keep the header and footer in a default
language, you could call the report's external layout this way::

    <t t-call="web.external_layout" t-lang="en_US">

.. tip::

    Please take note that this works only when calling external templates, you will not be
    able to translate part of a document by setting a ``t-lang`` attribute on an xml node other
    than ``t-call``. If you wish to translate part of a template, you can create an external
    template with this partial template and call it from the main one with the ``t-lang``
    attribute.


Barcodes
--------

Barcodes are images returned by a controller and can easily be embedded in
reports thanks to the QWeb syntax (e.g. see :ref:`reference/qweb/attributes`):

.. code-block:: html

    <img t-att-src="'/report/barcode/QR/%s' % 'My text in qr code'"/>

More parameters can be passed as a query string

.. code-block:: html

    <img t-att-src="'/report/barcode/?
        barcode_type=%s&amp;value=%s&amp;width=%s&amp;height=%s'%('QR', 'text', 200, 200)"/>


Useful Remarks
--------------

* Twitter Bootstrap and FontAwesome classes can be used in your report
  template
* Local CSS can be put directly in the template
* Global CSS can be inserted in the main report layout by inheriting its
  template and inserting your CSS::

    <template id="report_saleorder_style" inherit_id="report.style">
      <xpath expr=".">
        <t>
          .example-css-class {
            background-color: red;
          }
        </t>
      </xpath>
    </template>

* If it appears that your PDF report is missing the styles, please check
  :ref:`these instructions <reference/backend/reporting/printed-reports/pdf-without-styles>`.

.. _reference/reports/paper_formats:

Paper Format
============

Paper formats are records of ``report.paperformat`` and can contain the
following attributes:

``name`` (mandatory)
    only useful as a mnemonic/description of the report when looking for one
    in a list of some sort
``description``
    a small description of your format
``format``
    either a predefined format (A0 to A9, B0 to B10, Legal, Letter,
    Tabloid,...) or ``custom``; A4 by default. You cannot use a non-custom
    format if you define the page dimensions.
``dpi``
    output DPI; 90 by default
``margin_top``, ``margin_bottom``, ``margin_left``, ``margin_right``
    margin sizes in mm
``page_height``, ``page_width``
    page dimensions in mm
``orientation``
    Landscape or Portrait
``header_line``
    boolean to display a header line
``header_spacing``
    header spacing in mm

Example::

    <record id="paperformat_frenchcheck" model="report.paperformat">
        <field name="name">French Bank Check</field>
        <field name="default" eval="True"/>
        <field name="format">custom</field>
        <field name="page_height">80</field>
        <field name="page_width">175</field>
        <field name="orientation">Portrait</field>
        <field name="margin_top">3</field>
        <field name="margin_bottom">3</field>
        <field name="margin_left">3</field>
        <field name="margin_right">3</field>
        <field name="header_line" eval="False"/>
        <field name="header_spacing">3</field>
        <field name="dpi">80</field>
    </record>

.. _reference/reports/custom_reports:

Custom Reports
==============

By default, the reporting system builds rendering values based on the target
model specified through the ``model`` field.

However, it will first look for a model named
:samp:`report.{module.report_name}` and call that model's
``_get_report_values(doc_ids, data)`` in order to prepare the rendering data for
the template.

This can be used to include arbitrary items to use or display while rendering
the template, such as data from additional models:

.. code-block:: python

    from odoo import api, models

    class ParticularReport(models.AbstractModel):
        _name = 'report.module.report_name'

        def _get_report_values(self, docids, data=None):
            # get the report action back as we will need its data
            report = self.env['ir.actions.report']._get_report_from_name('module.report_name')
            # get the records selected for this rendering of the report
            obj = self.env[report.model].browse(docids)
            # return a custom rendering context
            return {
                'lines': docids.get_lines()
            }

.. warning::

    When using a custom report, the "default" document-related items
    (``doc_ids``, ``doc_model`` and ``docs``) will *not* be included. If you
    want them, you will need to include them yourself.

    In the example above, the rendering context will contain the "global" values
    as well as the ``lines`` we put in there but nothing else.

.. _reference/reports/custom_fonts:

Custom fonts
============

If you want to use custom fonts you will need to add your custom font and the related less/CSS to the ``web.reports_assets_common`` assets bundle.
Adding your custom font(s) to ``web.assets_common`` or ``web.assets_backend`` will not make your font available in QWeb reports.

Example::

    <template id="report_assets_common_custom_fonts" name="Custom QWeb fonts" inherit_id="web.report_assets_common">
        <xpath expr="." position="inside">
            <link href="/your_module/static/src/less/fonts.less" rel="stylesheet" type="text/less"/>
        </xpath>
    </template>

You will need to define your ``@font-face`` within this less file, even if you've used in another assets bundle (other than ``web.reports_assets_common``).

Example::

    @font-face {
        font-family: 'MonixBold';
        src: local('MonixBold'), local('MonixBold'), url(/your_module/static/fonts/MonixBold-Regular.otf) format('opentype');
    }

    .h1-title-big {
        font-family: MonixBold;
        font-size: 60px;
        color: #3399cc;
    }

After you've added the less into your assets bundle you can use the classes - in this example ``h1-title-big`` - in your custom QWeb report.

Reports are web pages
=====================

Reports are dynamically generated by the report module and can be accessed
directly via URL:

For example, you can access a Sale Order report in html mode by going to
\http://<server-address>/report/html/sale.report_saleorder/38

Or you can access the pdf version at
\http://<server-address>/report/pdf/sale.report_saleorder/38

.. [#unzoned] it does not matter what timezone the :class:`python:datetime`
              object is actually in (including no timezone), its timezone will
              unconditionally be *set* to UTC before being adjusted to the
              user's

.. _wkhtmltopdf: https://wkhtmltopdf.org


==================================================
SECTION: security.rst
PATH: developer/reference/backend/security.rst
==================================================


.. _reference/security:

================
Security in Odoo
================

Aside from manually managing access using custom code, Odoo provides two main
data-driven mechanisms to manage or restrict access to data.

Both mechanisms are linked to specific users through *groups*: a user belongs
to any number of groups, and security mechanisms are associated to groups,
thus applying security mechanisms to users.

.. class:: res.groups

    .. attribute:: name

        serves as user-readable identification for the group (spells out the
        role / purpose of the group)

    .. attribute:: category_id

        The *module category*, serves to associate groups with an Odoo App
        (~a set of related business models) and convert them into an exclusive
        selection in the user form.

        .. todo:: clarify & document special cases & relationship between
                  groups & categories better

    .. attribute:: implied_ids

        Other groups to set on the user alongside this one. This is a
        convenience pseudo-inheritance relationship: it's possible to
        explicitly remove implied groups from a user without removing the
        implier.

    .. attribute:: comment

        Additional notes on the group e.g.

.. _reference/security/acl:

Access Rights
=============

*Grants* access to an entire model for a given set of operations. If no access
rights matches an operation on a model for a user (through their group), the
user doesn't have access.

Access rights are additive, a user's accesses are the union of the accesses
they get through all their groups e.g. given a user who is part of group A
granting read and create access and a group B granting update access, the user
will have all three of create, read, and update.

.. class:: ir.model.access

    .. attribute:: name

        The purpose or role of the group.

    .. attribute:: model_id

        The model whose access the ACL controls.

    .. attribute:: group_id

        The :class:`res.groups` to which the accesses are granted, an empty
        :attr:`group_id` means the ACL is granted to *every user*
        (non-employees e.g. portal or public users).

    The :samp:`perm_{method}` attributes grant the corresponding CRUD access
    when set, they are all unset by default.

    .. attribute:: perm_create
    .. attribute:: perm_read
    .. attribute:: perm_write
    .. attribute:: perm_unlink

.. _reference/security/rules:

Record Rules
============

Record rules are *conditions* which must be satisfied in order for an operation
to be allowed. Record rules are evaluated record-by-record, following access
rights.

Record rules are default-allow: if access rights grant access and no rule
applies to the operation and model for the user, the access is granted.

.. class:: ir.rule

    .. attribute:: name

        The description of the rule.

    .. attribute:: model_id

        The model to which the rule applies.

    .. attribute:: groups

        The :class:`res.groups` to which access is granted (or not). Multiple
        groups can be specified. If no group is specified, the rule is *global*
        which is treated differently than "group" rules (see below).

    .. attribute:: global

        Computed on the basis of :attr:`groups`, provides easy access to the
        global status (or not) of the rule.

    .. attribute:: domain_force

        A predicate specified as a :ref:`domain <reference/orm/domains>`, the
        rule allows the selected operations if the domain matches the record,
        and forbids it otherwise.

        The domain is a *python expression* which can use the following
        variables:

        ``time``
            Python's :mod:`python:time` module.
        ``user``
            The current user, as a singleton recordset.
        ``company_id``
            The current user's currently selected company as a single company id
            (not a recordset).
        ``company_ids``
            All the companies to which the current user has access as a list of
            company ids (not a recordset), see
            :ref:`howto/company/security` for more details.

    The :samp:`perm_{method}` have completely different semantics than for
    :class:`ir.model.access`: for rules, they specify which operation the rules
    applies *for*. If an operation is not selected, then the rule is not checked
    for it, as if the rule did not exist.

    All operations are selected by default.

    .. attribute:: perm_create
    .. attribute:: perm_read
    .. attribute:: perm_write
    .. attribute:: perm_unlink

.. _reference/security/rules/global:

Global rules versus group rules
-------------------------------

There is a large difference between global and group rules in how they compose
and combine:

* Global rules *intersect*, if two global rules apply then *both* must be
  satisfied for the access to be granted, this means adding global rules always
  restricts access further.
* Group rules *unify*, if two group rules apply then *either* can be
  satisfied for the access to be granted. This means adding group rules can
  expand access, but not beyond the bounds defined by global rules.
* The global and group rulesets *intersect*, which means the first group rule
  being added to a given global ruleset will restrict access.

.. danger::

    Creating multiple global rules is risky as it's possible to create
    non-overlapping rulesets, which will remove all access.

.. _reference/security/fields:

Field Access
============

An ORM :class:`~odoo.fields.Field` can have a ``groups`` attribute
providing a list of groups (as a comma-separated string of
:term:`external identifiers`).

If the current user is not in one of the listed groups, he will not have
access to the field:

* restricted fields are automatically removed from requested views
* restricted fields are removed from :meth:`~odoo.models.Model.fields_get`
  responses
* attempts to (explicitly) read from or write to restricted fields results in
  an access error

.. todo::

    field access groups apply to the Superuser in fields_get but not in
    read/write...

.. _time module: https://docs.python.org/3/library/time.html


.. _reference/security/pitfalls:

Security Pitfalls
=================

As a developer, it is important to understand the security mechanisms and avoid
common mistakes leading to insecure code.

Unsafe Public Methods
---------------------

Any public method can be executed via a :ref:`RPC call
<api/external_api/calling_methods>` with the chosen parameters. The methods
starting with a ``_`` are not callable from an action button or external API.

On public methods, the record on which a method is executed and the parameters
can not be trusted, ACL being only verified during CRUD operations.

.. code-block:: python

    # this method is public and its arguments can not be trusted
    def action_done(self):
        if self.state == "draft" and self.env.user.has_group('base.manager'):
            self._set_state("done")

    # this method is private and can only be called from other python methods
    def _set_state(self, new_state):
        self.sudo().write({"state": new_state})

Making a method private is obviously not enough and care must be taken to use it
properly.

Bypassing the ORM
-----------------

You should never use the database cursor directly when the ORM can do the same
thing! By doing so you are bypassing all the ORM features, possibly the
automated behaviours like translations, invalidation of fields, ``active``,
access rights and so on.

And chances are that you are also making the code harder to read and probably
less secure.

.. code-block:: python

    # very very wrong
    self.env.cr.execute('SELECT id FROM auction_lots WHERE auction_id in (' + ','.join(map(str, ids))+') AND state=%s AND obj_price > 0', ('draft',))
    auction_lots_ids = [x[0] for x in self.env.cr.fetchall()]

    # no injection, but still wrong
    self.env.cr.execute('SELECT id FROM auction_lots WHERE auction_id in %s '\
               'AND state=%s AND obj_price > 0', (tuple(ids), 'draft',))
    auction_lots_ids = [x[0] for x in self.env.cr.fetchall()]

    # nearly there
    auction_lots_ids = [x[x] for x in self.env.execute_query(SQL("""
        SELECT id FROM auction_lots
        WHERE auction_id IN %s AND state = %s AND obj_price > 0
    """, tuple(ids), 'draft'))

    # better
    auction_lots_ids = self.search([('auction_id','in',ids), ('state','=','draft'), ('obj_price','>',0)])


SQL injections
~~~~~~~~~~~~~~

Care must be taken not to introduce SQL injections vulnerabilities when using
manual SQL queries. The vulnerability is present when user input is either
incorrectly filtered or badly quoted, allowing an attacker to introduce
undesirable clauses to a SQL query (such as circumventing filters or
executing ``UPDATE`` or ``DELETE`` commands).

The best way to be safe is to never, NEVER use Python string concatenation (+)
or string parameters interpolation (%) to pass variables to a SQL query string.

The second reason, which is almost as important, is that it is the job of the
database abstraction layer (psycopg2) to decide how to format query parameters,
not your job! For example psycopg2 knows that when you pass a list of values
it needs to format them as a comma-separated list, enclosed in parentheses !

Even better, there exists a :class:`~odoo.tools.SQL` wrapper to build queries
using templates that handles the formatting of inputs.
Check :ref:`SQL execution <reference/orm/sql>` for detailed usage.

.. code-block:: python

    # the following is very bad:
    #   - it's a SQL injection vulnerability
    #   - it's unreadable
    #   - it's not your job to format the list of ids
    self.env.cr.execute('SELECT distinct child_id FROM account_account_consol_rel ' +
               'WHERE parent_id IN ('+','.join(map(str, ids))+')')

    # better
    self.env.cr.execute('SELECT DISTINCT child_id '\
               'FROM account_account_consol_rel '\
               'WHERE parent_id IN %s',
               (tuple(ids),))

    # more readable
    self.env.cr.execute(SQL("""
        SELECT DISTINCT child_id
        FROM account_account_consol_rel
        WHERE parent_id IN %s
    """, tuple(ids)))

This is very important, so please be careful also when refactoring, and most
importantly do not copy these patterns!

Here is a memorable example to help you remember what the issue is about (but
do not copy the code there). Before continuing, please be sure to read the
online documentation of pyscopg2 to learn of to use it properly:

- `The problem with query parameters <http://initd.org/psycopg/docs/usage.html#the-problem-with-the-query-parameters>`_
- `How to pass parameters with psycopg2 <http://initd.org/psycopg/docs/usage.html#passing-parameters-to-sql-queries>`_
- `Advanced parameter types <http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types>`_
- `Psycopg documentation <https://www.psycopg.org/docs/sql.html>`_

Building the domains
--------------------

Domains are represented as lists and are serializable.
You would be tented to manipulate these lists directly, however it can
introduce subtle issues where the user could inject a domain if the input is
not normalized.
Use :class:`~odoo.fields.Domain` to handle safely the manipulation
of domains.

.. code-block:: python

    # bad
    # the user can just pass ['|', ('id', '>', 0)] to access all
    domain = ...  # passed by the user
    security_domain = [('user_id', '=', self.env.uid)]
    domain += security_domain  # can have a side-effect if this is a function argument
    self.search(domain)

    # better
    domain = Domain(...)
    domain &= Domain('user_id', '=', self.env.uid)
    self.search(domain)

Unescaped field content
-----------------------

When rendering content using JavaScript and XML, one may be tempted to use
a ``t-raw`` to display rich-text content. This should be avoided as a frequent
`XSS <https://en.wikipedia.org/wiki/Cross-site_scripting>`_ vector.

It is very hard to control the integrity of the data from the computation until
the final integration in the browser DOM. A ``t-raw`` that is correctly escaped
at the time of introduction may no longer be safe at the next bugfix or
refactoring.

.. code-block:: javascript

    QWeb.render('insecure_template', {
        info_message: "You have an <strong>important</strong> notification",
    })

.. code-block:: xml

    <div t-name="insecure_template">
        <div id="information-bar"><t t-raw="info_message" /></div>
    </div>

The above code may feel safe as the message content is controlled but is a bad
practice that may lead to unexpected security vulnerabilities once this code
evolves in the future.

.. code-block:: javascript

    // XSS possible with unescaped user provided content !
    QWeb.render('insecure_template', {
        info_message: "You have an <strong>important</strong> notification on " \
            + "the product <strong>" + product.name + "</strong>",
    })

While formatting the template differently would prevent such vulnerabilities.

.. code-block:: javascript

    QWeb.render('secure_template', {
        message: "You have an important notification on the product:",
        subject: product.name
    })

.. code-block:: xml

    <div t-name="secure_template">
        <div id="information-bar">
            <div class="info"><t t-esc="message" /></div>
            <div class="subject"><t t-esc="subject" /></div>
        </div>
    </div>

.. code-block:: css

    .subject {
        font-weight: bold;
    }

Creating safe content using :class:`~markupsafe.Markup`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

See the `official documentation <https://markupsafe.palletsprojects.com/>`_ for
explanations, but the big advantage of
:class:`~markupsafe.Markup` is that it's a very rich type overrinding
:class:`str` operations to *automatically escape parameters*.

This means that it's easy to create *safe* html snippets by using
:class:`~markupsafe.Markup` on a string literal and "formatting in"
user-provided (and thus potentially unsafe) content:

.. code-block:: pycon

    >>> Markup('<em>Hello</em> ') + '<foo>'
    Markup('<em>Hello</em> &lt;foo&gt;')
    >>> Markup('<em>Hello</em> %s') % '<foo>'
    Markup('<em>Hello</em> &lt;foo&gt;')

though it is a very good thing, note that the effects can be odd at times:

.. code-block:: pycon

    >>> Markup('<a>').replace('>', 'x')
    Markup('<a>')
    >>> Markup('<a>').replace(Markup('>'), 'x')
    Markup('<ax')
    >>> Markup('<a&gt;').replace('>', 'x')
    Markup('<ax')
    >>> Markup('<a&gt;').replace('>', '&')
    Markup('<a&amp;')

.. tip:: Most of the content-safe APIs actually return a
         :class:`~markupsafe.Markup` with all that implies.

The :class:`~markupsafe.escape` method (and its
alias :class:`~odoo.tools.misc.html_escape`) turns a `str` into
a :class:`~markupsafe.Markup` and escapes its content. It will not escape the
content of a :class:`~markupsafe.Markup` object.

.. code-block:: python

    def get_name(self, to_html=False):
        if to_html:
            return Markup("<strong>%s</strong>") % self.name  # escape the name
        else:
            return self.name

    >>> record.name = "<R&D>"
    >>> escape(record.get_name())
    Markup("&lt;R&amp;D&gt;")
    >>> escape(record.get_name(True))
    Markup("<strong>&lt;R&amp;D&gt;</strong>")  # HTML is kept

When generating HTML code, it is important to separate the structure (tags) from
the content (text).

.. code-block:: pycon

    >>> Markup("<p>") + "Hello <R&D>" + Markup("</p>")
    Markup('<p>Hello &lt;R&amp;D&gt;</p>')
    >>> Markup("%s <br/> %s") % ("<R&D>", Markup("<p>Hello</p>"))
    Markup('&lt;R&amp;D&gt; <br/> <p>Hello</p>')
    >>> escape("<R&D>")
    Markup('&lt;R&amp;D&gt;')
    >>> _("List of Tasks on project %s: %s",
    ...     project.name,
    ...     Markup("<ul>%s</ul>") % Markup().join(Markup("<li>%s</li>") % t.name for t in project.task_ids)
    ... )
    Markup('Liste de tÃ¢ches pour le projet &lt;R&amp;D&gt;: <ul><li>First &lt;R&amp;D&gt; task</li></ul>')

    >>> Markup("<p>Foo %</p>" % bar)  # bad, bar is not escaped
    >>> Markup("<p>Foo %</p>") % bar  # good, bar is escaped if text and kept if markup

    >>> link = Markup("<a>%s</a>") % self.name
    >>> message = "Click %s" % link  # bad, message is text and Markup did nothing
    >>> message = escape("Click %s") % link  # good, format two markup objects together

    >>> Markup(f"<p>Foo {self.bar}</p>")  # bad, bar is inserted before escaping
    >>> Markup("<p>Foo {bar}</p>").format(bar=self.bar)  # good, sorry no fstring

When working with translations, it is especially important to separate the HTML
from the text. The translation methods accepts a :class:`~markupsafe.Markup`
parameters and will escape the translation if it gets receives at least one.

.. code-block:: pycon

    >>> Markup("<p>%s</p>") % _("Hello <R&D>")
    Markup('<p>Bonjour &lt;R&amp;D&gt;</p>')
    >>> _("Order %s has been confirmed", Markup("<a>%s</a>") % order.name)
    Markup('Order <a>SO42</a> has been confirmed')
    >>> _("Message received from %(name)s <%(email)s>",
    ...   name=self.name,
    ...   email=Markup("<a href='mailto:%s'>%s</a>") % (self.email, self.email)
    Markup('Message received from Georges &lt;<a href=mailto:george@abitbol.example>george@abitbol.example</a>&gt;')


Escaping vs Sanitizing
----------------------

.. important::

    Escaping is always 100% mandatory when you mix data and code, no matter how
    safe the data

**Escaping** converts *TEXT* to *CODE*. It is absolutely mandatory to do it
every time you mix *DATA/TEXT* with *CODE* (e.g. generating HTML or python code
to be evaluated inside a `safe_eval`), because *CODE* always requires *TEXT* to
be encoded. It is critical for security, but it's also a question of
correctness. Even when there is no security risk (because the text is 100%
guarantee to be safe or trusted), it is still required (e.g. to avoid breaking
the layout in generated HTML).

Escaping will never break any feature, as long as the developer identifies which
variable contains *TEXT* and which contains *CODE*.

.. code-block:: python

    >>> from odoo.tools import html_escape, html_sanitize
    >>> data = "<R&D>" # `data` is some TEXT coming from somewhere

    # Escaping turns it into CODE, good!
    >>> code = html_escape(data)
    >>> code
    Markup('&lt;R&amp;D&gt;')

    # Now you can mix it with other code...
    >>> self.website_description = Markup("<strong>%s</strong>") % code

**Sanitizing** converts *CODE* to *SAFER CODE* (but not necessary *safe* code).
It does not work on *TEXT*. Sanitizing is only necessary when *CODE* is
untrusted, because it comes in full or in part from some user-provided data. If
the user-provided data is in the form of *TEXT* (e.g. the content from a form
filled by a user), and if that data was correctly escaped before putting it in
*CODE*, then sanitizing is useless (but can still be done). If however, the
user-provided data was **not escaped**, then sanitizing will **not** work as
expected.

.. code-block:: python

    # Sanitizing without escaping is BROKEN: data is corrupted!
    >>> html_sanitize(data)
    Markup('')

    # Sanitizing *after* escaping is OK!
    >>> html_sanitize(code)
    Markup('<p>&lt;R&amp;D&gt;</p>')

Sanitizing can break features, depending on whether the *CODE* is expected to
contain patterns that are not safe. That's why `fields.Html` and
`tools.html_sanitize()` have options to fine-tune the level of sanitization for
styles, etc. Those options have to be carefully considered depending on where
the data comes from, and the desired features. The sanitization safety is
balanced against sanitization breakages: the safer the sanitisation the more
likely it is to break things.

.. code-block:: python

    >>> code = "<p class='text-warning'>Important Information</p>"
    # this will remove the style, which may break features
    # but is necessary if the source is untrusted
    >>> html_sanitize(code, strip_classes=True)
    Markup('<p>Important Information</p>')

Evaluating content
------------------

Some may want to ``eval`` to parse user provided content. Using ``eval`` should
be avoided at all cost. A safer, sandboxed, method :class:`~odoo.tools.safe_eval`
can be used instead but still gives tremendous capabilities to the user running
it and must be reserved for trusted privileged users only as it breaks the
barrier between code and data.

.. code-block:: python

    # very bad
    domain = eval(self.filter_domain)
    return self.search(domain)

    # better but still not recommended
    from odoo.tools import safe_eval
    domain = safe_eval(self.filter_domain)
    return self.search(domain)

    # good
    from ast import literal_eval
    domain = literal_eval(self.filter_domain)
    return self.search(domain)

Parsing content does not need ``eval``

==========  ==================  ================================
Language    Data type           Suitable parser
==========  ==================  ================================
Python      int, float, etc.    int(), float()
Javascript  int, float, etc.    parseInt(), parseFloat()
Python      dict                json.loads(), ast.literal_eval()
Javascript  object, list, etc.  JSON.parse()
==========  ==================  ================================

Accessing object attributes
---------------------------

If the values of a record needs to be retrieved or modified dynamically, one may
want to use the ``getattr`` and ``setattr`` methods.

.. code-block:: python

    # unsafe retrieval of a field value
    def _get_state_value(self, res_id, state_field):
        record = self.sudo().browse(res_id)
        return getattr(record, state_field, False)

This code is however not safe as it allows to access any property of the record,
including private attributes or methods.

The ``__getitem__`` of a recordset has been defined and accessing a dynamic
field value can be easily achieved safely:

.. code-block:: python

    # better retrieval of a field value
    def _get_state_value(self, res_id, state_field):
        record = self.sudo().browse(res_id)
        return record[state_field]

The above method is obviously still too optimistic and additional verifications
on the record id and field value must be done.


==================================================
SECTION: testing.rst
PATH: developer/reference/backend/testing.rst
==================================================

.. _reference/testing:

============
Testing Odoo
============

There are many ways to test an application.  In Odoo, we have three kinds of
tests

- Python unit tests (see `Testing Python code`_): useful for testing model business logic
- JS unit tests (see `Testing JS code`_): useful to test the javascript code in isolation
- Tours (see `Integration Testing`_): tours simulate a real situation. They ensures that the
  python and the javascript parts properly talk to each other.

.. _testing/python:

Testing Python code
===================

Odoo provides support for testing modules using `Python's unittest library
<https://docs.python.org/3/library/unittest.html>`_.

To write tests, simply define a ``tests`` sub-package in your module, it will
be automatically inspected for test modules. Test modules should have a name
starting with ``test_`` and should be imported from ``tests/__init__.py``,
e.g.

.. code-block:: text

    your_module
    â”œâ”€â”€ ...
    â”œâ”€â”€ tests
    |   â”œâ”€â”€ __init__.py
    |   â”œâ”€â”€ test_bar.py
    |   â””â”€â”€ test_foo.py

and ``__init__.py`` contains::

    from . import test_foo, test_bar

.. warning::

    test modules which are not imported from ``tests/__init__.py`` will not be
    run

The test runner will simply run any test case, as described in the official
`unittest documentation`_, but Odoo provides a number of utilities and helpers
related to testing Odoo content (modules, mainly):

.. autoclass:: odoo.tests.TransactionCase
    :members: browse_ref, ref

.. autoclass:: odoo.tests.SingleTransactionCase
    :members: browse_ref, ref

.. autoclass:: odoo.tests.HttpCase
    :members: browse_ref, ref, url_open, browser_js

.. autofunction:: odoo.tests.tagged

By default, tests are run once right after the corresponding module has been
installed. Test cases can also be configured to run after all modules have
been installed, and not run right after the module installation::

  # coding: utf-8
  from odoo.tests import HttpCase, tagged

  # This test should only be executed after all modules have been installed.
  @tagged('-at_install', 'post_install')
  class WebsiteVisitorTests(HttpCase):
    def test_create_visitor_on_tracked_page(self):
        Page = self.env['website.page']

The most common situation is to use
:class:`~odoo.tests.TransactionCase` and test a property of a model
in each method::

    class TestModelA(TransactionCase):
        def test_some_action(self):
            record = self.env['model.a'].create({'field': 'value'})
            record.some_action()
            self.assertEqual(
                record.field,
                expected_field_value)

        # other tests...

.. note::

    Test methods must start with ``test_``

.. autoclass:: odoo.tests.Form
    :members:

.. autoclass:: odoo.tests.M2MProxy
    :members: add, remove, clear

.. autoclass:: odoo.tests.O2MProxy
    :members: new, edit, remove

Running tests
-------------

Tests are automatically run when installing or updating modules if
:option:`--test-enable <odoo-bin --test-enable>` was enabled when starting the
Odoo server.

.. _unittest documentation: https://docs.python.org/3/library/unittest.html

.. _developer/reference/testing/selection:

Test selection
--------------

In Odoo, Python tests can be tagged to facilitate the test selection when
running tests.

Subclasses of :class:`odoo.tests.BaseCase` (usually through
:class:`~odoo.tests.TransactionCase` or
:class:`~odoo.tests.HttpCase`) are automatically tagged with
``standard`` and ``at_install`` by default.

Invocation
~~~~~~~~~~

:option:`--test-tags <odoo-bin --test-tags>` can be used to select/filter tests
to run on the command-line. It implies :option:`--test-enable <odoo-bin --test-enable>`,
so it's not necessary to specify :option:`--test-enable <odoo-bin --test-enable>`
when using :option:`--test-tags <odoo-bin --test-tags>`.

This option defaults to ``+standard`` meaning tests tagged ``standard``
(explicitly or implicitly) will be run by default when starting Odoo
with :option:`--test-enable <odoo-bin --test-enable>`.

When writing tests, the :func:`~odoo.tests.tagged` decorator can be
used on **test classes** to add or remove tags.

The decorator's arguments are tag names, as strings.

.. danger:: :func:`~odoo.tests.tagged` is a class decorator, it has no
            effect on functions or methods

Tags can be prefixed with the minus (``-``) sign, to *remove* them instead of
add or select them e.g. if you don't want your test to be executed by
default you can remove the ``standard`` tag:

.. code-block:: python

    from odoo.tests import TransactionCase, tagged

    @tagged('-standard', 'nice')
    class NiceTest(TransactionCase):
        ...

This test will not be selected by default, to run it the relevant tag will
have to be selected explicitly:

.. code-block:: console

    $ odoo-bin --test-tags nice

Note that only the tests tagged ``nice`` are going to be executed. To run
*both* ``nice`` and ``standard`` tests, provide multiple values to
:option:`--test-tags <odoo-bin --test-tags>`: on the command-line, values
are *additive* (you're selecting all tests with *any* of the specified tags)

.. code-block:: console

    $ odoo-bin --test-tags nice,standard

The config switch parameter also accepts the ``+`` and ``-`` prefixes. The
``+`` prefix is implied and therefore, totally optional. The ``-`` (minus)
prefix is made to deselect tests tagged with the prefixed tags, even if they
are selected by other specified tags e.g. if there are ``standard`` tests which
are also tagged as ``slow`` you can run all standard tests *except* the slow
ones:

.. code-block:: console

    $ odoo-bin --test-tags 'standard,-slow'

When you write a test that does not inherit from the
:class:`~odoo.tests.BaseCase`, this test will not have the default tags,
you have to add them explicitly to have the test included in the default test
suite.  This is a common issue when using a simple ``unittest.TestCase`` as
they're not going to get run:

.. code-block:: python

    import unittest
    from odoo.tests import tagged

    @tagged('standard', 'at_install')
    class SmallTest(unittest.TestCase):
        ...

Besides tags you can also specify specific modules, classes or functions to
test. The full syntax of the format accepted by :option:`--test-tags <odoo-bin --test-tags>`
is:

.. code-block:: text

    [-][tag][/module][:class][.method]

So if you want to test the `stock_account` module, you can use:

    .. code-block:: console

        $ odoo-bin --test-tags /stock_account

If you want to test a specific function with a unique name, it can be specified
directly:

    .. code-block:: console

        $ odoo-bin --test-tags .test_supplier_invoice_forwarded_by_internal_user_without_supplier

This is equivalent to

    .. code-block:: console

        $ odoo-bin --test-tags /account:TestAccountIncomingSupplierInvoice.test_supplier_invoice_forwarded_by_internal_user_without_supplier

if the name of the test is unambiguous. Multiple modules, classes and functions
can be specified at once separated by a `,` like with regular tags.

.. _reference/testing/tags:

Special tags
~~~~~~~~~~~~

- ``standard``: All Odoo tests that inherit from
  :class:`~odoo.tests.BaseCase` are implicitly tagged standard.
  :option:`--test-tags <odoo-bin --test-tags>` also defaults to ``standard``.

  That means untagged test will be executed by default when tests are enabled.
- ``at_install``: Means that the test will be executed right after the module
  installation and before other modules are installed. This is a default
  implicit tag.
- ``post_install``: Means that the test will be executed after all the modules
  are installed. This is what you want for HttpCase tests most of the time.

  Note that this is *not exclusive* with ``at_install``, however since you
  will generally not want both ``post_install`` is usually paired with
  ``-at_install`` when tagging a test class.

Examples
~~~~~~~~

.. important::

    Tests will be executed only in installed modules. If you're starting from
    a clean database, you'll need to install the modules with the
    :option:`-i <odoo-bin -i>` switch at least once. After that it's no longer
    needed, unless you need to upgrade the module, in which case
    :option:`-u <odoo-bin -u>` can be used. For simplicity, those switches are
    not specified in the examples below.

Run only the tests from the sale module:

.. code-block:: console

    $ odoo-bin --test-tags /sale

Run the tests from the sale module but not the ones tagged as slow:

.. code-block:: console

    $ odoo-bin --test-tags '/sale,-slow'

Run only the tests from stock or tagged as slow:

.. code-block:: console

    $ odoo-bin --test-tags '-standard, slow, /stock'

.. note:: ``-standard`` is implicit (not required), and present for clarity

Testing JS code
===============

Testing a complex system is an important safeguard to prevent regressions and to
guarantee that some basic functionality still works. Since Odoo has a non trivial
codebase in Javascript, it is necessary to test it.

See the :doc:`Unit testing <../frontend/unit_testing>` to learn about the
various aspect of the front-end testing framework, or jump directly to one of the
sub-sections:

- :doc:`Hoot <../frontend/unit_testing/hoot>`

- :doc:`Web test helpers <../frontend/unit_testing/web_helpers>`

- :doc:`Mock server <../frontend/unit_testing/mock_server>`

.. _reference/testing/integration-testing:

Integration Testing
===================

Testing Python code and JS code separately is very useful, but it does not prove that the web client
and the server work together.  In order to do that, we can write another kind of test: tours.  A
tour is a mini scenario of some interesting business flow.  It explains a sequence of steps that
should be followed.  The test runner will then create a PhantomJs browser, point it to the proper
url and simulate the click and inputs, according to the scenario.

Writing a test tour
-------------------

Structure
~~~~~~~~~

To write a test tour for `your_module`, start with creating the required files:

.. code-block:: text

    your_module
    â”œâ”€â”€ ...
    â”œâ”€â”€ static
    |   â””â”€â”€ tests
    |       â””â”€â”€ tours
    |           â””â”€â”€ your_tour.js
    â”œâ”€â”€ tests
    |   â”œâ”€â”€ __init__.py
    |   â””â”€â”€ test_calling_the_tour.py
    â””â”€â”€ __manifest__.py

You can then:

- update :file:`__manifest__.py` to add :file:`your_tour.js` in the assets.

  .. code-block:: python

     'assets': {
         'web.assets_tests': [
             'your_module/static/tests/tours/your_tour.js',
         ],
     },

- update :file:`__init__.py` in the folder :file:`tests` to import :file:`test_calling_the_tour`.

.. seealso::
   - :ref:`Assets Bundle <reference/assets_bundle>`
   - :ref:`testing/python`

.. _testing/javascript/test:

Javascript
~~~~~~~~~~

#. Setup your tour by registering it.

   .. code-block:: javascript

      import tour from 'web_tour.tour';
      tour.register('rental_product_configurator_tour', {
          url: '/web',  // Here, you can specify any other starting url
      }, [
          // Your sequence of steps
      ]);

#. Add any step you want.

Every step contains at least a trigger. You can either use the `predefined steps
<{GITHUB_PATH}/addons/web_tour/static/src/tour_service/tour_utils.js#L426>`_ or write your own personalized
step.

Here are some example of steps:

.. example::

   .. code-block:: javascript

      // First step
      tour.stepUtils.showAppsMenuItem(),
      // Second step
      {
         trigger: '.o_app[data-menu-xmlid="your_module.maybe_your_module_menu_root"]',
         isActive: ['community'],  // Optional
         run: "click",
      }, {
          // Third step
      },

.. example::

   .. code-block:: javascript

      {
          trigger: '.js_product:has(strong:contains(Chair floor protection)) .js_add',
          run: "click",
      },

.. example::

   .. code-block:: javascript

      {
          isActive: ["mobile", "enterprise"],
          content: "Click on Add a product link",
          trigger: 'a:contains("Add a product")',
          tooltipPosition: "bottom",
          async run(helpers) { //Exactly the same as run: "click"
            helpers.click();
          }
      },

Here are some possible arguments for your personalized steps:

- **trigger**: Required, Selector/element to ``run`` an action on. The tour will
  wait until the element exists and is visible before ``run``-ing the
  action *on it*.
- **run**: Optional, Action to perform on the *trigger* element. If no ``run``,
  no action.

  The action can be:

  - A function, asynchronous, executed with the trigger's ``Tip`` as
    context (``this``) and the action helpers as parameter.
  - The name of one of the action helpers, which will be run on the
    trigger element:

    .. rst-class::  o-definition-list

    ``check``
        Ensures that the **trigger** element is checked. This helper is intended
        for `<input[type=checkbox]>` elements only.
    ``clear``
        Clears the value of the **trigger** element. This helper is
        intended for `<input>` or `<textarea>` elements only.
    ``click``
        Clicks the **trigger** element, performing all the relevant intermediate
        events.
    ``dblclick``,
        Same as ``click`` with two repetitions.
    :samp:`drag_and_drop {target}`
        Simulates the dragging of the **trigger** element over to the ``target``.
    :samp:`edit {content}`
        ``clear`` the element and then ``fill`` the ``content``.
    :samp:`editor {content}`
        Focus the **trigger** element (wysiwyg) and then ``press`` the ``content``.
    :samp:`fill {content}`
        Focus the **trigger** element and then ``press`` the ``content``. This helper is
        intended for `<input>` or `<textarea>` elements only.
    ``hover``
        Performs a hover sequence on the **trigger** element.
    :samp:`press {content}`
        Performs a keyboard event sequence.
    :samp:`range {content}`
        Focus the **trigger** element and set ``content`` as value. This helper is intended
        for `<input[type=range]>` elements only.
    :samp:`select {value}`
        Performs a selection event sequence on **trigger** element. Select the option by its
        ``value``. This helper is intended for `<select>` elements only.
    :samp:`selectByIndex {index}`
        Same as ``select`` but select the option by its ``index``. Note that first option has
        index 0.
    :samp:`selectByLabel {label}`
        Same as ``select`` but select the option by its ``label``.
    ``uncheck``
        Ensures that the **trigger** element is unchecked. This helper is intended
        for `<input[type=checkbox]>` elements only.


- **isActive**: Optional,
  Activates the step only if all conditions of isActive array are met.
  - Browser is in either **desktop** or **mobile** mode.
  - The tour concerns either **community** or **enterprise** edition.
  - The tour is run in either **auto** (runbot) or **manual** (onboarding) mode.
- **tooltipPosition**: Optional, ``"top"``, ``"right"``, ``"bottom"``, or
  ``"left"``. Where to position the tooltip relative to the **target**
  when running interactive tours.
- **content**: Optional but recommended, the content of the tooltip in
  interactive tours, also logged to the console so very useful to
  trace and debug automated tours.
- **timeout**: How long to wait until the step can ``run``, in
  milliseconds, 10000 (10 seconds).

.. important::

   The last step(s) of a tour should always return the client to a
   "stable" state (e.g. no ongoing editions) and ensure all
   side-effects (network requests) have finished running to avoid race
   conditions or errors during teardown.

.. seealso::
   - `jQuery documentation about find <https://api.jquery.com/find/>`_

Python
~~~~~~

To start a tour from a python test, make the class inherit from
:class:`~odoo.tests.HTTPCase`, and call `start_tour`:

.. code-block:: python

   def test_your_test(self):
       # Optional Setup
       self.start_tour("/web", "your_tour_name", login="admin")
       # Optional verifications

Writing an onboarding tour
--------------------------

Structure
~~~~~~~~~

To write an onboarding tour for `your_module`, start with creating the required files:

.. code-block:: text

    your_module
    â”œâ”€â”€ ...
    â”œâ”€â”€ data
    |   â””â”€â”€ your_tour.xml
    â”œâ”€â”€ static/src/js/tours/your_tour.js
    â””â”€â”€ __manifest__.py

You can then update :file:`__manifest__.py` to add :file:`your_tour.js` in the assets and :file:`your_tour.xml` in the data.

  .. code-block:: python

     'data': [
        'data/your_tour.xml',
     ],
     'assets': {
         'web.assets_backend': [
             'your_module/static/src/js/tours/your_tour.js',
         ],
     },

Javascript
~~~~~~~~~~

The javascript part is the same as for :ref: `the test tour <testing/javascript/test>`.

XML
~~~

When you have your tour in the javascript registry, you can create a record `web_tour.tour` in the xml, like that:

  .. code-block:: xml

      <?xml version="1.0" encoding="utf-8"?>
      <odoo>
          <record id="your_tour" model="web_tour.tour">
              <field name="name">your_tour</field>
              <field name="sequence">10</field>
              <field name="rainbow_man_message">Congrats, that was a great tour</field>
          </record>
      </odoo>

- `name`: Required, the name must be the same as the one in the
  javascript registry.
- `sequence`: Optional; determines the order to execute the
  onboarding tours. Defaults to 1000.
- `url`: Optional; the url where to start the tour. If ``url`` is ``False``,
  take the url from the registry. Defaults to "/odoo".
- `rainbow_man_message`: Optional; will show the message in the
  rainbow man effect at the completion of the tour. If ``rainbow_man_message`` is ``False``,
  there is no rainbow effect. Defaults to ``<b>Good job!</b> You went through all steps of this tour.``

Running onboarding tours
~~~~~~~~~~~~~~~~~~~~~~~~

They can all be started in their sequence order by toggling the :guilabel:`Onboarding` option in the user menu.
You can run specific onboarding tours by going to the :menuselection:`Settings --> Technical --> User Interface --> Tours`
and clicking on :guilabel:`Onboarding` or :guilabel:`Testing`.

- **Onboarding**: will execute the tour in interactive mode. That means the tour will show what to do and
  wait for interactions from the user.
- **Testing**: will execute the tour automatically. That means the tour will be executing all the step in
  front of the user.

Tour recorder
~~~~~~~~~~~~~

You can also create tours easily with the tour recorder. To do so, click on :guilabel:`Record` on the
onboarding tours view. When started, this tool will record all your interactions in Odoo.

The created tours are flagged in the onboarding tours view as **Custom**. These tours can also
be exported to a javascript file, ready to be put in your module.

Debugging tips
--------------

Observing test tours in a browser
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are three ways with different tradeoffs:

``watch=True``
**************

When running a tour locally via the test suite, the ``watch=True``
parameter can be added to the ``browser_js`` or ``start_tour``
call::

    self.start_tour("/web", "your_tour_name", watch=True)

This will automatically open a Chrome window with the tour being
run inside it.

**Advantages**
  - always works if the tour has Python setup / surrounding code, or multiple steps
  - runs entirely automatically (just select the test which launches the tour)
  - transactional (*should* always be runnable multiple times)
**Drawbacks**
  - only works locally
  - only works if the test / tour can run correctly locally

``debug=True``
**************

When running a tour locally via the test suite, the ``debug=True``
parameter can be added to the ``browser_js`` or ``start_tour``
call::

    self.start_tour("/web", "your_tour_name", debug=True)

This will automatically open a fullscreen Chrome window with opened
devtools and a debugger breakpoint set at the start of the tour. The tour
is ran with the debug=assets query parameter. When an error is thrown, the
debugger stops on the exception.

**Advantages**
  - Same advantages as mode `watch=True`
  - Easier to debug steps
**Drawbacks**
  - only works locally
  - only works if the test / tour can run correctly locally

Run via browser
***************

Test tours can also be launched via the browser UI by calling

.. code-block:: javascript

    odoo.startTour("tour_name");

in the javascript console, or by enabling :ref:`tests mode
<frontend/framework/tests_debug_mode>` by setting ``?debug=tests`` in
the URL.

**Advantages**
  - easier to run
  - can be used on production or test sites, not just local instances
  - allows running in "Onboarding" mode (manual steps)
**Drawbacks**
  - harder to use with test tours involving Python setup
  - may not work multiple times depending on tour side-effects

.. tip::

   It's possible to use this method to observe or interact with tours
   which require Python setup:

   - add a *python* breakpoint before the relevant tour is started
     (``start_tour`` or ``browser_js`` call)
   - when the breakpoint is hit, open the instance in your browser
   - run the tour

   At this point the Python setup will be visible to the browser, and
   the tour will be able to run.

   You may want to comment the ``start_tour`` or ``browser_js`` call
   if you also want the test to continue afterwards, depending on the
   tour's side-effects.

Screenshots and screencasts during browser_js tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When running tests that use ``HttpCase.browser_js`` from the command line, the Chrome
browser is used in headless mode. By default, if a test fails, a PNG screenshot is
taken at the moment of the failure and written in

.. code-block:: console

  '/tmp/odoo_tests/{db_name}/screenshots/'

Two new command line arguments were added since Odoo 13.0 to control this behavior:
:option:`--screenshots <odoo-bin --screenshots>` and :option:`--screencasts <odoo-bin --screencasts>`

Introspecting / debugging steps
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When trying to fix / debug a tour, the screenshots (on failure) are
not necessarily sufficient. In that case it can be useful to see
what's happening at some or each step.

While this is pretty easy when in an "onboarding" (as they're mostly
driven explicitly by the user) it's more complicated when running
"test" tours, or when running tours through the test suite. In that
case there are two main tricks:

- A step property ``break: true,`` in debug mode (debug=True).

  This adds a debugger breakpoint at the start of the step.
  You can then add your own wherever you need.

  **Advantages**
    - very simple
    - the tour continues as soon as you resume execution
  **Drawbacks**
    - page interaction is limited as all javascript is blocked

- A step property ``pause: true,`` in debug mode (debug=True).

  The tour will stop at the end of the step. This allows inspecting
  and interacting with the page until the developer is ready to
  resume by typing **play();** in the browser console.

  **Advantages**
    - allows interacting with the page
    - no useless (for this situation) debugger UI

- A step with a ``run() { debugger; }`` action.

  This can be added to an existing step, or can be a new dedicated
  step. Once the step's **trigger** is matched, the execution will
  stop all javascript execution.

  **Advantages**
    - simple
    - the tour continues as soon as you resume execution
  **Drawbacks**
    - page interaction is limited as all javascript is blocked
    - the debugger is triggered after trying to find targeted
      element defined in the step.

Performance Testing
===================

Query counts
------------

One of the ways to test performance is to measure database queries. Manually, this can be tested with the
`--log-sql` CLI parameter. If you want to establish the maximum number of queries for an operation,
you can use the :meth:`~odoo.tests.BaseCase.assertQueryCount` method, integrated in Odoo test classes.

.. code-block:: python

    with self.assertQueryCount(11):
        do_something()

.. _qunit: https://qunitjs.com/
.. _qunit_config.js: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/static/tests/helpers/qunit_config.js#L49
.. _web.tests_assets: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/views/webclient_templates.xml#L594
.. _controller: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/controllers/main.py#L637
.. _test_js.py: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/tests/test_js.py#L13
.. _test_utils.js: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/static/tests/helpers/test_utils.js
.. _mock server: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/static/tests/helpers/mock_server.js
.. _qunit assertions: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/static/tests/helpers/qunit_asserts.js
.. _createView: https://github.com/odoo/odoo/blob/51ee0c3cb59810449a60dae0b086b49b1ed6f946/addons/web/static/tests/helpers/test_utils_create.js#L267
